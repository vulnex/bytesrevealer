/**
 * Kaitai Formats - Common
 * 7 formats
 * Auto-generated: 2025-09-21T19:51:05.638Z
 */

export const commonFormats = [
  {
    "id": "ksy_bcd",
    "name": "BCD (Binary Coded Decimals)",
    "category": "Common",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "BCD (Binary Coded Decimals)",
      "originalCategory": "common",
      "filePath": "common/bcd.ksy"
    },
    "content": "meta:\n  id: bcd\n  title: BCD (Binary Coded Decimals)\n  xref:\n    justsolve: Binary-coded_decimal\n    wikidata: Q276582\n  license: CC0-1.0\n  ks-version: 0.8\ndoc: |\n  BCD (Binary Coded Decimals) is a common way to encode integer\n  numbers in a way that makes human-readable output somewhat\n  simpler. In this encoding scheme, every decimal digit is encoded as\n  either a single byte (8 bits), or a nibble (half of a byte, 4\n  bits). This obviously wastes a lot of bits, but it makes translation\n  into human-readable string much easier than traditional\n  binary-to-decimal conversion process, which includes lots of\n  divisions by 10.\n\n  For example, encoding integer 31337 in 8-digit, 8 bits per digit,\n  big endian order of digits BCD format yields\n\n  ```\n  00 00 00 03 01 03 03 07\n  ```\n\n  Encoding the same integer as 8-digit, 4 bits per digit, little\n  endian order BCD format would yield:\n\n  ```\n  73 31 30 00\n  ```\n\n  Using this type of encoding in Kaitai Struct is pretty\n  straightforward: one calls for this type, specifying desired\n  encoding parameters, and gets result using either `as_int` or\n  `as_str` attributes.\nparams:\n  - id: num_digits\n    type: u1\n    doc: Number of digits in this BCD representation. Only values from 1 to 8 inclusive are supported.\n  - id: bits_per_digit\n    type: u1\n    doc: Number of bits per digit. Only values of 4 and 8 are supported.\n  - id: is_le\n    type: bool\n    doc: Endianness used by this BCD representation. True means little-endian, false is for big-endian.\nseq:\n  - id: digits\n    type:\n      switch-on: bits_per_digit\n      cases:\n        4: b4\n        8: u1\n    repeat: expr\n    repeat-expr: num_digits\ninstances:\n  as_int:\n    value: 'is_le ? as_int_le : as_int_be'\n    doc: Value of this BCD number as integer. Endianness would be selected based on `is_le` parameter given.\n  as_int_le:\n    value: >\n      digits[0] +\n      (num_digits < 2 ? 0 :\n       (digits[1] * 10 +\n        (num_digits < 3 ? 0 :\n         (digits[2] * 100 +\n          (num_digits < 4 ? 0 :\n           (digits[3] * 1000 +\n            (num_digits < 5 ? 0 :\n             (digits[4] * 10000 +\n              (num_digits < 6 ? 0 :\n               (digits[5] * 100000 +\n                (num_digits < 7 ? 0 :\n                 (digits[6] * 1000000 +\n                  (num_digits < 8 ? 0 :\n                   (digits[7] * 10000000)\n                  )\n                 )\n                )\n               )\n              )\n             )\n            )\n           )\n          )\n         )\n        )\n       )\n      )\n    doc: Value of this BCD number as integer (treating digit order as little-endian).\n  last_idx:\n    value: num_digits - 1\n    doc: Index of last digit (0-based).\n  as_int_be:\n    value: >\n      digits[last_idx] +\n      (num_digits < 2 ? 0 :\n       (digits[last_idx - 1] * 10 +\n        (num_digits < 3 ? 0 :\n         (digits[last_idx - 2] * 100 +\n          (num_digits < 4 ? 0 :\n           (digits[last_idx - 3] * 1000 +\n            (num_digits < 5 ? 0 :\n             (digits[last_idx - 4] * 10000 +\n              (num_digits < 6 ? 0 :\n               (digits[last_idx - 5] * 100000 +\n                (num_digits < 7 ? 0 :\n                 (digits[last_idx - 6] * 1000000 +\n                  (num_digits < 8 ? 0 :\n                   (digits[last_idx - 7] * 10000000)\n                  )\n                 )\n                )\n               )\n              )\n             )\n            )\n           )\n          )\n         )\n        )\n       )\n      )\n    doc: Value of this BCD number as integer (treating digit order as big-endian).\n"
  },
  {
    "id": "ksy_bytes_with_io",
    "name": "Byte array with an `_io` member",
    "category": "Common",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "Byte array with an `_io` member",
      "originalCategory": "common",
      "filePath": "common/bytes_with_io.ksy"
    },
    "content": "meta:\n  id: bytes_with_io\n  title: Byte array with an `_io` member\n  license: MIT\ndoc: |\n  Helper type to work around Kaitai Struct not providing an `_io` member for plain byte arrays.\nseq:\n  - id: data\n    size-eos: true\n    doc: The actual data.\n"
  },
  {
    "id": "ksy_dos_datetime",
    "name": "MS-DOS datetime",
    "category": "Common",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "MS-DOS datetime",
      "originalCategory": "common",
      "filePath": "common/dos_datetime.ksy"
    },
    "content": "meta:\n  id: dos_datetime\n  title: MS-DOS datetime\n  xref:\n    justsolve: MS-DOS_date/time\n  tags:\n    - dos\n  license: CC0-1.0\n  ks-version: 0.9\n  bit-endian: le\ndoc: |\n  MS-DOS date and time are packed 16-bit values that specify local date/time.\n  The time is always stored in the current UTC time offset set on the computer\n  which created the file. Note that the daylight saving time (DST) shifts\n  also change the UTC time offset.\n\n  For example, if you pack two files A and B into a ZIP archive, file A last modified\n  at 2020-03-29 00:59 UTC+00:00 (GMT) and file B at 2020-03-29 02:00 UTC+01:00 (BST),\n  the file modification times saved in MS-DOS format in the ZIP file will vary depending\n  on whether the computer packing the files is set to GMT or BST at the time of ZIP creation.\n\n    - If set to GMT:\n        - file A: 2020-03-29 00:59 (UTC+00:00)\n        - file B: 2020-03-29 01:00 (UTC+00:00)\n    - If set to BST:\n        - file A: 2020-03-29 01:59 (UTC+01:00)\n        - file B: 2020-03-29 02:00 (UTC+01:00)\n\n  It follows that you are unable to determine the actual last modified time\n  of any file stored in the ZIP archive, if you don't know the locale time\n  setting of the computer at the time it created the ZIP.\n\n  This format is used in some data formats from the MS-DOS era, for example:\n\n    - [zip](/zip/)\n    - [rar](/rar/)\n    - [vfat](/vfat/) (FAT12)\n    - [lzh](/lzh/)\n    - [cab](http://justsolve.archiveteam.org/wiki/Cabinet)\n\ndoc-ref:\n  - https://learn.microsoft.com/en-us/windows/win32/sysinfo/ms-dos-date-and-time\n  - https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-dosdatetimetofiletime\n  - https://github.com/reactos/reactos/blob/c6b64448ce4/dll/win32/kernel32/client/time.c#L82-L87 DosDateTimeToFileTime\n  - https://download.microsoft.com/download/0/8/4/084c452b-b772-4fe5-89bb-a0cbf082286a/fatgen103.doc page 25/34\n-webide-representation: \"{date} {time}\"\nseq:\n  - id: time\n    type: time\n  - id: date\n    type: date\ntypes:\n  time:\n    -webide-representation: \"{padded_hour}:{padded_minute}:{padded_second}\"\n    seq:\n      - id: second_div_2\n        type: b5\n        valid:\n          max: 29 # 0-58 seconds\n      - id: minute\n        type: b6\n        valid:\n          max: 59\n      - id: hour\n        type: b5\n        valid:\n          max: 23\n    instances:\n      second:\n        value: 2 * second_div_2\n      padded_second:\n        value: '(second <= 9 ? \"0\" : \"\") + second.to_s'\n      padded_minute:\n        value: '(minute <= 9 ? \"0\" : \"\") + minute.to_s'\n      padded_hour:\n        value: '(hour <= 9 ? \"0\" : \"\") + hour.to_s'\n  date:\n    -webide-representation: \"{padded_year}-{padded_month}-{padded_day}\"\n    seq:\n      - id: day\n        type: b5\n        valid:\n          min: 1\n      - id: month\n        type: b4\n        valid:\n          min: 1\n          max: 12\n      - id: year_minus_1980\n        type: b7\n    instances:\n      year:\n        value: 1980 + year_minus_1980\n        doc: only years from 1980 to 2107 (1980 + 127) can be represented\n      padded_day:\n        value: '(day <= 9 ? \"0\" : \"\") + day.to_s'\n      padded_month:\n        value: '(month <= 9 ? \"0\" : \"\") + month.to_s'\n      padded_year:\n        value: |\n          (year <= 999 ? \"0\" +\n            (year <= 99 ? \"0\" +\n              (year <= 9 ? \"0\" : \"\")\n            : \"\")\n          : \"\") + year.to_s\n"
  },
  {
    "id": "ksy_riff",
    "name": "Resource Interchange File Format (RIFF)",
    "category": "Common",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "Resource Interchange File Format (RIFF)",
      "originalCategory": "common",
      "filePath": "common/riff.ksy",
      "endian": "le"
    },
    "content": "meta:\n  id: riff\n  title: Resource Interchange File Format (RIFF)\n  xref:\n    justsolve: RIFF\n    loc: fdd000025\n    wikidata: Q1196805\n  license: CC0-1.0\n  endian: le\ndoc: |\n  The Resource Interchange File Format (RIFF) is a generic file container format\n  for storing data in tagged chunks. It is primarily used to store multimedia\n  such as sound and video, though it may also be used to store any arbitrary data.\n\n  The Microsoft implementation is mostly known through container formats\n  like AVI, ANI and WAV, which use RIFF as their basis.\ndoc-ref: https://www.johnloomis.org/cpe102/asgn/asgn1/riff.html\nseq:\n  - id: chunk\n    type: chunk\ninstances:\n  chunk_id:\n    value: chunk.id\n    enum: fourcc\n  is_riff_chunk:\n    value: 'chunk_id == fourcc::riff'\n  parent_chunk_data:\n    io: chunk.data_slot._io\n    pos: 0\n    type: parent_chunk_data\n    if: is_riff_chunk\n  subchunks:\n    io: parent_chunk_data.subchunks_slot._io\n    pos: 0\n    type: chunk_type\n    repeat: eos\n    if: is_riff_chunk\ntypes:\n  chunk:\n    seq:\n      - id: id\n        type: u4\n      - id: len\n        type: u4\n      - id: data_slot\n        type: slot\n        size: len\n      - id: pad_byte\n        size: len % 2 # if size is odd, there is 1 padding byte\n    types:\n      slot: {} # Keeps _io for later use of same substream\n  parent_chunk_data:\n    seq:\n      - id: form_type\n        type: u4\n      - id: subchunks_slot\n        type: slot\n        size-eos: true\n    types:\n      slot: {} # Keeps _io for later use of same substream\n\n  chunk_type:\n    seq:\n      - id: save_chunk_ofs\n        size: 0\n        if: chunk_ofs < 0\n      - id: chunk\n        type: chunk\n    instances:\n      chunk_ofs:\n        value: _io.pos\n      chunk_id:\n        value: chunk.id\n        enum: fourcc\n      chunk_id_readable:\n        pos: chunk_ofs\n        size: 4\n        type: str\n        encoding: ASCII\n      chunk_data:\n        io: chunk.data_slot._io\n        pos: 0\n        type:\n          switch-on: chunk_id\n          cases:\n            'fourcc::list': list_chunk_data\n  list_chunk_data:\n    seq:\n      - id: save_parent_chunk_data_ofs\n        size: 0\n        if: parent_chunk_data_ofs < 0\n      - id: parent_chunk_data\n        type: parent_chunk_data\n    instances:\n      parent_chunk_data_ofs:\n        value: _io.pos\n      form_type:\n        value: parent_chunk_data.form_type\n        enum: fourcc\n      form_type_readable:\n        pos: parent_chunk_data_ofs\n        size: 4\n        type: str\n        encoding: ASCII\n      subchunks:\n        io: parent_chunk_data.subchunks_slot._io\n        pos: 0\n        type:\n          switch-on: form_type\n          cases:\n            'fourcc::info': info_subchunk\n            _: chunk_type\n        repeat: eos\n  info_subchunk:\n    meta:\n      encoding: UTF-8\n    doc: |\n      All registered subchunks in the INFO chunk are NULL-terminated strings,\n      but the unregistered might not be. By convention, the registered\n      chunk IDs are in uppercase and the unregistered IDs are in lowercase.\n\n      If the chunk ID of an INFO subchunk contains a lowercase\n      letter, this chunk is considered as unregistered and thus we can make\n      no assumptions about the type of data.\n    seq:\n      - id: save_chunk_ofs\n        size: 0\n        if: chunk_ofs < 0\n      - id: chunk\n        type: chunk\n    instances:\n      chunk_ofs:\n        value: _io.pos\n      chunk_id_readable:\n        value: id_chars.to_s('ASCII')\n      chunk_data:\n        io: chunk.data_slot._io\n        pos: 0\n        type:\n          switch-on: is_unregistered_tag\n          cases:\n            false: strz\n      id_chars:\n        pos: chunk_ofs\n        size: 4\n      is_unregistered_tag:\n        value: >-\n          (id_chars[0] >= 97 and id_chars[0] <= 122) or\n          (id_chars[1] >= 97 and id_chars[1] <= 122) or\n          (id_chars[2] >= 97 and id_chars[2] <= 122) or\n          (id_chars[3] >= 97 and id_chars[3] <= 122)\n        doc: |\n          Check if chunk_id contains lowercase characters ([a-z], ASCII 97 = a, ASCII 122 = z).\nenums:\n  fourcc:\n  # little-endian\n    0x46464952: riff\n    0x5453494c: list\n    0x4f464e49: info\n"
  },
  {
    "id": "ksy_utf8_string",
    "name": "UTF-8-encoded string",
    "category": "Common",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [
        "txt"
      ],
      "description": "UTF-8-encoded string",
      "originalCategory": "common",
      "filePath": "common/utf8_string.ksy"
    },
    "content": "meta:\n  id: utf8_string\n  title: UTF-8-encoded string\n  file-extension: txt\n  xref:\n    wikidata: Q193537\n  license: CC0-1.0\ndoc: |\n  UTF-8 is a popular character encoding scheme that allows to\n  represent strings as sequence of code points defined in Unicode\n  standard. Its features are:\n\n  * variable width (i.e. one code point might be represented by 1 to 4\n    bytes)\n  * backward compatiblity with ASCII\n  * basic validity checking (and thus distinguishing from other legacy\n    8-bit encodings)\n  * maintaining sort order of codepoints if sorted as a byte array\n\n  WARNING: For the vast majority of practical purposes of format\n  definitions in Kaitai Struct, you'd likely NOT want to use this and\n  rather just use `type: str` with `encoding: utf-8`. That will use\n  native string implementations, which are most likely more efficient\n  and will give you native language strings, rather than an array of\n  individual codepoints.  This format definition is provided mostly\n  for educational / research purposes.\nseq:\n  - id: codepoints\n    type: utf8_codepoint(_io.pos)\n    repeat: eos\ntypes:\n  utf8_codepoint:\n    -webide-representation: 'U+{value_as_int:hex}'\n    params:\n      - id: ofs\n        type: u8\n    seq:\n      - id: bytes\n        size: len_bytes\n    instances:\n      byte0:\n        pos: ofs\n        type: u1\n      len_bytes:\n        value: |\n          (byte0 & 0b1000_0000 == 0) ? 1 :\n          (byte0 & 0b1110_0000 == 0b1100_0000) ? 2 :\n          (byte0 & 0b1111_0000 == 0b1110_0000) ? 3 :\n          (byte0 & 0b1111_1000 == 0b1111_0000) ? 4 :\n          -1\n      raw0:\n        value: |\n          bytes[0] & (\n            len_bytes == 1 ? 0b0111_1111 :\n            len_bytes == 2 ? 0b0001_1111 :\n            len_bytes == 3 ? 0b0000_1111 :\n            len_bytes == 4 ? 0b0000_0111 :\n            0\n          )\n      raw1:\n        value: 'bytes[1] & 0b0011_1111'\n        if: len_bytes >= 2\n      raw2:\n        value: 'bytes[2] & 0b0011_1111'\n        if: len_bytes >= 3\n      raw3:\n        value: 'bytes[3] & 0b0011_1111'\n        if: len_bytes >= 4\n      value_as_int:\n        value: >\n          len_bytes == 1 ? raw0 :\n          len_bytes == 2 ? ((raw0 << 6) | raw1) :\n          len_bytes == 3 ? ((raw0 << 12) | (raw1 << 6) | raw2) :\n          len_bytes == 4 ? ((raw0 << 18) | (raw1 << 12) | (raw2 << 6) | raw3) :\n          -1\n"
  },
  {
    "id": "ksy_vlq_base128_be",
    "name": "Variable length quantity, unsigned integer, base128, big-endian",
    "category": "Common",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "Variable length quantity, unsigned integer, base128, big-endian",
      "originalCategory": "common",
      "filePath": "common/vlq_base128_be.ksy"
    },
    "content": "meta:\n  id: vlq_base128_be\n  title: Variable length quantity, unsigned integer, base128, big-endian\n  xref:\n    justsolve: Variable-length_quantity\n    wikidata: Q7915686\n  license: CC0-1.0\n  ks-version: 0.9\n  bit-endian: be\ndoc: |\n  A variable-length unsigned integer using base128 encoding. 1-byte groups\n  consist of 1-bit flag of continuation and 7-bit value chunk, and are ordered\n  \"most significant group first\", i.e. in \"big-endian\" manner.\n\n  This particular encoding is specified and used in:\n\n  * Standard MIDI file format\n  * ASN.1 BER encoding\n  * RAR 5.0 file format\n\n  More information on this encoding is available at\n  <https://en.wikipedia.org/wiki/Variable-length_quantity>\n\n  This particular implementation supports serialized values to up 8 bytes long.\n-webide-representation: '{value:dec}'\nseq:\n  - id: groups\n    type: group\n    repeat: until\n    repeat-until: not _.has_next\ntypes:\n  group:\n    -webide-representation: '{value}'\n    doc: |\n      One byte group, clearly divided into 7-bit \"value\" chunk and 1-bit \"continuation\" flag.\n    seq:\n      - id: has_next\n        type: b1\n        doc: If true, then we have more bytes to read\n      - id: value\n        type: b7\n        doc: The 7-bit (base128) numeric value chunk of this group\ninstances:\n  last:\n    value: groups.size - 1\n  value:\n    value: |\n      (groups[last].value\n      + (last >= 1 ? (groups[last - 1].value << 7) : 0)\n      + (last >= 2 ? (groups[last - 2].value << 14) : 0)\n      + (last >= 3 ? (groups[last - 3].value << 21) : 0)\n      + (last >= 4 ? (groups[last - 4].value << 28) : 0)\n      + (last >= 5 ? (groups[last - 5].value << 35) : 0)\n      + (last >= 6 ? (groups[last - 6].value << 42) : 0)\n      + (last >= 7 ? (groups[last - 7].value << 49) : 0)).as<u8>\n    doc: Resulting value as normal integer\n"
  },
  {
    "id": "ksy_vlq_base128_le",
    "name": "Variable length quantity, unsigned/signed integer, base128, little-endian",
    "category": "Common",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "Variable length quantity, unsigned/signed integer, base128, little-endian",
      "originalCategory": "common",
      "filePath": "common/vlq_base128_le.ksy"
    },
    "content": "meta:\n  id: vlq_base128_le\n  title: Variable length quantity, unsigned/signed integer, base128, little-endian\n  xref:\n    justsolve: Variable-length_quantity\n    wikidata: Q6457577\n  license: CC0-1.0\n  ks-version: '0.10'\n  bit-endian: be\ndoc: |\n  A variable-length unsigned/signed integer using base128 encoding. 1-byte groups\n  consist of 1-bit flag of continuation and 7-bit value chunk, and are ordered\n  \"least significant group first\", i.e. in \"little-endian\" manner.\n\n  This particular encoding is specified and used in:\n\n  * DWARF debug file format, where it's dubbed \"unsigned LEB128\" or \"ULEB128\".\n    <https://dwarfstd.org/doc/dwarf-2.0.0.pdf> - page 139\n  * Google Protocol Buffers, where it's called \"Base 128 Varints\".\n    <https://protobuf.dev/programming-guides/encoding/#varints>\n  * Apache Lucene, where it's called \"VInt\"\n    <https://lucene.apache.org/core/3_5_0/fileformats.html#VInt>\n  * Apache Avro uses this as a basis for integer encoding, adding ZigZag on\n    top of it for signed ints\n    <https://avro.apache.org/docs/1.12.0/specification/#primitive-types-1>\n\n  More information on this encoding is available at <https://en.wikipedia.org/wiki/LEB128>\n\n  This particular implementation supports integer values up to 64 bits (i.e. the\n  maximum unsigned value supported is `2**64 - 1`), which implies that serialized\n  values can be up to 10 bytes in length.\n\n  If the most significant 10th byte (`groups[9]`) is present, its `has_next`\n  must be `false` (otherwise we would have 11 or more bytes, which is not\n  supported) and its `value` can be only `0` or `1` (because a 9-byte VLQ can\n  represent `9 * 7 = 63` bits already, so the 10th byte can only add 1 bit,\n  since only integers up to 64 bits are supported). These restrictions are\n  enforced by this implementation. They were inspired by the Protoscope tool,\n  see <https://github.com/protocolbuffers/protoscope/blob/8e7a6aafa2c9958527b1e0747e66e1bfff045819/writer.go#L644-L648>.\n-webide-representation: '{value:dec}'\nseq:\n  - id: groups\n    # NOTE: with KSC 0.11, handling `_index == 9` as a special case is needed\n    # for PHP, otherwise `TypeError: Argument #3 ($multiplier) must be of type\n    # int, float given` would occur.\n    type: |\n      group(\n        _index,\n        _index != 0 ? groups[_index - 1].interm_value : 0,\n        _index != 0 ? (_index == 9 ? 0x8000_0000_0000_0000 : groups[_index - 1].multiplier * 128) : 1\n      )\n    repeat: until\n    repeat-until: not _.has_next\ntypes:\n  group:\n    -webide-representation: '{value}'\n    doc: |\n      One byte group, clearly divided into 7-bit \"value\" chunk and 1-bit \"continuation\" flag.\n    params:\n      - id: idx\n        type: s4\n      - id: prev_interm_value\n        type: u8\n      - id: multiplier\n        type: u8\n    seq:\n      - id: has_next\n        type: b1\n        valid: 'idx == 9 ? false : has_next'\n        doc: |\n          If `true`, then we have more bytes to read.\n\n          Since this implementation only supports serialized values up to 10\n          bytes, this must be `false` in the 10th group (`groups[9]`).\n      - id: value\n        type: b7\n        valid:\n          # # As of KSC 0.11, this causes `if (!(_value <= (Idx == 9 ? 1 :\n          # # 127))) { throw new ValidationGreaterThanError(...); }` to be\n          # # generated in the C# code, which fails to compile with the message\n          # # `error CS0034: Operator '<=' is ambiguous on operands of type\n          # # 'ulong' and 'int'`. To work around that, we add type casting\n          # # (`.as<u8>`).\n          # max: 'idx == 9 ? 1 : 0b111_1111'\n          max: '(idx == 9 ? 1 : 0b111_1111).as<u8>'\n        doc: |\n          The 7-bit (base128) numeric value chunk of this group\n\n          Since this implementation only supports integer values up to 64 bits,\n          the `value` in the 10th group (`groups[9]`) can only be `0` or `1`\n          (otherwise the width of the represented value would be 65 bits or\n          more, which is not supported).\n    instances:\n      interm_value:\n        # We intentionally use addition (`+`) and multiplication (`*`), not\n        # bitwise OR (`|`) and left shift (`<<`), in order to get better\n        # precision in JavaScript, especially with respect to the Web IDE. Using\n        # any bitwise operators (like `|` and `<<`) in JavaScript truncates the\n        # result to a signed 32-bit integer (except `>>>`, which yields an\n        # unsigned 32-bit integer).\n        #\n        # Avoiding bitwise operators allows greater precision than 32 bits. We\n        # are still limited by the fact that the built-in `Number` type in\n        # JavaScript can only exactly represent integers from `-2**53 + 1` to\n        # `2**53 - 1` (these bounds are available as constants\n        # `Number.MIN_SAFE_INTEGER` and `Number.MAX_SAFE_INTEGER`), so for any\n        # integer that requires more than 53 bits of precision, we get\n        # approximate values. But 53 bits is still better than 32.\n        #\n        # Full 64-bit integer support in JavaScript is only possible via the\n        # `BigInt` type: https://github.com/kaitai-io/kaitai_struct/issues/183\n        value: (prev_interm_value + value * multiplier).as<u8>\ninstances:\n  len:\n    value: groups.size\n  value:\n    value: groups.last.interm_value\n    doc: Resulting unsigned value as normal integer\n  sign_bit:\n    value: '(len == 10 ? 0x8000_0000_0000_0000 : groups.last.multiplier * 0b100_0000).as<u8>'\n  value_signed:\n    # NOTE 1: the expression `-(sign_bit - (value - sign_bit))` performing\n    # signed extension is carefully written to avoid overflows in statically\n    # typed languages like C++ (where they would cause undefined behavior) or\n    # Nim. The goal is to achieve mathematically exactly `value - 2 * sign_bit`.\n    #\n    # NOTE 2: the `sign_bit > 0` check is a hack for PHP (it is required only\n    # because KSC 0.11 does not abstract from the fact that PHP has only\n    # **signed** 64-bit integers, which should be considered a bug because it\n    # reduces portability between target languages). Since PHP only has signed\n    # 64-bit integers, `sign_bit` will be `-0x8000_0000_0000_0000` if\n    # `len == 10`, so the `value >= sign_bit` condition that is supposed to\n    # detect whether the sign bit is set will not work (in reality, it will be\n    # true for any `value`). However, the sign extension would only cause the\n    # value to overflow and become a `float`. The fix in this case is to return\n    # `value` as is, since it already represents the correct signed value.\n    value: 'sign_bit > 0 and value >= sign_bit ? -(sign_bit - (value - sign_bit)).as<s8> : value.as<s8>'\n    # # We don't use this anymore again because of JavaScript as explained\n    # # above. Since it relies on bitwise XOR (`^`), it would truncate the value\n    # # to 32 bits in the Web IDE.\n    # value: '((value ^ sign_bit).as<s8> - sign_bit.as<s8>).as<s8>'\n    # doc-ref: https://graphics.stanford.edu/~seander/bithacks.html#VariableSignExtend\n"
  }
];

export default {
  category: "Common",
  formats: commonFormats
};
