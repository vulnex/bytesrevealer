/**
 * Kaitai Formats - File System
 * 17 formats
 * Auto-generated: 2025-09-21T19:51:05.639Z
 */

export const file_systemFormats = [
  {
    "id": "ksy_amlogic_emmc_partitions",
    "name": "Amlogic proprietary eMMC partition table",
    "category": "File System",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "Amlogic proprietary eMMC partition table",
      "originalCategory": "filesystem",
      "filePath": "filesystem/amlogic_emmc_partitions.ksy",
      "signature": {
        "offset": 0,
        "bytes": [
          null,
          0
        ]
      },
      "endian": "le"
    },
    "content": "meta:\n  id: amlogic_emmc_partitions\n  title: Amlogic proprietary eMMC partition table\n  license: CC0-1.0\n  ks-version: 0.9\n  encoding: UTF-8\n  endian: le\n  bit-endian: le\n\ndoc: |\n  This is an unnamed and undocumented partition table format implemented by\n  the bootloader and kernel that Amlogic provides for their Linux SoCs (Meson\n  series at least, and probably others). They appear to use this rather than GPT,\n  the industry standard, because their BootROM loads and executes the next stage\n  loader from offset 512 (0x200) on the eMMC, which is exactly where the GPT\n  header would have to start. So instead of changing their BootROM, Amlogic\n  devised this partition table, which lives at an offset of 36MiB (0x240_0000)\n  on the eMMC and so doesn't conflict. This parser expects as input just the\n  partition table from that offset. The maximum number of partitions in a table\n  is 32, which corresponds to a maximum table size of 1304 bytes (0x518).\n\ndoc-ref:\n  - http://aml-code.amlogic.com/kernel/common.git/tree/include/linux/mmc/emmc_partitions.h?id=18a4a87072ababf76ea08c8539e939b5b8a440ef\n  - http://aml-code.amlogic.com/kernel/common.git/tree/drivers/amlogic/mmc/emmc_partitions.c?id=18a4a87072ababf76ea08c8539e939b5b8a440ef\n\nseq:\n  - id: magic\n    contents: [\"MPT\", 0]\n  - id: version\n    size: 12\n    type: strz\n  - id: num_partitions\n    -orig-id: part_num\n    type: s4\n    valid:\n      min: 1\n      max: 32\n  - id: checksum\n    type: u4\n    doc: |\n      To calculate this, treat the first (and only the first) partition\n      descriptor in the table below as an array of unsigned little-endian\n      32-bit integers. Sum all those integers mod 2^32, then multiply the\n      result by the total number of partitions, also mod 2^32. Amlogic\n      likely meant to include all the partition descriptors in the sum,\n      but their code as written instead repeatedly loops over the first\n      one, once for each partition in the table.\n  - id: partitions\n    type: partition\n    repeat: expr\n    repeat-expr: num_partitions\n\ntypes:\n  partition:\n    seq:\n      - id: name\n        size: 16\n        type: strz\n      - id: size\n        type: u8\n      - id: offset\n        type: u8\n        doc: |\n          The start of the partition relative to the start of the eMMC, in bytes\n      - id: flags\n        size: 4\n        type: part_flags\n      - id: padding\n        size: 4\n\n    types:\n      part_flags:\n        seq:\n          - id: is_code\n            -orig-id: STORE_CODE\n            type: b1\n          - id: is_cache\n            -orig-id: STORE_CACHE\n            type: b1\n          - id: is_data\n            -orig-id: STORE_DATA\n            type: b1\n"
  },
  {
    "id": "ksy_android_super",
    "name": "Android Dynamic Partitions metadata",
    "category": "File System",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [
        "img"
      ],
      "description": "Android Dynamic Partitions metadata",
      "originalCategory": "filesystem",
      "filePath": "filesystem/android_super.ksy",
      "endian": "le"
    },
    "content": "meta:\n  id: android_super\n  title: Android Dynamic Partitions metadata\n  application: Android\n  file-extension: img\n  tags:\n    - android\n    - filesystem\n  license: CC0-1.0\n  ks-version: 0.9\n  bit-endian: le\n  endian: le\n\ndoc: |\n  The metadata stored by Android at the beginning of a \"super\" partition, which\n  is what it calls a disk partition that holds one or more Dynamic Partitions.\n  Dynamic Partitions do more or less the same thing that LVM does on Linux,\n  allowing Android to map ranges of non-contiguous extents to a single logical\n  device. This metadata holds that mapping.\n\ndoc-ref:\n  - https://source.android.com/docs/core/ota/dynamic_partitions\n  - https://android.googlesource.com/platform/system/core/+/refs/tags/android-11.0.0_r8/fs_mgr/liblp/include/liblp/metadata_format.h\n\ninstances:\n  root:\n    pos: 0x1000\n    type: root\n\ntypes:\n  root:\n    seq:\n      - id: primary_geometry\n        size: 0x1000\n        type: geometry\n\n      - id: backup_geometry\n        type: geometry\n        size: 0x1000\n\n      - id: primary_metadata\n        size: primary_geometry.metadata_max_size\n        type: metadata\n        repeat: expr\n        repeat-expr: primary_geometry.metadata_slot_count\n\n      - id: backup_metadata\n        # These attributes are intentionally taken from primary_geometry, even\n        # for backup_metadata. The first non-corrupt geometry specifier dictates\n        # the layout of both primary and backup metadata.\n        size: primary_geometry.metadata_max_size\n        type: metadata\n        repeat: expr\n        repeat-expr: primary_geometry.metadata_slot_count\n\n  geometry:\n    seq:\n      - id: magic\n        contents: 'gDla'\n      - id: struct_size\n        type: u4\n      - id: checksum\n        size: 32\n        doc: |\n          SHA-256 hash of struct_size bytes from beginning of geometry,\n          calculated as if checksum were zeroed out\n      - id: metadata_max_size\n        type: u4\n      - id: metadata_slot_count\n        type: u4\n      - id: logical_block_size\n        type: u4\n\n  metadata:\n    seq:\n      - id: magic\n        contents: '0PLA'\n      - id: major_version\n        type: u2\n      - id: minor_version\n        type: u2\n      - id: header_size\n        type: u4\n      - id: header_checksum\n        size: 32\n        doc: |\n          SHA-256 hash of header_size bytes from beginning of metadata,\n          calculated as if header_checksum were zeroed out\n      - id: tables_size\n        type: u4\n      - id: tables_checksum\n        size: 32\n        doc: SHA-256 hash of tables_size bytes from end of header\n      - id: partitions\n        type: table_descriptor(table_kind::partitions)\n      - id: extents\n        type: table_descriptor(table_kind::extents)\n      - id: groups\n        type: table_descriptor(table_kind::groups)\n      - id: block_devices\n        type: table_descriptor(table_kind::block_devices)\n\n    enums:\n      table_kind:\n        0: partitions\n        1: extents\n        2: groups\n        3: block_devices\n\n    types:\n      table_descriptor:\n        params:\n          - id: kind\n            type: u1\n            enum: table_kind\n            -affected-by: 135\n\n        seq:\n          - id: offset\n            type: u4\n          - id: num_entries\n            type: u4\n          - id: entry_size\n            type: u4\n\n        instances:\n          table:\n            pos: _parent.header_size + offset\n            size: entry_size\n            type:\n              switch-on: kind\n              cases:\n                'table_kind::partitions': partition\n                'table_kind::extents': extent\n                'table_kind::groups': group\n                'table_kind::block_devices': block_device\n            repeat: expr\n            repeat-expr: num_entries\n\n      partition:\n        seq:\n          - id: name\n            size: 36\n            type: strz\n            encoding: UTF-8\n          - id: attr_readonly\n            type: b1\n          - id: attr_slot_suffixed\n            type: b1\n          - id: attr_updated\n            type: b1\n          - id: attr_disabled\n            type: b1\n          - id: attrs_reserved\n            type: b28\n          - id: first_extent_index\n            type: u4\n          - id: num_extents\n            type: u4\n          - id: group_index\n            type: u4\n\n      extent:\n        seq:\n          - id: num_sectors\n            type: u8\n          - id: target_type\n            type: u4\n            enum: target_type\n          - id: target_data\n            type: u8\n          - id: target_source\n            type: u4\n\n        enums:\n          target_type:\n            0: linear\n            1: zero\n\n      group:\n        seq:\n          - id: name\n            size: 36\n            type: strz\n            encoding: UTF-8\n          - id: flag_slot_suffixed\n            type: b1\n          - id: flags_reserved\n            type: b31\n          - id: maximum_size\n            type: u8\n\n      block_device:\n        seq:\n          - id: first_logical_sector\n            type: u8\n          - id: alignment\n            type: u4\n          - id: alignment_offset\n            type: u4\n          - id: size\n            type: u8\n          - id: partition_name\n            size: 36\n            type: strz\n            encoding: UTF-8\n          - id: flag_slot_suffixed\n            type: b1\n          - id: flags_reserved\n            type: b31\n"
  },
  {
    "id": "ksy_apm_partition_table",
    "name": "APM (Apple Partition Map) partition table",
    "category": "File System",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "APM (Apple Partition Map) partition table",
      "originalCategory": "filesystem",
      "filePath": "filesystem/apm_partition_table.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: apm_partition_table\n  title: APM (Apple Partition Map) partition table\n  xref:\n    forensicswiki: apm\n    justsolve: Apple_Partition_Map\n    wikidata: Q375944\n  tags:\n    - filesystem\n    - macos\n  license: CC0-1.0\n  encoding: ascii\n  endian: be\ndoc-ref: https://en.wikipedia.org/wiki/Apple_Partition_Map\ninstances:\n  sector_size:\n    value: 0x200\n    doc: |\n      0x200 (512) bytes for disks, 0x1000 (4096) bytes is not supported by APM\n      0x800 (2048) bytes for CDROM\n  partition_lookup:\n    io: _root._io\n    pos: _root.sector_size\n    size: sector_size\n    type: partition_entry\n    doc: |\n      Every partition entry contains the number of partition entries.\n      We parse the first entry, to know how many to parse, including the first one.\n      No logic is given what to do if other entries have a different number.\n  partition_entries:\n    io: _root._io\n    pos: _root.sector_size\n    size: sector_size\n    type: partition_entry\n    repeat: expr\n    repeat-expr: _root.partition_lookup.number_of_partitions\ntypes:\n  partition_entry:\n    seq:\n      - id: magic\n        contents: [ 0x50, 0x4d ]\n      - id: reserved_1\n        size: 0x2\n      - id: number_of_partitions\n        type: u4\n      - id: partition_start\n        type: u4\n        doc: \"First sector\"\n      - id: partition_size\n        type: u4\n        doc: \"Number of sectors\"\n      - id: partition_name\n        type: strz\n        size: 0x20\n      - id: partition_type\n        type: strz\n        size: 0x20\n      - id: data_start\n        type: u4\n        doc: \"First sector\"\n      - id: data_size\n        type: u4\n        doc: \"Number of sectors\"\n      - id: partition_status\n        type: u4\n      - id: boot_code_start\n        type: u4\n        doc: \"First sector\"\n      - id: boot_code_size\n        type: u4\n        doc: \"Number of bytes\"\n      - id: boot_loader_address\n        type: u4\n        doc: \"Address of bootloader code\"\n      - id: reserved_2\n        size: 0x4\n      - id: boot_code_entry\n        type: u4\n        doc: \"Boot code entry point\"\n      - id: reserved_3\n        size: 0x4\n      - id: boot_code_cksum\n        type: u4\n        doc: \"Boot code checksum\"\n      - id: processor_type\n        type: strz\n        size: 0x10\n      # Skipping the remaining of the sector, it should be all 0x00\n    instances:\n      partition:\n        io: _root._io\n        pos: partition_start * _root.sector_size\n        size: partition_size * _root.sector_size\n        if: 'partition_status & 1 != 0'\n      data:\n        io: _root._io\n        pos: data_start * _root.sector_size\n        size: data_size * _root.sector_size\n      boot_code:\n        io: _root._io\n        pos: boot_code_start * _root.sector_size\n        size: boot_code_size\n"
  },
  {
    "id": "ksy_apple_single_double",
    "name": "AppleSingle / AppleDouble",
    "category": "File System",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "AppleSingle / AppleDouble",
      "originalCategory": "filesystem",
      "filePath": "filesystem/apple_single_double.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: apple_single_double\n  title: AppleSingle / AppleDouble\n  xref:\n    forensicswiki: appledouble_header_file\n    justsolve: AppleDouble\n    rfc: 1740\n    wikidata: Q4781113\n  tags:\n    - filesystem\n    - macos\n  license: CC0-1.0\n  endian: be\ndoc: |\n  AppleSingle and AppleDouble files are used by certain Mac\n  applications (e.g. Finder) to store Mac-specific file attributes on\n  filesystems that do not support that.\n\n  Syntactically, both formats are the same, the only difference is how\n  they are being used:\n\n  * AppleSingle means that only one file will be created on external\n    filesystem that will hold both the data (AKA \"data fork\" in Apple\n    terminology), and the attributes (AKA \"resource fork\").\n  * AppleDouble means that two files will be created: a normal file\n    that keeps the data (\"data fork\") is kept separately from an\n    auxiliary file that contains attributes (\"resource fork\"), which\n    is kept with the same name, but starting with an extra dot and\n    underscore `._` to keep it hidden.\n\n  In modern practice (Mac OS X), Finder only uses AppleDouble to keep\n  compatibility with other OSes, as virtually nobody outside of Mac\n  understands how to access data in AppleSingle container.\ndoc-ref: http://kaiser-edv.de/documents/AppleSingle_AppleDouble.pdf\nseq:\n  - id: magic\n    type: u4\n    enum: file_type\n  - id: version\n    type: u4\n  - id: reserved\n    size: 16\n    doc: Must be all 0.\n  - id: num_entries\n    type: u2\n  - id: entries\n    type: entry\n    repeat: expr\n    repeat-expr: num_entries\nenums:\n  file_type:\n    0x00051600: apple_single\n    0x00051607: apple_double\ntypes:\n  entry:\n    seq:\n      - id: type\n        type: u4\n        enum: types\n      - id: ofs_body\n        type: u4\n      - id: len_body\n        type: u4\n    instances:\n      body:\n        pos: ofs_body\n        size: len_body\n        type:\n          switch-on: type\n          cases:\n            'types::finder_info': finder_info\n    enums:\n      types:\n        1:\n          id: data_fork\n        2:\n          id: resource_fork\n        3:\n          id: real_name\n          doc: File name on a file system that supports all the attributes.\n        4:\n          id: comment\n        5:\n          id: icon_bw\n        6:\n          id: icon_color\n        8:\n          id: file_dates_info\n          doc: File creation, modification, access date/timestamps.\n        9:\n          id: finder_info\n        10:\n          id: macintosh_file_info\n        11:\n          id: prodos_file_info\n        12:\n          id: msdos_file_info\n        13:\n          id: afp_short_name\n        14:\n          id: afp_file_info\n        15:\n          id: afp_directory_id\n  finder_info:\n    -orig-id: FInfo\n    doc: Information specific to Finder\n    doc-ref: older Inside Macintosh, Volume II page 84 or Volume IV page 104.\n    seq:\n      - id: file_type\n        -orig-id: fdType\n        size: 4\n      - id: file_creator\n        -orig-id: fdCreator\n        size: 4\n      - id: flags\n        -orig-id: fdFlags\n        type: u2\n      - id: location\n        -orig-id: fdLocation\n        type: point\n        doc: File icon's coordinates when displaying this folder.\n      - id: folder_id\n        -orig-id: fdFldr\n        type: u2\n        doc: File folder ID (=window).\n  point:\n    doc: Specifies 2D coordinate in QuickDraw grid.\n    seq:\n      - id: x\n        type: u2\n      - id: y\n        type: u2\n"
  },
  {
    "id": "ksy_btrfs_stream",
    "name": "Btrfs Stream",
    "category": "File System",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "",
      "originalCategory": "filesystem",
      "filePath": "filesystem/btrfs_stream.ksy",
      "endian": "le"
    },
    "content": "meta:\n  id: btrfs_stream\n  application: Btrfs\n  xref:\n    wikidata: Q283820\n  tags:\n    - filesystem\n    - linux\n  license: CC0-1.0\n  endian: le\ndoc: |\n  Btrfs is a copy on write file system based on B-trees focusing on fault tolerance, repair and easy\n  administration. Btrfs is intended to address the lack of pooling, snapshots, checksums, and\n  integral multi-device spanning in Linux file systems.\n  Given any pair of subvolumes (or snapshots), Btrfs can generate a binary diff between them by\n  using the `btrfs send` command that can be replayed later by using `btrfs receive`, possibly on a\n  different Btrfs file system. The `btrfs send` command creates a set of data modifications required\n  for converting one subvolume into another.\n  This spec can be used to disassemble the binary diff created by the `btrfs send` command.\n  If you want a text representation you may want to checkout `btrfs receive --dump` instead.\ndoc-ref: https://archive.kernel.org/oldwiki/btrfs.wiki.kernel.org/index.php/Design_notes_on_Send/Receive.html\n\nseq:\n  - id: header\n    type: send_stream_header\n  - id: commands\n    type: send_command\n    repeat: eos\ntypes:\n  send_stream_header:\n    seq:\n      - id: magic\n        contents: ['btrfs-stream', 0x00]\n      - id: version\n        type: u4le\n  send_command:\n    seq:\n      - id: len_data\n        type: u4le\n      - id: type\n        type: u2le\n        enum: command\n      - id: checksum\n        size: 4\n        doc: CRC32 checksum of a whole send command, including the header, with this attribute set to 0.\n      - id: data\n        type: tlvs\n        size: len_data\n    types:\n      tlvs:\n        seq:\n          - id: tlv\n            type: tlv\n            repeat: eos\n      tlv:\n        seq:\n          - id: type\n            enum: attribute\n            type: u2le\n          - id: length\n            type: u2le\n          - id: value\n            size: length\n            type:\n              switch-on: type\n              cases:\n                #'attribute::unspec':\n                'attribute::uuid': uuid\n                'attribute::ctransid': u8le\n                #'attribute:ino':\n                'attribute::size': u8le\n                'attribute::mode': u8le\n                'attribute::uid': u8le\n                'attribute::gid': u8le\n                'attribute::rdev': u8le\n                'attribute::ctime': timespec\n                'attribute::mtime': timespec\n                'attribute::atime': timespec\n                'attribute::otime': timespec\n                'attribute::xattr_name': string\n                #'attribute::xattr_data':\n                'attribute::path': string\n                'attribute::path_to': string\n                'attribute::path_link': string\n                'attribute::file_offset': u8le\n                #'attribute::data':\n                'attribute::clone_uuid': uuid\n                'attribute::clone_ctransid': u8le\n                'attribute::clone_path': string\n                'attribute::clone_offset': u8le\n                'attribute::clone_len': u8le\n      timespec:\n        seq:\n          - id: ts_sec\n            type: s8le\n          - id: ts_nsec\n            type: s4le\n      string:\n        seq:\n          - id: string\n            type: str\n            size-eos: true\n            encoding: UTF-8\n      uuid:\n        seq:\n          - id: uuid\n            size: 16\n\n# enum btrfs_send_cmd\n# https://git.kernel.org/pub/scm/linux/kernel/git/kdave/btrfs-progs.git/tree/kernel-shared/send.h?id=979bda6f#n69\nenums:\n  command:\n    0x00: unspec\n    0x01: subvol\n    0x02: snapshot\n    0x03: mkfile\n    0x04: mkdir\n    0x05: mknod\n    0x06: mkfifo\n    0x07: mksock\n    0x08: symlink\n    0x09: rename\n    0x0a: link\n    0x0b: unlink\n    0x0c: rmdir\n    0x0d: set_xattr\n    0x0e: remove_xattr\n    0x0f: write\n    0x10: clone\n    0x11: truncate\n    0x12: chmod\n    0x13: chown\n    0x14: utimes\n    0x15: end\n    0x16: update_extent\n  attribute:\n    0x00: unspec\n    0x01: uuid\n    0x02: ctransid\n    0x03: ino\n    0x04: size\n    0x05: mode\n    0x06: uid\n    0x07: gid\n    0x08: rdev\n    0x09: ctime\n    0x0a: mtime\n    0x0b: atime\n    0x0c: otime\n    0x0d: xattr_name\n    0x0e: xattr_data\n    0x0f: path\n    0x10: path_to\n    0x11: path_link\n    0x12: file_offset\n    0x13: data\n    0x14: clone_uuid\n    0x15: clone_ctransid\n    0x16: clone_path\n    0x17: clone_offset\n    0x18: clone_len\n"
  },
  {
    "id": "ksy_cramfs",
    "name": "Cramfs",
    "category": "File System",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "",
      "originalCategory": "filesystem",
      "filePath": "filesystem/cramfs.ksy",
      "endian": "le"
    },
    "content": "meta:\n  id: cramfs\n  xref:\n    justsolve: Cramfs\n    wikidata: Q747406\n  tags:\n    - filesystem\n    - linux\n  license: MIT\n  endian: le\nseq:\n  - id: super_block\n    type: super_block_struct\n\ninstances:\n  page_size:\n    value: 4096\n\ntypes:\n  super_block_struct:\n    seq:\n      - id: magic\n        contents: [0x45, 0x3D, 0xCD, 0x28]\n      - id: size\n        type: u4\n      - id: flags\n        type: u4\n      - id: future\n        type: u4\n      - id: signature\n        contents: 'Compressed ROMFS'\n      - id: fsid\n        type: info\n      - id: name\n        type: str\n        size: 16\n        encoding: ASCII\n      - id: root\n        type: inode\n    instances:\n      # flags\n      flag_fsid_v2:\n        value: (flags >>  0) & 1\n      flag_sorted_dirs:\n        value: (flags >>  1) & 1\n      flag_holes:\n        value: (flags >>  8) & 1\n      flag_wrong_signature:\n        value: (flags >>  9) & 1\n      flag_shifted_root_offset:\n        value: (flags >> 10) & 1\n\n  info:\n    seq:\n      - id: crc\n        type: u4\n      - id: edition\n        type: u4\n      - id: blocks\n        type: u4\n      - id: files\n        type: u4\n\n  inode:\n    seq:\n      - id: mode\n        type: u2\n      - id: uid\n        type: u2\n      - id: size_gid\n        type: u4\n      - id: namelen_offset\n        type: u4\n      - id: name\n        type: str\n        size: namelen\n        encoding: utf-8\n    instances:\n      # -- [mode] --\n      type:\n        value: (mode >> 12) & 0b1111\n        enum: file_type\n      attr:\n        value: (mode >> 9) & 0b0111\n      perm_u:\n        value: (mode >> 6) & 0b0111\n      perm_g:\n        value: (mode >> 3) & 0b0111\n      perm_o:\n        value: mode & 0b0111\n      # -- [size_gid] --\n      size:\n        value: size_gid & 0xFFFFFF\n      gid:\n        value: size_gid >> 24\n      # -- [namelen_offset] --\n      namelen:\n        value: (namelen_offset & 0x3F) << 2\n      offset:\n        value: ((namelen_offset >> 6) & 0x3FFFFFF) << 2\n      # -- [type dependent data] --\n      as_reg_file:\n        io: _root._io\n        pos: offset\n        type: chunked_data_inode\n      as_symlink:\n        io: _root._io\n        pos: offset\n        type: chunked_data_inode\n      as_dir:\n        io: _root._io\n        pos: offset\n        size: size\n        type: dir_inode\n    enums:\n      file_type:\n        1: fifo\n        2: chrdev\n        4: dir\n        6: blkdev\n        8: reg_file\n        10: symlink\n        12: socket\n\n  chunked_data_inode:\n    seq:\n      - id: block_end_index\n        type: u4\n        repeat: expr\n        repeat-expr: (_parent.size + _root.page_size - 1) / _root.page_size\n\n      # Correct decoding can't yet be described -- raw data for now.\n      - id: raw_blocks\n        size-eos: true\n\n      #- id: raw_blocks\n      #  size: block_end_index[i] - _io.pos\n      #  repeat: expr\n      #  repeat-expr: (_parent.size + _root.page_size - 1) / _root.page_size\n\n  dir_inode:\n    seq:\n      - id: children\n        repeat: eos\n        type: inode\n        if: _io.size > 0\n"
  },
  {
    "id": "ksy_ext2",
    "name": "ext2 filesystem",
    "category": "File System",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "ext2 filesystem",
      "originalCategory": "filesystem",
      "filePath": "filesystem/ext2.ksy",
      "endian": "le"
    },
    "content": "meta:\n  id: ext2\n  title: ext2 filesystem\n  xref:\n    forensicswiki: extended_file_system_(ext)\n    justsolve: Ext2\n    wikidata: Q283527\n  tags:\n    - filesystem\n    - linux\n  license: CC0-1.0\n  endian: le\ninstances:\n  # https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/filesystems/ext2.rst?id=a9edc03f13db#n116\n  bg1:\n    pos: 1024\n    type: block_group\n  root_dir:\n    value: bg1.block_groups[0].inodes[1].as_dir\ntypes:\n  block_group:\n    seq:\n      - id: super_block\n        type: super_block_struct\n        size: 1024\n      # https://www.nongnu.org/ext2-doc/ext2.html#BLOCK-GROUP-DESCRIPTOR-TABLE\n      - id: block_groups\n        type: bgd\n        repeat: expr\n        repeat-expr: super_block.block_group_count\n  # https://www.nongnu.org/ext2-doc/ext2.html#super_block\n  # https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/ext2/ext2.h?id=cd913c76f489#n412\n  # https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout#The_Super_Block\n  super_block_struct:\n    seq:\n      - id: inodes_count\n        type: u4\n      - id: blocks_count\n        type: u4\n      - id: r_blocks_count\n        type: u4\n      - id: free_blocks_count\n        type: u4\n      - id: free_inodes_count\n        type: u4\n      - id: first_data_block\n        type: u4\n      - id: log_block_size\n        type: u4\n      - id: log_frag_size\n        type: u4\n      - id: blocks_per_group\n        type: u4\n      - id: frags_per_group\n        type: u4\n      - id: inodes_per_group\n        type: u4\n      - id: mtime\n        type: u4\n      - id: wtime\n        type: u4\n      - id: mnt_count\n        type: u2\n      - id: max_mnt_count\n        type: u2\n      - id: magic\n        contents: [0x53, 0xef]\n      - id: state\n        type: u2\n        enum: state_enum\n      - id: errors\n        type: u2\n        enum: errors_enum\n      - id: minor_rev_level\n        type: u2\n      - id: lastcheck\n        type: u4\n      - id: checkinterval\n        type: u4\n      - id: creator_os\n        type: u4\n      - id: rev_level\n        type: u4\n      - id: def_resuid\n        type: u2\n      - id: def_resgid\n        type: u2\n#    -- EXT2_DYNAMIC_REV Specific --\n      - id: first_ino\n        type: u4\n      - id: inode_size\n        type: u2\n      - id: block_group_nr\n        type: u2\n      - id: feature_compat\n        type: u4\n      - id: feature_incompat\n        type: u4\n      - id: feature_ro_compat\n        type: u4\n      - id: uuid\n        size: 16\n      - id: volume_name\n        size: 16\n      - id: last_mounted\n        size: 64\n      - id: algo_bitmap\n        type: u4\n#    -- Performance Hints --\n      - id: prealloc_blocks\n        type: u1\n      - id: prealloc_dir_blocks\n        type: u1\n      - id: padding1\n        size: 2\n#    -- Journaling Support --\n      - id: journal_uuid\n        size: 16\n      - id: journal_inum\n        type: u4\n      - id: journal_dev\n        type: u4\n      - id: last_orphan\n        type: u4\n#    -- Directory Indexing Support --\n      - id: hash_seed\n        type: u4\n        repeat: expr\n        repeat-expr: 4\n      - id: def_hash_version\n        type: u1\n    instances:\n      block_size:\n        value: 1024 << log_block_size\n      block_group_count:\n        value: blocks_count / blocks_per_group\n    enums:\n      state_enum:\n        1: valid_fs\n        2: error_fs\n      errors_enum:\n        1: act_continue\n        2: act_ro\n        3: act_panic\n  # https://www.nongnu.org/ext2-doc/ext2.html#BLOCK-GROUP-DESCRIPTOR-STRUCTURE\n  # https://web.archive.org/web/20160804172310/http://virtualblueness.net/Ext2fs-overview/Ext2fs-overview-0.1-7.html\n  bgd:\n    seq:\n      - id: block_bitmap_block\n        type: u4\n      - id: inode_bitmap_block\n        type: u4\n      - id: inode_table_block\n        type: u4\n      - id: free_blocks_count\n        type: u2\n      - id: free_inodes_count\n        type: u2\n      - id: used_dirs_count\n        type: u2\n      - id: pad_reserved\n        size: 2 + 12\n    instances:\n      block_bitmap:\n        pos: block_bitmap_block * _root.bg1.super_block.block_size\n        size: 1024\n      inode_bitmap:\n        pos: inode_bitmap_block * _root.bg1.super_block.block_size\n        size: 1024\n      # https://www.nongnu.org/ext2-doc/ext2.html#INODE-TABLE\n      # https://web.archive.org/web/20161114202411/http://www.virtualblueness.net/Ext2fs-overview/Ext2fs-overview-0.1-10.html\n      inodes:\n        pos: inode_table_block * _root.bg1.super_block.block_size\n        type: inode\n        repeat: expr\n        repeat-expr: _root.bg1.super_block.inodes_per_group\n  inode:\n    seq:\n      - id: mode\n        type: u2\n      - id: uid\n        type: u2\n      - id: size\n        type: u4\n      - id: atime\n        type: u4\n      - id: ctime\n        type: u4\n      - id: mtime\n        type: u4\n      - id: dtime\n        type: u4\n      - id: gid\n        type: u2\n      - id: links_count\n        type: u2\n      - id: blocks\n        type: u4\n      - id: flags\n        type: u4\n      - id: osd1\n        type: u4\n      - id: block\n        type: block_ptr\n        repeat: expr\n        repeat-expr: 15\n      - id: generation\n        type: u4\n      - id: file_acl\n        type: u4\n      - id: dir_acl\n        type: u4\n      - id: faddr\n        type: u4\n      - id: osd2\n        size: 12\n    instances:\n      as_dir:\n        io: 'block[0].body._io'\n        pos: 0\n        type: dir\n  block_ptr:\n    seq:\n      - id: ptr\n        type: u4\n    instances:\n      body:\n        pos: ptr * _root.bg1.super_block.block_size\n        size: _root.bg1.super_block.block_size\n        type: raw_block\n  raw_block:\n    seq:\n      - id: body\n        size: _root.bg1.super_block.block_size\n  # https://www.nongnu.org/ext2-doc/ext2.html#LINKED-DIRECTORY-ENTRY-STRUCTURE\n  dir:\n    seq:\n      - id: entries\n        type: dir_entry\n        repeat: eos\n  dir_entry:\n    seq:\n      - id: inode_ptr\n        type: u4\n      - id: rec_len\n        type: u2\n      - id: name_len\n        type: u1\n      - id: file_type\n        type: u1\n        enum: file_type_enum\n      - id: name\n        size: name_len\n        type: str\n        encoding: UTF-8\n      - id: padding\n        size: rec_len - name_len - 8\n    instances:\n      inode:\n        value: '_root.bg1.block_groups[(inode_ptr - 1) / _root.bg1.super_block.inodes_per_group].inodes[(inode_ptr - 1) % _root.bg1.super_block.inodes_per_group]'\n    enums:\n      # https://www.nongnu.org/ext2-doc/ext2.html#IFDIR-FILE-TYPE\n      file_type_enum:\n        0: unknown\n        1: reg_file\n        2: dir\n        3: chrdev\n        4: blkdev\n        5: fifo\n        6: sock\n        7: symlink\n"
  },
  {
    "id": "ksy_gpt_partition_table",
    "name": "GPT (GUID) partition table",
    "category": "File System",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "GPT (GUID) partition table",
      "originalCategory": "filesystem",
      "filePath": "filesystem/gpt_partition_table.ksy",
      "endian": "le"
    },
    "content": "meta:\n  id: gpt_partition_table\n  title: GPT (GUID) partition table\n  xref:\n    forensicswiki: gpt\n    justsolve: GUID_Partition_Table\n    wikidata: Q603889\n  license: CC0-1.0\n  endian: le\ndoc-ref: https://en.wikipedia.org/wiki/GUID_Partition_Table\ninstances:\n  sector_size:\n    value: 0x200\n    # Default is 0x200 for 512 byte sectors, set to 0x1000 to parse 4096 byte sectors.\n  primary:\n    io: _root._io\n    pos: _root.sector_size\n    type: partition_header\n  backup:\n    io: _root._io\n    pos: _io.size - _root.sector_size\n    type: partition_header\ntypes:\n  partition_entry:\n    seq:\n      - id: type_guid\n        size: 0x10\n      - id: guid\n        size: 0x10\n      - id: first_lba\n        type: u8\n      - id: last_lba\n        type: u8\n      - id: attributes\n        type: u8\n      - id: name\n        type: str\n        encoding: UTF-16LE\n        size: 0x48\n  partition_header:\n    seq:\n      - id: signature\n        contents: [0x45, 0x46, 0x49, 0x20, 0x50, 0x41, 0x52, 0x54]\n      - id: revision\n        type: u4\n      - id: header_size\n        type: u4\n      - id: crc32_header\n        type: u4\n      - id: reserved\n        type: u4\n      - id: current_lba\n        type: u8\n      - id: backup_lba\n        type: u8\n      - id: first_usable_lba\n        type: u8\n      - id: last_usable_lba\n        type: u8\n      - id: disk_guid\n        size: 0x10\n      - id: entries_start\n        type: u8\n      - id: entries_count\n        type: u4\n      - id: entries_size\n        type: u4\n      - id: crc32_array\n        type: u4\n      # The document states \"Reserved; must be zeroes for the rest of the block\".\n      # It would be pointless to process a data structure that must be zeroed.\n    instances:\n      entries:\n        io: _root._io\n        pos: entries_start * _root.sector_size\n        size: entries_size\n        type: partition_entry\n        repeat: expr\n        repeat-expr: entries_count\n"
  },
  {
    "id": "ksy_iso9660",
    "name": "ISO9660 CD filesystem",
    "category": "File System",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [
        "iso"
      ],
      "description": "ISO9660 CD filesystem",
      "originalCategory": "filesystem",
      "filePath": "filesystem/iso9660.ksy"
    },
    "content": "meta:\n  id: iso9660\n  title: ISO9660 CD filesystem\n  file-extension: iso\n  xref:\n    justsolve: ISO_9660\n    loc: fdd000348\n    pronom: fmt/468\n    wikidata: Q815645\n  license: CC0-1.0\ndoc: |\n  ISO9660 is standard filesystem used on read-only optical discs\n  (mostly CD-ROM). The standard was based on earlier High Sierra\n  Format (HSF), proposed for CD-ROMs in 1985, and, after several\n  revisions, it was accepted as ISO9960:1998.\n\n  The format emphasizes portability (thus having pretty minimal\n  features and very conservative file names standards) and sequential\n  access (which favors disc devices with relatively slow rotation\n  speed).\ntypes:\n  vol_desc:\n    seq:\n      - id: type\n        type: u1\n      - id: magic\n        contents: \"CD001\"\n      - id: version\n        type: u1\n      - id: vol_desc_boot_record\n        type: vol_desc_boot_record\n        if: type == 0\n      - id: vol_desc_primary\n        type: vol_desc_primary\n        if: type == 1\n  vol_desc_boot_record:\n    seq:\n      - id: boot_system_id\n        type: str\n        size: 32\n        encoding: UTF-8\n      - id: boot_id\n        type: str\n        size: 32\n        encoding: UTF-8\n  vol_desc_primary:\n    doc-ref: 'https://wiki.osdev.org/ISO_9660#The_Primary_Volume_Descriptor'\n    seq:\n      - id: unused1\n        contents: [0]\n      - id: system_id\n        type: str\n        size: 32\n        encoding: UTF-8\n      - id: volume_id\n        type: str\n        size: 32\n        encoding: UTF-8\n      - id: unused2\n        contents: [0, 0, 0, 0, 0, 0, 0, 0]\n      - id: vol_space_size\n        type: u4bi\n      - id: unused3\n        contents: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n      - id: vol_set_size\n        type: u2bi\n      - id: vol_seq_num\n        type: u2bi\n      - id: logical_block_size\n        type: u2bi\n      - id: path_table_size\n        type: u4bi\n      - id: lba_path_table_le\n        type: u4le\n      - id: lba_opt_path_table_le\n        type: u4le\n      - id: lba_path_table_be\n        type: u4be\n      - id: lba_opt_path_table_be\n        type: u4be\n      - id: root_dir\n        type: dir_entry\n        size: 34\n      - id: vol_set_id\n        type: str\n        size: 128\n        encoding: UTF-8\n      - id: publisher_id\n        type: str\n        size: 128\n        encoding: UTF-8\n      - id: data_preparer_id\n        type: str\n        size: 128\n        encoding: UTF-8\n      - id: application_id\n        type: str\n        size: 128\n        encoding: UTF-8\n      - id: copyright_file_id\n        type: str\n        size: 38\n        encoding: UTF-8\n      - id: abstract_file_id\n        type: str\n        size: 36\n        encoding: UTF-8\n      - id: bibliographic_file_id\n        type: str\n        size: 37\n        encoding: UTF-8\n      - id: vol_create_datetime\n        type: dec_datetime\n      - id: vol_mod_datetime\n        type: dec_datetime\n      - id: vol_expire_datetime\n        type: dec_datetime\n      - id: vol_effective_datetime\n        type: dec_datetime\n      - id: file_structure_version\n        type: u1\n      - id: unused4\n        type: u1\n      - id: application_area\n        size: 512\n    instances:\n      path_table:\n        pos: lba_path_table_le * _root.sector_size\n        size: path_table_size.le\n        type: path_table_le\n  dir_entries:\n    seq:\n      - id: entries\n        type: dir_entry\n        repeat: until\n        repeat-until: _.len == 0\n  dir_entry:\n    seq:\n      - id: len\n        type: u1\n      - id: body\n        type: dir_entry_body\n        size: len - 1\n        if: len > 0\n  dir_entry_body:\n    seq:\n      - id: len_ext_attr_rec\n        type: u1\n      - id: lba_extent\n        type: u4bi\n      - id: size_extent\n        type: u4bi\n      - id: datetime\n        type: datetime\n      - id: file_flags\n        type: u1\n      - id: file_unit_size\n        type: u1\n      - id: interleave_gap_size\n        type: u1\n      - id: vol_seq_num\n        type: u2bi\n      - id: len_file_name\n        type: u1\n      - id: file_name\n        type: str\n        encoding: UTF-8\n        size: len_file_name\n      - id: padding\n        type: u1\n        if: len_file_name % 2 == 0\n      - id: rest\n        size-eos: true\n    instances:\n      extent_as_dir:\n        io: _root._io\n        pos: lba_extent.le * _root.sector_size\n        size: size_extent.le\n        type: dir_entries\n        if: file_flags & 2 != 0\n      extent_as_file:\n        io: _root._io\n        pos: lba_extent.le * _root.sector_size\n        size: size_extent.le\n        if: file_flags & 2 == 0\n  ## AKA \"Path Table Entry\"\n  path_table_le:\n    doc-ref: 'https://wiki.osdev.org/ISO_9660#The_Path_Table'\n    seq:\n      - id: entries\n        type: path_table_entry_le\n        repeat: eos\n  path_table_entry_le:\n    seq:\n      - id: len_dir_name\n        type: u1\n      - id: len_ext_attr_rec\n        type: u1\n      - id: lba_extent\n        type: u4le\n      - id: parent_dir_idx\n        type: u2le\n      - id: dir_name\n        type: str\n        encoding: UTF-8\n        size: len_dir_name\n      - id: padding\n        type: u1\n        if: len_dir_name % 2 == 1\n  datetime:\n    seq:\n      - id: year\n        type: u1\n      - id: month\n        type: u1\n      - id: day\n        type: u1\n      - id: hour\n        type: u1\n      - id: minute\n        type: u1\n      - id: sec\n        type: u1\n      - id: timezone\n        type: u1\n  dec_datetime:\n    doc-ref: 'https://wiki.osdev.org/ISO_9660#Date.2Ftime_format'\n    seq:\n      - id: year\n        type: str\n        size: 4\n        encoding: ASCII\n      - id: month\n        type: str\n        size: 2\n        encoding: ASCII\n      - id: day\n        type: str\n        size: 2\n        encoding: ASCII\n      - id: hour\n        type: str\n        size: 2\n        encoding: ASCII\n      - id: minute\n        type: str\n        size: 2\n        encoding: ASCII\n      - id: sec\n        type: str\n        size: 2\n        encoding: ASCII\n      - id: sec_hundreds\n        type: str\n        size: 2\n        encoding: ASCII\n      - id: timezone\n        type: u1\n  u2bi:\n    seq:\n      - id: le\n        type: u2le\n      - id: be\n        type: u2be\n  u4bi:\n    seq:\n      - id: le\n        type: u4le\n      - id: be\n        type: u4be\ninstances:\n  sector_size:\n    value: 2048\n  primary_vol_desc:\n    pos: 0x010 * sector_size\n    type: vol_desc\n"
  },
  {
    "id": "ksy_luks",
    "name": "Linux Unified Key Setup",
    "category": "File System",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "Linux Unified Key Setup",
      "originalCategory": "filesystem",
      "filePath": "filesystem/luks.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: luks\n  title: Linux Unified Key Setup\n  xref:\n    forensicswiki: linux_unified_key_setup_(luks)\n    justsolve: LUKS\n    wikidata: Q29000504\n  tags:\n    - filesystem\n    - linux\n  license: CC0-1.0\n  encoding: ASCII\n  endian: be\ndoc: |\n  Linux Unified Key Setup (LUKS) is a format specification for storing disk\n  encryption parameters and up to 8 user keys (which can unlock the master key).\ndoc-ref: https://gitlab.com/cryptsetup/cryptsetup/-/wikis/LUKS-standard/on-disk-format.pdf\nseq:\n  - id: partition_header\n    type: partition_header\ntypes:\n  partition_header:\n    seq:\n      - id: magic\n        contents: [0x4C, 0x55, 0x4B, 0x53, 0xBA, 0xBE]\n      - id: version\n        contents: [0x00, 0x01]\n      - id: cipher_name_specification\n        type: str\n        size: 32\n      - id: cipher_mode_specification\n        type: str\n        size: 32\n      - id: hash_specification\n        type: str\n        size: 32\n      - id: payload_offset\n        type: u4\n      - id: number_of_key_bytes\n        type: u4\n      - id: master_key_checksum\n        size: 20\n      - id: master_key_salt_parameter\n        size: 32\n      - id: master_key_iterations_parameter\n        type: u4\n      - id: uuid\n        type: str\n        size: 40\n      - id: key_slots\n        type: key_slot\n        repeat: expr\n        repeat-expr: 8\n    types:\n      key_slot:\n        seq:\n          - id: state_of_key_slot\n            type: u4\n            enum: key_slot_states\n          - id: iteration_parameter\n            type: u4\n          - id: salt_parameter\n            size: 32\n          - id: start_sector_of_key_material\n            type: u4\n          - id: number_of_anti_forensic_stripes\n            type: u4\n        instances:\n          key_material:\n            pos: start_sector_of_key_material * 512\n            size: _parent.number_of_key_bytes * number_of_anti_forensic_stripes\n        enums:\n          key_slot_states:\n            0x0000DEAD: disabled_key_slot\n            0x00AC71F3: enabled_key_slot\ninstances:\n  payload:\n    pos: partition_header.payload_offset * 512\n    size-eos: true\n"
  },
  {
    "id": "ksy_lvm2",
    "name": "Logical Volume Manager version 2",
    "category": "File System",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "Logical Volume Manager version 2",
      "originalCategory": "filesystem",
      "filePath": "filesystem/lvm2.ksy",
      "endian": "le"
    },
    "content": "meta:\n  id: lvm2\n  title: Logical Volume Manager version 2\n  application:\n    - linux\n    - grub2\n    - lvm tools\n    - libvslvm\n  xref:\n    forensicswiki: linux_logical_volume_manager_(lvm)\n    wikidata: Q6667482 # software, not format\n  tags:\n    - filesystem\n    - linux\n  license: GFDL-1.3-or-later\n  encoding: ascii\n  endian: le\ndoc: |\n  ### Building a test file\n\n  ```\n  dd if=/dev/zero of=image.img bs=512 count=$(( 4 * 1024 * 2 ))\n  sudo losetup /dev/loop1 image.img\n  sudo pvcreate /dev/loop1\n  sudo vgcreate vg_test /dev/loop1\n  sudo lvcreate --name lv_test1 vg_test\n  sudo losetup -d /dev/loop1\n  ```\ndoc-ref: https://github.com/libyal/libvslvm/blob/main/documentation/Logical%20Volume%20Manager%20(LVM)%20format.asciidoc\nseq:\n  - id: pv\n    type: physical_volume\n    doc: Physical volume\ninstances:\n  sector_size:\n    value: 512 # TODO: how about 4k sectors?\ntypes:\n  physical_volume:\n    seq:\n      - id: empty_sector\n        size: _root.sector_size\n      - id: label\n        type: label\n    types:\n      label:\n        seq:\n          - id: label_header\n            type: label_header\n          - id: volume_header\n            type: volume_header\n        types:\n          label_header:\n            seq:\n              - id: signature\n                contents: \"LABELONE\"\n              - id: sector_number\n                type: u8\n                doc: \"The sector number of the physical volume label header\"\n              - id: checksum\n                type: u4\n                doc: \"CRC-32 for offset 20 to end of the physical volume label sector\"\n              - id: label_header_\n                type: label_header_\n            types:\n              label_header_:\n                seq:\n                  - id: data_offset\n                    type: u4\n                    doc: \"The offset, in bytes, relative from the start of the physical volume label header where data is stored\"\n                  - id: type_indicator\n                    contents: \"LVM2 001\"\n\n          volume_header:\n            seq:\n              - id: id\n                type: str\n                size: 32\n                doc: >\n                  Contains a UUID stored as an ASCII string.\n                  The physical volume identifier can be used to uniquely identify a physical volume. The physical volume identifier is stored as: 9LBcEB7PQTGIlLI0KxrtzrynjuSL983W but is equivalent to its formatted variant: 9LBcEB-7PQT-GIlL-I0Kx-rtzr-ynju-SL983W, which is used in the metadata.\n              - id: size\n                type: u8\n                doc: \"Physical Volume size. Value in bytes\"\n              - id: data_area_descriptors\n                type: data_area_descriptor\n                repeat: until\n                repeat-until: _.size != 0 and _.offset != 0\n                doc: \"The last descriptor in the list is terminator and consists of 0-byte values.\"\n              - id: metadata_area_descriptors\n                type: metadata_area_descriptor\n                repeat: until\n                repeat-until: _.size != 0 and _.offset != 0\n            types:\n              data_area_descriptor:\n                seq:\n                  - id: offset\n                    type: u8\n                    doc: The offset, in bytes, relative from the start of the physical volume\n                  - id: size\n                    type: u8\n                    doc: >\n                      Value in bytes.\n                      Can be 0. [yellow-background]*Does this represent all remaining available space?*\n                instances:\n                  data:\n                    pos: offset\n                    size: size\n                    type: str\n                    if: size != 0\n              metadata_area_descriptor:\n                seq:\n                  - id: offset\n                    type: u8\n                    doc: The offset, in bytes, relative from the start of the physical volume\n                  - id: size\n                    type: u8\n                    doc: Value in bytes\n                instances:\n                  data:\n                    pos: offset\n                    size: size\n                    type: metadata_area\n                    if: size != 0\n              metadata_area:\n                doc: \"According to `[REDHAT]` the metadata area is a circular buffer. New metadata is appended to the old metadata and then the pointer to the start of it is updated. The metadata area, therefore, can contain copies of older versions of the metadata.\"\n                seq:\n                  - id: header\n                    type: metadata_area_header\n                types:\n                  metadata_area_header:\n                    seq:\n                      - id: checksum\n                        type: metadata_area_header\n                        doc: \"CRC-32 for offset 4 to end of the metadata area header\"\n                      - id: signature\n                        contents: \" LVM2 x[5A%r0N*>\"\n                      - id: version\n                        type: u4\n                      - id: metadata_area_offset\n                        type: u8\n                        doc: \"The offset, in bytes, of the metadata area relative from the start of the physical volume\"\n                      - id: metadata_area_size\n                        type: u8\n                      - id: raw_location_descriptors\n                        type: raw_location_descriptor\n                        doc: \"The last descriptor in the list is terminator and consists of 0-byte values.\"\n                        repeat: until\n                        repeat-until: _.offset != 0 and _.size != 0 and _.checksum != 0 # and _.flags != 0\n                    instances:\n                      metadata:\n                        pos: metadata_area_offset\n                        size: metadata_area_size\n                    types:\n                      raw_location_descriptor:\n                        -orig-id: \"raw_locn\"\n                        doc: \"The data area size can be 0. It is assumed it represents the remaining  available data.\"\n                        seq:\n                          - id: offset\n                            type: u8\n                            doc: \"The data area offset, in bytes, relative from the start of the metadata area\"\n                          - id: size\n                            type: u8\n                            doc: \"data area size in bytes\"\n                          - id: checksum\n                            type: u4\n                            doc: \"CRC-32 of *TODO (metadata?)*\"\n                          - id: flags\n                            type: u4\n                            enum: raw_location_descriptor_flags\n                        enums:\n                          raw_location_descriptor_flags:\n                            0x00000001: raw_location_ignored #The raw location descriptor should be ignored.\n"
  },
  {
    "id": "ksy_mbr_partition_table",
    "name": "MBR (Master Boot Record) partition table",
    "category": "File System",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "MBR (Master Boot Record) partition table",
      "originalCategory": "filesystem",
      "filePath": "filesystem/mbr_partition_table.ksy",
      "signature": {
        "offset": 0,
        "bytes": [
          85,
          170
        ]
      },
      "endian": "le"
    },
    "content": "meta:\n  id: mbr_partition_table\n  title: MBR (Master Boot Record) partition table\n  xref:\n    forensicswiki: master_boot_record\n    justsolve: Master_Boot_Record\n    wikidata: Q624752\n  tags:\n    - dos\n  license: CC0-1.0\n  endian: le\ndoc: |\n  MBR (Master Boot Record) partition table is a traditional way of\n  MS-DOS to partition larger hard disc drives into distinct\n  partitions.\n\n  This table is stored in the end of the boot sector (first sector) of\n  the drive, after the bootstrap code. Original DOS 2.0 specification\n  allowed only 4 partitions per disc, but DOS 3.2 introduced concept\n  of \"extended partitions\", which work as nested extra \"boot records\"\n  which are pointed to by original (\"primary\") partitions in MBR.\nseq:\n  - id: bootstrap_code\n    size: 0x1be\n  - id: partitions\n    type: partition_entry\n    repeat: expr\n    repeat-expr: 4\n  - id: boot_signature\n    contents: [0x55, 0xaa]\ntypes:\n  partition_entry:\n    seq:\n      - id: status\n        type: u1\n      - id: chs_start\n        type: chs\n      - id: partition_type\n        type: u1\n      - id: chs_end\n        type: chs\n      - id: lba_start\n        type: u4\n      - id: num_sectors\n        type: u4\n  chs:\n    seq:\n      - id: head\n        type: u1\n      - id: b2\n        type: u1\n      - id: b3\n        type: u1\n    instances:\n      sector:\n        value: 'b2 & 0b111111'\n      cylinder:\n        value: 'b3 + ((b2 & 0b11000000) << 2)'\n"
  },
  {
    "id": "ksy_tr_dos_image",
    "name": "TR-DOS flat-file disk image",
    "category": "File System",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [
        "trd"
      ],
      "description": "TR-DOS flat-file disk image",
      "originalCategory": "filesystem",
      "filePath": "filesystem/tr_dos_image.ksy",
      "endian": "le"
    },
    "content": "meta:\n  id: tr_dos_image\n  title: \"TR-DOS flat-file disk image\"\n  file-extension: trd\n  xref:\n    justsolve: TRD\n  license: CC0-1.0\n  endian: le\ndoc: |\n  .trd file is a raw dump of TR-DOS (ZX-Spectrum) floppy. .trd files are\n  headerless and contain consequent \"logical tracks\", each logical track\n  consists of 16 256-byte sectors.\n\n  Logical tracks are defined the same way as used by TR-DOS: for single-side\n  floppies it's just a physical track number, for two-side floppies sides are\n  interleaved, i.e. logical_track_num = (physical_track_num << 1) | side\n\n  So, this format definition is more for TR-DOS filesystem than for .trd files,\n  which are formatless.\n\n  Strings (file names, disk label, disk password) are padded with spaces and use\n  ZX Spectrum character set, including UDGs, block drawing chars and Basic\n  tokens. ASCII range is mostly standard ASCII, with few characters (^, `, DEL)\n  replaced with (up arrow, pound, copyright symbol).\n\n  .trd file can be smaller than actual floppy disk, if last logical tracks are\n  empty (contain no file data) they can be omitted.\nseq:\n  - id: files\n    type: file\n    repeat: until\n    # After 128 files there is disk info entry, which also has 0x00 terminator\n    # in the same position as file name. So usually even with 128 files you can\n    # just read until 0x00.\n    repeat-until: _.is_terminator\ninstances:\n  volume_info:\n    pos: 0x800\n    type: volume_info\ntypes:\n  file:\n    seq:\n      - id: name\n        # It uses custom type due to limitation of streams: there's no way to\n        # extract first byte from byte array directly\n        type: filename\n        size: 8\n      - id: extension\n        type: u1\n      - id: position_and_length\n        type:\n          switch-on: extension\n          cases:\n            0x42: position_and_length_basic # 'B'\n            0x43: position_and_length_code  # 'C'\n            0x23: position_and_length_print # '#'\n            _: position_and_length_generic\n      - id: length_sectors\n        type: u1\n      - id: starting_sector\n        type: u1\n      - id: starting_track\n        type: u1\n    instances:\n      is_deleted:\n        value: name.first_byte == 0x01\n      is_terminator:\n        value: name.first_byte == 0x00\n      contents:\n        pos: starting_track * 256 * 16 + starting_sector * 256\n        size: length_sectors * 256\n  position_and_length_basic:\n    seq:\n      - id: program_and_data_length\n        type: u2\n      - id: program_length\n        type: u2\n  position_and_length_code:\n    seq:\n      - id: start_address\n        type: u2\n        doc: Default memory address to load this byte array into\n      - id: length\n        type: u2\n  position_and_length_print:\n    seq:\n      - id: extent_no\n        type: u1\n      - id: reserved\n        type: u1\n      - id: length\n        type: u2\n  position_and_length_generic: # used for standard 'D' type and unknown types\n    seq:\n      - id: reserved\n        type: u2\n      - id: length\n        type: u2\n  volume_info:\n    seq:\n      # This is 0x00 at the same position as first character of filename in\n      # file entries for convenience. When disk has 128 files, it acts as\n      # \"last file\" terminator.\n      - id: catalog_end\n        contents: [0]\n      - id: unused\n        size: 224\n      - id: first_free_sector_sector\n        type: u1\n      - id: first_free_sector_track\n        doc: |\n          track number is logical, for double-sided disks it's\n          (physical_track << 1) | side, the same way that tracks are stored\n          sequentially in .trd file\n        type: u1\n      - id: disk_type\n        type: u1\n        enum: disk_type\n      - id: num_files\n        doc: |\n          Number of non-deleted files. Directory can have more than\n          number_of_files entries due to deleted files\n        type: u1\n      - id: num_free_sectors\n        type: u2\n      - id: tr_dos_id\n        contents: [0x10]\n      - id: unused_2\n        size: 2\n      - id: password\n        size: 9\n      - id: unused_3\n        size: 1\n      - id: num_deleted_files\n        type: u1\n      - id: label\n        size: 8\n      - id: unused_4\n        size: 3\n    instances:\n      num_tracks:\n        value: \"disk_type.to_i & 0x01 != 0 ? 40 : 80\"\n      num_sides:\n        value: \"disk_type.to_i & 0x08 != 0 ? 1 : 2\"\n  filename:\n    seq:\n      - id: name\n        size: 8\n    instances:\n      first_byte:\n        pos: 0\n        type: u1\n\nenums:\n  disk_type:\n    0x16: type_80_tracks_double_side\n    0x17: type_40_tracks_double_side\n    0x18: type_80_tracks_single_side\n    0x19: type_40_tracks_single_side\n"
  },
  {
    "id": "ksy_vdi",
    "name": "VirtualBox Disk Image",
    "category": "File System",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [
        "vdi"
      ],
      "description": "VirtualBox Disk Image",
      "originalCategory": "filesystem",
      "filePath": "filesystem/vdi.ksy",
      "endian": "le"
    },
    "content": "meta:\n  id: vdi\n  title: VirtualBox Disk Image\n  application:\n    - VirtualBox\n    - QEMU\n    - VMWare Workstation\n  file-extension: vdi\n  xref:\n    justsolve: VDI\n    forensicswiki: virtual_disk_image_(vdi)\n    pronom: fmt/726\n    wikidata: Q29209126\n  license: GPL-3.0-or-later\n  encoding: utf-8\n  endian: le\ndoc-ref: https://github.com/qemu/qemu/blob/master/block/vdi.c\n#  - https://github.com/qemu/qemu/blob/master/block/vdi.c\n#  - https://www.virtualbox.org/browser/vbox/trunk/src/VBox/Storage/VDI.cpp\n#  - https://forums.virtualbox.org/viewtopic.php?t=8046\ndoc: |\n  A native VirtualBox file format\n\n  Images for testing can be downloaded from\n\n   * <https://www.osboxes.org/virtualbox-images/>\n   * <https://virtualboxes.org/images/>\n\n  or you can convert images of other formats.\nseq:\n  - id: header\n    type: header\n\ninstances:\n  block_discarded:\n    value: \"0xfffffffe\"\n  block_unallocated:\n    value: \"0xffffffff\"\n  blocks_map:\n    -orig-id: bmap\n    pos: header.blocks_map_offset\n    size: header.blocks_map_size\n    type: blocks_map\n    doc: >\n      block_index = offset_in_virtual_disk / block_size\n      actual_data_offset = blocks_map[block_index]*block_size+metadata_size+offset_in_block\n\n      The blocks_map will take up blocks_in_image_max * sizeof(uint32_t) bytes;\n      since the blocks_map is read and written in a single operation, its size needs to be limited to INT_MAX; furthermore, when opening an image, the blocks_map size is rounded up to be aligned on BDRV_SECTOR_SIZE.\n      Therefore this should satisfy the following: blocks_in_image_max * sizeof(uint32_t) + BDRV_SECTOR_SIZE == INT_MAX + 1 (INT_MAX + 1 is the first value not representable as an int)\n      This guarantees that any value below or equal to the constant will, when multiplied by sizeof(uint32_t) and rounded up to a BDRV_SECTOR_SIZE boundary, still be below or equal to INT_MAX.\n  disk:\n    pos: header.blocks_offset\n    #size: header.header_main.disk_size\n    type: disk\ntypes:\n  header:\n    seq:\n      - id: text\n        type: str\n        size: 0x40\n\n      - id: signature\n        contents: [0x7F, 0x10, 0xDA, 0xBE]\n\n      - id: version\n        type: version\n\n      - id: header_size_optional\n        type: u4\n        if: subheader_size_is_dynamic\n\n      - id: header_main\n        size: header_size\n        type: header_main\n    instances:\n      subheader_size_is_dynamic:\n        value: version.major>=1\n      header_size:\n        value: '(subheader_size_is_dynamic ? header_size_optional : 336)'\n\n      blocks_map_size:\n        value: ( ( header_main.blocks_in_image * 4 + header_main.geometry.sector_size - 1 ) / header_main.geometry.sector_size ) * header_main.geometry.sector_size\n      blocks_map_offset:\n        value: header_main.blocks_map_offset\n\n      blocks_offset:\n        -orig-id: data_offset\n        value: header_main.offset_data\n      block_size:\n        value: header_main.block_metadata_size + header_main.block_data_size\n\n    types:\n      uuid:\n        seq:\n          - id: uuid\n            size: 16\n      version:\n        seq:\n          - id: major\n            type: u2\n          - id: minor\n            type: u2\n      header_main:\n        seq:\n          - id: image_type\n            type: u4\n            enum: image_type\n\n          - id: image_flags\n            type: flags\n\n          - id: description\n            type: str\n            size: 256\n\n          - id: blocks_map_offset\n            -orig-id: offset_bmap\n            type: u4\n            if: _parent.version.major>=1\n\n          - id: offset_data\n            type: u4\n            if: _parent.version.major>=1\n\n          - id: geometry\n            type: geometry\n\n          - id: reserved1\n            -orig-id: unused1\n            type: u4\n            if: _parent.version.major>=1\n\n          - id: disk_size\n            type: u8\n\n          - id: block_data_size\n            -orig-id: block_size\n            type: u4\n            doc: \"Size of block (bytes).\"\n\n          - id: block_metadata_size\n            -orig-id: block_extra\n            type: u4\n            if: _parent.version.major>=1\n\n          - id: blocks_in_image\n            type: u4\n\n          - id: blocks_allocated\n            type: u4\n\n          - id: uuid_image\n            type: uuid\n\n          - id: uuid_last_snap\n            type: uuid\n\n          - id: uuid_link\n            type: uuid\n\n          - id: uuid_parent\n            type: uuid\n            if: _parent.version.major>=1\n\n          - id: lchc_geometry\n            type: geometry\n            if: _parent.version.major>=1 and _io.pos + 16 <= _io.size\n\n          #- id: reserved2\n          #  -orig_id: unused2\n          #  size: _io.size - _io.pos\n        types:\n          geometry:\n            seq:\n              - id: cylinders\n                type: u4\n\n              - id: heads\n                type: u4\n\n              - id: sectors\n                type: u4\n\n              - id: sector_size\n                type: u4\n          flags:\n            seq: #little endian assummed\n              - id: reserved0\n                type: b15\n              - id: zero_expand\n                type: b1\n              - id: reserved1\n                type: b6\n              - id: diff\n                type: b1\n              - id: fixed\n                type: b1\n              - id: reserved2\n                type: b8\n  blocks_map:\n    seq:\n      - id: index\n        type: block_index\n        repeat: expr\n        repeat-expr: _root.header.header_main.blocks_in_image\n    types:\n      block_index:\n        seq:\n          - id: index\n            type: u4\n        instances:\n          is_allocated:\n            value: index < _root.block_discarded\n          block:\n            #io: _root.disk._io\n            value: _root.disk.blocks[index]\n            if: is_allocated\n  disk:\n    seq:\n      - id: blocks\n        type: block\n        repeat: expr\n        repeat-expr: _root.header.header_main.blocks_in_image\n    types:\n      block:\n        seq:\n          - id: metadata\n            size: _root.header.header_main.block_metadata_size\n          - id: data\n            size: _root.header.header_main.block_data_size\n            type: sector\n            repeat: eos\n        types:\n          sector:\n            seq:\n              - id: data\n                size: _root.header.header_main.geometry.sector_size\n\nenums:\n  image_type:\n    1: dynamic\n    2: static\n    3: undo\n    4: diff\n"
  },
  {
    "id": "ksy_vfat",
    "name": "Vfat",
    "category": "File System",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "",
      "originalCategory": "filesystem",
      "filePath": "filesystem/vfat.ksy",
      "endian": "le"
    },
    "content": "meta:\n  id: vfat\n  # actually FAT12\n  xref:\n    forensicswiki: fat\n    justsolve: FAT\n    wikidata: Q190167\n  tags:\n    - dos\n  license: CC0-1.0\n  ks-version: 0.9\n  imports:\n    - /common/dos_datetime\n  endian: le\n  bit-endian: le\ndoc-ref: https://download.microsoft.com/download/0/8/4/084c452b-b772-4fe5-89bb-a0cbf082286a/fatgen103.doc\nseq:\n  - id: boot_sector\n    type: boot_sector\ninstances:\n  fats:\n    pos: boot_sector.pos_fats\n    size: boot_sector.size_fat\n    repeat: expr\n    repeat-expr: boot_sector.bpb.num_fats\n  root_dir:\n    pos: boot_sector.pos_root_dir\n    size: boot_sector.size_root_dir\n    type: root_directory\ntypes:\n  boot_sector:\n    seq:\n      - id: jmp_instruction\n        size: 3\n      - id: oem_name\n        type: str\n        encoding: ASCII\n        pad-right: 0x20\n        size: 8\n      - id: bpb\n        type: bios_param_block\n        doc: Basic BIOS parameter block, present in all versions of FAT\n      - id: ebpb_fat16\n        type: ext_bios_param_block_fat16\n        if: not is_fat32\n        doc: FAT12/16-specific extended BIOS parameter block\n      - id: ebpb_fat32\n        type: ext_bios_param_block_fat32\n        if: is_fat32\n        doc: FAT32-specific extended BIOS parameter block\n    instances:\n      is_fat32:\n        value: bpb.max_root_dir_rec == 0\n        doc: |\n          Determines if filesystem is FAT32 (true) or FAT12/16 (false)\n          by analyzing some preliminary conditions in BPB. Used to\n          determine whether we should parse post-BPB data as\n          `ext_bios_param_block_fat16` or `ext_bios_param_block_fat32`.\n      pos_fats:\n        value: bpb.bytes_per_ls * bpb.num_reserved_ls\n        doc: Offset of FATs in bytes from start of filesystem\n      ls_per_fat:\n        value: 'is_fat32 ? ebpb_fat32.ls_per_fat : bpb.ls_per_fat'\n      size_fat:\n        value: bpb.bytes_per_ls * ls_per_fat\n        doc: Size of one FAT in bytes\n      pos_root_dir:\n        value: bpb.bytes_per_ls * (bpb.num_reserved_ls + ls_per_fat * bpb.num_fats)\n        doc: Offset of root directory in bytes from start of filesystem\n      ls_per_root_dir:\n        -orig-id: RootDirSectors\n        value: (bpb.max_root_dir_rec * 32 + bpb.bytes_per_ls - 1) / bpb.bytes_per_ls\n        doc: Size of root directory in logical sectors\n        doc-ref: 'FAT: General Overview of On-Disk Format, section \"FAT Data Structure\"'\n      size_root_dir:\n        value: ls_per_root_dir * bpb.bytes_per_ls\n        doc: Size of root directory in bytes\n  bios_param_block:\n    seq:\n      # Basic BIOS Parameter block, DOS 2.0+\n      - id: bytes_per_ls\n        -orig-id: BPB_BytsPerSec\n        type: u2\n        doc: Bytes per logical sector\n      - id: ls_per_clus\n        -orig-id: BPB_SecPerClus\n        type: u1\n        doc: Logical sectors per cluster\n      - id: num_reserved_ls\n        -orig-id: BPB_RsvdSecCnt\n        type: u2\n        doc: |\n          Count of reserved logical sectors. The number of logical\n          sectors before the first FAT in the file system image.\n      - id: num_fats\n        -orig-id: BPB_NumFATs\n        type: u1\n        doc: Number of File Allocation Tables\n      - id: max_root_dir_rec\n        -orig-id: BPB_RootEntCnt\n        type: u2\n        doc: |\n          Maximum number of FAT12 or FAT16 root directory entries. 0\n          for FAT32, where the root directory is stored in ordinary\n          data clusters.\n      - id: total_ls_2\n        -orig-id: BPB_TotSec16\n        type: u2\n        doc: Total logical sectors (if zero, use total_ls_4)\n      - id: media_code\n        -orig-id: BPB_Media\n        type: u1\n        doc: Media descriptor\n      - id: ls_per_fat\n        -orig-id: BPB_FATSz16\n        type: u2\n        doc: |\n          Logical sectors per File Allocation Table for\n          FAT12/FAT16. FAT32 sets this to 0 and uses the 32-bit value\n          at offset 0x024 instead.\n      # FIXME: DOS 3.0 and 3.2 BPBs continuation should follow here\n      # and they differ from DOS 3.31+ that most modern\n      # implementations use. We'll skip them for now, as they seem to\n      # be very rare.\n      #\n      # DOS 3.31+ BPB\n      - id: ps_per_track\n        -orig-id: BPB_SecPerTrk\n        type: u2\n        doc: |\n          Physical sectors per track for disks with INT 13h CHS\n          geometry, e.g., 15 for a \"1.20 MB\" (1200 KB) floppy. A zero\n          entry indicates that this entry is reserved, but not used.\n      - id: num_heads\n        -orig-id: BPB_NumHeads\n        type: u2\n        doc: |\n          Number of heads for disks with INT 13h CHS geometry,[9]\n          e.g., 2 for a double sided floppy.\n      - id: num_hidden_sectors\n        -orig-id: BPB_HiddSec\n        type: u4\n        doc: |\n          Number of hidden sectors preceding the partition that\n          contains this FAT volume. This field should always be zero\n          on media that are not partitioned. This DOS 3.0 entry is\n          incompatible with a similar entry at offset 0x01C in BPBs\n          since DOS 3.31.  It must not be used if the logical sectors\n          entry at offset 0x013 is zero.\n      - id: total_ls_4\n        -orig-id: BPB_TotSec32\n        type: u4\n        doc: |\n          Total logical sectors including hidden sectors. This DOS 3.2\n          entry is incompatible with a similar entry at offset 0x020\n          in BPBs since DOS 3.31. It must not be used if the logical\n          sectors entry at offset 0x013 is zero.\n  ext_bios_param_block_fat16:\n    doc: |\n      Extended BIOS Parameter Block (DOS 4.0+, OS/2 1.0+). Used only\n      for FAT12 and FAT16.\n    seq:\n      - id: phys_drive_num\n        type: u1\n        doc: |\n          Physical drive number (0x00 for (first) removable media,\n          0x80 for (first) fixed disk as per INT 13h).\n      - id: reserved1\n        type: u1\n      - id: ext_boot_sign\n        type: u1\n        doc: |\n          Should be 0x29 to indicate that an EBPB with the following 3\n          entries exists.\n      - id: volume_id\n        size: 4\n        doc: |\n          Volume ID (serial number).\n\n          Typically the serial number \"xxxx-xxxx\" is created by a\n          16-bit addition of both DX values returned by INT 21h/AH=2Ah\n          (get system date) and INT 21h/AH=2Ch (get system time) for\n          the high word and another 16-bit addition of both CX values\n          for the low word of the serial number. Alternatively, some\n          DR-DOS disk utilities provide a /# option to generate a\n          human-readable time stamp \"mmdd-hhmm\" build from BCD-encoded\n          8-bit values for the month, day, hour and minute instead of\n          a serial number.\n      - id: partition_volume_label\n        size: 11\n        type: str\n        encoding: ASCII\n        pad-right: 0x20\n      - id: fs_type_str\n        size: 8\n        type: str\n        encoding: ASCII\n        pad-right: 0x20\n  ext_bios_param_block_fat32:\n    doc: Extended BIOS Parameter Block for FAT32\n    seq:\n      - id: ls_per_fat\n        type: u4\n        doc: |\n          Logical sectors per file allocation table (corresponds with\n          the old entry `ls_per_fat` in the DOS 2.0 BPB).\n      - id: has_active_fat\n        type: b1\n        doc: |\n          If true, then there is \"active\" FAT, which is designated in\n          `active_fat` attribute. If false, all FATs are mirrored as\n          usual.\n      - id: reserved1\n        type: b3\n      - id: active_fat_id\n        type: b4\n        doc: |\n          Zero-based number of active FAT, if `has_active_fat`\n          attribute is true.\n      - id: reserved2\n        contents: [0]\n      - id: fat_version\n        type: u2\n      - id: root_dir_start_clus\n        type: u4\n        doc: |\n          Cluster number of root directory start, typically 2 if it\n          contains no bad sector. (Microsoft's FAT32 implementation\n          imposes an artificial limit of 65,535 entries per directory,\n          whilst many third-party implementations do not.)\n      - id: ls_fs_info\n        type: u2\n        doc: |\n          Logical sector number of FS Information Sector, typically 1,\n          i.e., the second of the three FAT32 boot sectors. Values\n          like 0 and 0xFFFF are used by some FAT32 implementations to\n          designate abscence of FS Information Sector.\n      - id: boot_sectors_copy_start_ls\n        type: u2\n        doc: |\n          First logical sector number of a copy of the three FAT32\n          boot sectors, typically 6.\n      - id: reserved3\n        size: 12\n      - id: phys_drive_num\n        type: u1\n        doc: |\n          Physical drive number (0x00 for (first) removable media,\n          0x80 for (first) fixed disk as per INT 13h).\n      - id: reserved4\n        type: u1\n      - id: ext_boot_sign\n        type: u1\n        doc: |\n          Should be 0x29 to indicate that an EBPB with the following 3\n          entries exists.\n      - id: volume_id\n        size: 4\n        doc: |\n          Volume ID (serial number).\n\n          Typically the serial number \"xxxx-xxxx\" is created by a\n          16-bit addition of both DX values returned by INT 21h/AH=2Ah\n          (get system date) and INT 21h/AH=2Ch (get system time) for\n          the high word and another 16-bit addition of both CX values\n          for the low word of the serial number. Alternatively, some\n          DR-DOS disk utilities provide a /# option to generate a\n          human-readable time stamp \"mmdd-hhmm\" build from BCD-encoded\n          8-bit values for the month, day, hour and minute instead of\n          a serial number.\n      - id: partition_volume_label\n        size: 11\n        type: str\n        encoding: ASCII\n        pad-right: 0x20\n      - id: fs_type_str\n        size: 8\n        type: str\n        encoding: ASCII\n        pad-right: 0x20\n  root_directory:\n    seq:\n      - id: records\n        type: root_directory_rec\n        repeat: expr\n        repeat-expr: _root.boot_sector.bpb.max_root_dir_rec\n  root_directory_rec:\n    seq:\n      - id: file_name\n        size: 11\n      - id: attrs\n        size: 1\n        type: attr_flags\n      - id: reserved\n        size: 10\n      - id: last_write_time\n        size: 4\n        type: dos_datetime\n      - id: start_clus\n        type: u2\n      - id: file_size\n        type: u4\n    types:\n      attr_flags:\n        seq:\n          - id: read_only\n            type: b1\n          - id: hidden\n            type: b1\n          - id: system\n            type: b1\n          - id: volume_id\n            type: b1\n          - id: is_directory\n            type: b1\n          - id: archive\n            type: b1\n          - id: reserved\n            type: b2\n        instances:\n          long_name:\n            value: |\n              read_only\n              and hidden\n              and system\n              and volume_id\n"
  },
  {
    "id": "ksy_vmware_vmdk",
    "name": "VMWare Virtual Disk",
    "category": "File System",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [
        "vmdk"
      ],
      "description": "VMWare Virtual Disk",
      "originalCategory": "filesystem",
      "filePath": "filesystem/vmware_vmdk.ksy",
      "signature": {
        "offset": 0,
        "bytes": [
          75,
          68,
          77,
          86
        ]
      },
      "endian": "le"
    },
    "content": "meta:\n  id: vmware_vmdk\n  title: VMWare Virtual Disk\n  file-extension: vmdk\n  xref:\n    forensicswiki: vmware_virtual_disk_format_(vmdk)\n    justsolve: VMDK\n    wikidata: Q2658179\n  license: CC0-1.0\n  endian: le\ndoc-ref: 'https://github.com/libyal/libvmdk/blob/main/documentation/VMWare%20Virtual%20Disk%20Format%20(VMDK).asciidoc#41-file-header'\nseq:\n  - id: magic\n    contents: \"KDMV\"\n  - id: version\n    type: s4\n  - id: flags\n    type: header_flags\n  - id: size_max\n    type: s8\n    doc: Maximum number of sectors in a given image file (capacity)\n  - id: size_grain\n    type: s8\n  - id: start_descriptor\n    type: s8\n    doc: Embedded descriptor file start sector number (0 if not available)\n  - id: size_descriptor\n    type: s8\n    doc: Number of sectors that embedded descriptor file occupies\n  - id: num_grain_table_entries\n    type: s4\n    doc: Number of grains table entries\n  - id: start_secondary_grain\n    type: s8\n    doc: Secondary (backup) grain directory start sector number\n  - id: start_primary_grain\n    type: s8\n    doc: Primary grain directory start sector number\n  - id: size_metadata\n    type: s8\n  - id: is_dirty\n    type: u1\n  - id: stuff\n    size: 4\n  - id: compression_method\n    type: u2\n    enum: compression_methods\nenums:\n  compression_methods:\n    0: none\n    1: deflate\ninstances:\n  len_sector:\n    value: 0x200\n  descriptor:\n    pos: start_descriptor * _root.len_sector\n    size: size_descriptor * _root.len_sector\n  grain_primary:\n    pos: start_primary_grain * _root.len_sector\n    size: size_grain * _root.len_sector\n  grain_secondary:\n    pos: start_secondary_grain * _root.len_sector\n    size: size_grain * _root.len_sector\ntypes:\n  header_flags:\n    doc-ref: 'https://github.com/libyal/libvmdk/blob/main/documentation/VMWare%20Virtual%20Disk%20Format%20(VMDK).asciidoc#411-flags'\n    seq:\n      - id: reserved1\n        type: b5\n      - id: zeroed_grain_table_entry\n        # 0x00000004\n        type: b1\n      - id: use_secondary_grain_dir\n        # 0x00000002\n        type: b1\n      - id: valid_new_line_detection_test\n        # 0x00000001\n        type: b1\n      - id: reserved2\n        type: u1\n      - id: reserved3\n        type: b6\n      - id: has_metadata\n        # 0x00020000\n        type: b1\n      - id: has_compressed_grain\n        # 0x00010000\n        type: b1\n      - id: reserved4\n        type: u1\n"
  },
  {
    "id": "ksy_zx_spectrum_tap",
    "name": "ZX Spectrum tape file",
    "category": "File System",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [
        "tap"
      ],
      "description": "ZX Spectrum tape file",
      "originalCategory": "filesystem",
      "filePath": "filesystem/zx_spectrum_tap.ksy",
      "endian": "le"
    },
    "content": "meta:\n  id: zx_spectrum_tap\n  title: ZX Spectrum tape file\n  file-extension: tap\n  xref:\n    justsolve: TAP_(ZX_Spectrum)\n    pronom: fmt/801\n    wikidata: Q34748140\n  license: CC0-1.0\n  endian: le\ndoc: |\n  TAP files are used by emulators of ZX Spectrum computer (released in\n  1982 by Sinclair Research). TAP file stores blocks of data as if\n  they are written to magnetic tape, which was used as primary media\n  for ZX Spectrum. Contents of this file can be viewed as a very\n  simple linear filesystem, storing named files with some basic\n  metainformation prepended as a header.\ndoc-ref: https://sinclair.wiki.zxnet.co.uk/wiki/TAP_format\nseq:\n  - id: blocks\n    type: block\n    repeat: eos\nenums:\n  flag_enum:\n    0x00: header\n    0xFF: data\n  header_type_enum:\n    0: program\n    1: num_array\n    2: char_array\n    3: bytes\ntypes:\n  block:\n    seq:\n      - id: len_block\n        type: u2\n      - id: flag\n        type: u1\n        enum: flag_enum\n      - id: header\n        type: header\n        if: len_block == 0x13 and flag == flag_enum::header\n      - id: data\n        size: header.len_data + 4\n        if: len_block == 0x13\n      - id: headerless_data\n        size: len_block - 1\n        if: flag == flag_enum::data\n  header:\n    seq:\n      - id: header_type\n        type: u1\n        enum: header_type_enum\n      - id: filename\n        size: 10\n        pad-right: 0x20\n      - id: len_data\n        type: u2\n      - id: params\n        type:\n          switch-on: header_type\n          cases:\n            'header_type_enum::program': program_params\n            'header_type_enum::num_array': array_params\n            'header_type_enum::char_array': array_params\n            'header_type_enum::bytes': bytes_params\n      - id: checksum\n        type: u1\n        doc: Bitwise XOR of all bytes including the flag byte\n  program_params:\n    seq:\n      - id: autostart_line\n        type: u2\n      - id: len_program\n        type: u2\n  array_params:\n    seq:\n      - id: reserved\n        type: u1\n      - id: var_name\n        type: u1\n        doc: Variable name (1..26 meaning A$..Z$ +192)\n      - id: reserved1\n        contents: [0x00, 0x80]\n  bytes_params:\n    seq:\n      - id: start_address\n        type: u2\n      - id: reserved\n        size: 2\n"
  }
];

export default {
  category: "File System",
  formats: file_systemFormats
};
