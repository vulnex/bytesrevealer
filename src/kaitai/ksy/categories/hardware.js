/**
 * Kaitai Formats - Hardware
 * 3 formats
 * Auto-generated: 2025-09-21T19:51:05.640Z
 */

export const hardwareFormats = [
  {
    "id": "ksy_dtb",
    "name": "Flattened Devicetree Format",
    "category": "Hardware",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [
        "dtb"
      ],
      "description": "Flattened Devicetree Format",
      "originalCategory": "hardware",
      "filePath": "hardware/dtb.ksy",
      "signature": {
        "offset": 0,
        "bytes": [
          208,
          13,
          254,
          237
        ]
      },
      "endian": "be"
    },
    "content": "meta:\n  id: dtb\n  title: Flattened Devicetree Format\n  file-extension: dtb\n  application:\n    - Linux\n    - Das U-Boot\n  xref:\n    wikidata: Q16960371\n  tags:\n    - linux\n    - serialization\n  license: CC0-1.0\n  ks-version: 0.9\n  encoding: ASCII\n  endian: be\ndoc: |\n  Also referred to as Devicetree Blob (DTB). It is a flat binary encoding\n  of data (primarily devicetree data, although other data is possible as well).\n  The data is internally stored as a tree of named nodes and properties. Nodes\n  contain properties and child nodes, while properties are name-value pairs.\n\n  The Devicetree Blobs (`.dtb` files) are compiled from the Devicetree Source\n  files (`.dts`) through the Devicetree compiler (DTC).\n\n  On Linux systems that support this, the blobs can be accessed in\n  `/sys/firmware/fdt`:\n\n  * <https://www.kernel.org/doc/Documentation/ABI/testing/sysfs-firmware-ofw>\n\n  The encoding of strings used in the `strings_block` and `structure_block` is\n  actually a subset of ASCII:\n\n  <https://devicetree-specification.readthedocs.io/en/v0.3/devicetree-basics.html#node-names>\n\n  Example files:\n\n  * <https://github.com/qemu/qemu/tree/master/pc-bios>\ndoc-ref:\n  - https://devicetree-specification.readthedocs.io/en/v0.3/flattened-format.html\n  - https://elinux.org/images/f/f4/Elc2013_Fernandes.pdf\nseq:\n  - id: magic\n    -orig-id: magic\n    contents: [0xd0, 0x0d, 0xfe, 0xed]\n  - id: total_size\n    -orig-id: totalsize\n    type: u4\n  - id: ofs_structure_block\n    -orig-id: off_dt_struct\n    type: u4\n  - id: ofs_strings_block\n    -orig-id: off_dt_strings\n    type: u4\n  - id: ofs_memory_reservation_block\n    -orig-id: off_mem_rsvmap\n    type: u4\n  - id: version\n    type: u4\n  - id: min_compatible_version\n    -orig-id: last_comp_version\n    type: u4\n    valid:\n      max: version\n  - id: boot_cpuid_phys\n    -orig-id: boot_cpuid_phys\n    type: u4\n  - id: len_strings_block\n    -orig-id: size_dt_strings\n    type: u4\n  - id: len_structure_block\n    -orig-id: size_dt_struct\n    type: u4\ninstances:\n  memory_reservation_block:\n    pos: ofs_memory_reservation_block\n    size: ofs_structure_block - ofs_memory_reservation_block\n    type: memory_block\n  structure_block:\n    pos: ofs_structure_block\n    size: len_structure_block\n    type: fdt_block\n  strings_block:\n    pos: ofs_strings_block\n    size: len_strings_block\n    type: strings\ntypes:\n  memory_block:\n    seq:\n      - id: entries\n        type: memory_block_entry\n        repeat: eos\n  memory_block_entry:\n    seq:\n      - id: address\n        type: u8\n        doc: physical address of a reserved memory region\n      - id: size\n        type: u8\n        doc: size of a reserved memory region\n  fdt_block:\n    seq:\n      - id: nodes\n        type: fdt_node\n        repeat: until\n        repeat-until: _.type == fdt::end\n  fdt_node:\n    -webide-representation: '{type} {body}'\n    seq:\n      - id: type\n        type: u4\n        enum: fdt\n      - id: body\n        type:\n          switch-on: type\n          cases:\n            fdt::begin_node: fdt_begin_node\n            fdt::prop: fdt_prop\n  fdt_begin_node:\n    -webide-representation: '{name}'\n    seq:\n      - id: name\n        type: strz\n      - id: padding\n        size: (- _io.pos) % 4\n  fdt_prop:\n    -webide-representation: '{name}'\n    seq:\n      - id: len_property\n        -orig-id: len\n        type: u4\n      - id: ofs_name\n        -orig-id: nameoff\n        type: u4\n      - id: property\n        size: len_property\n      - id: padding\n        size: (- _io.pos) % 4\n    instances:\n      name:\n        io: _root.strings_block._io\n        pos: ofs_name\n        type: strz\n        -webide-parse-mode: eager\n  strings:\n    seq:\n      - id: strings\n        type: strz\n        repeat: eos\nenums:\n  fdt:\n    0x00000001: begin_node\n    0x00000002: end_node\n    0x00000003: prop\n    0x00000004: nop\n    0x00000009: end\n"
  },
  {
    "id": "ksy_edid",
    "name": "EDID (VESA Enhanced Extended Display Identification Data)",
    "category": "Hardware",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "EDID (VESA Enhanced Extended Display Identification Data)",
      "originalCategory": "hardware",
      "filePath": "hardware/edid.ksy",
      "signature": {
        "offset": 0,
        "bytes": [
          0,
          255,
          255,
          255,
          255,
          255,
          255,
          0
        ]
      },
      "endian": "le"
    },
    "content": "meta:\n  id: edid\n  title: EDID (VESA Enhanced Extended Display Identification Data)\n  xref:\n    repo: https://github.com/kaitai-io/edid.ksy.git\n    wikidata: Q1376385\n  license: CC0-1.0\n  endian: le\nseq:\n  - id: magic\n    contents: [0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00]\n  - id: mfg_bytes\n    type: u2be\n  - id: product_code\n    type: u2\n    doc: Manufacturer product code\n  - id: serial\n    type: u4\n    doc: Serial number\n  - id: mfg_week\n    type: u1\n    doc: Week of manufacture. Week numbering is not consistent between manufacturers.\n  - id: mfg_year_mod\n    type: u1\n    doc: Year of manufacture, less 1990. (1990-2245). If week=255, it is the model year instead.\n  - id: edid_version_major\n    type: u1\n    doc: EDID version, usually 1 (for 1.3)\n  - id: edid_version_minor\n    type: u1\n    doc: EDID revision, usually 3 (for 1.3)\n  - id: input_flags\n    type: u1\n  - id: screen_size_h\n    type: u1\n    doc: Maximum horizontal image size, in centimetres (max 292 cm/115 in at 16:9 aspect ratio)\n  - id: screen_size_v\n    type: u1\n    doc: Maximum vertical image size, in centimetres. If either byte is 0, undefined (e.g. projector)\n  - id: gamma_mod\n    type: u1\n    doc: Display gamma, datavalue = (gamma*100)-100 (range 1.00-3.54)\n  - id: features_flags\n    type: u1\n  - id: chromacity\n    type: chromacity_info\n    doc: 'Phosphor or filter chromaticity structure, which provides info on colorimetry and white point'\n    doc-ref: Standard, section 3.7\n  - id: est_timings\n    type: est_timings_info\n    doc: |\n      Block of bit flags that indicates support of so called\n      \"established timings\", which is a commonly used subset of VESA\n      DMT (Discrete Monitor Timings) modes.\n    doc-ref: Standard, section 3.8\n  - id: std_timings\n    size: 2\n    type: std_timing\n    doc: |\n      Array of descriptions of so called \"standard timings\", which are\n      used to specify up to 8 additional timings not included in\n      \"established timings\".\n    repeat: expr\n    repeat-expr: 8\ntypes:\n  chromacity_info:\n    doc: |\n      Chromaticity information: colorimetry and white point\n      coordinates. All coordinates are stored as fixed precision\n      10-bit numbers, bits are shuffled for compactness.\n    seq:\n      - id: red_x_1_0\n        type: b2\n        doc: Red X, bits 1..0\n      - id: red_y_1_0\n        type: b2\n        doc: Red Y, bits 1..0\n      - id: green_x_1_0\n        type: b2\n        doc: Green X, bits 1..0\n      - id: green_y_1_0\n        type: b2\n        doc: Green Y, bits 1..0\n      - id: blue_x_1_0\n        type: b2\n        doc: Blue X, bits 1..0\n      - id: blue_y_1_0\n        type: b2\n        doc: Blue Y, bits 1..0\n      - id: white_x_1_0\n        type: b2\n        doc: White X, bits 1..0\n      - id: white_y_1_0\n        type: b2\n        doc: White Y, bits 1..0\n      - id: red_x_9_2\n        type: u1\n        doc: Red X, bits 9..2\n      - id: red_y_9_2\n        type: u1\n        doc: Red Y, bits 9..2\n      - id: green_x_9_2\n        type: u1\n        doc: Green X, bits 9..2\n      - id: green_y_9_2\n        type: u1\n        doc: Green Y, bits 9..2\n      - id: blue_x_9_2\n        type: u1\n        doc: Blue X, bits 9..2\n      - id: blue_y_9_2\n        type: u1\n        doc: Blue Y, bits 9..2\n      - id: white_x_9_2\n        type: u1\n        doc: White X, bits 9..2\n      - id: white_y_9_2\n        type: u1\n        doc: White Y, bits 9..2\n    instances:\n      # Raw chromacity coordinates as 10-bit integers\n      red_x_int:\n        value: '(red_x_9_2 << 2) | red_x_1_0'\n      red_y_int:\n        value: '(red_y_9_2 << 2) | red_y_1_0'\n      green_x_int:\n        value: '(green_x_9_2 << 2) | green_x_1_0'\n      green_y_int:\n        value: '(green_y_9_2 << 2) | green_y_1_0'\n      blue_x_int:\n        value: '(blue_x_9_2 << 2) | blue_x_1_0'\n      blue_y_int:\n        value: '(blue_y_9_2 << 2) | blue_y_1_0'\n      white_x_int:\n        value: '(white_x_9_2 << 2) | white_x_1_0'\n      white_y_int:\n        value: '(white_y_9_2 << 2) | white_y_1_0'\n      # User-friendly chromacity coordinates as floating point fractions\n      red_x:\n        value: red_x_int / 1024.0\n        doc: Red X coordinate\n      red_y:\n        value: red_y_int / 1024.0\n        doc: Red Y coordinate\n      green_x:\n        value: green_x_int / 1024.0\n        doc: Green X coordinate\n      green_y:\n        value: green_y_int / 1024.0\n        doc: Green Y coordinate\n      blue_x:\n        value: blue_x_int / 1024.0\n        doc: Blue X coordinate\n      blue_y:\n        value: blue_y_int / 1024.0\n        doc: Blue Y coordinate\n      white_x:\n        value: white_x_int / 1024.0\n        doc: White X coordinate\n      white_y:\n        value: white_y_int / 1024.0\n        doc: White Y coordinate\n  est_timings_info:\n    seq:\n      # Byte 0: \"Established Timing I\"\n      - id: can_720x400px_70hz\n        type: b1\n        doc: Supports 720 x 400 @ 70Hz\n      - id: can_720x400px_88hz\n        type: b1\n        doc: Supports 720 x 400 @ 88Hz\n      - id: can_640x480px_60hz\n        type: b1\n        doc: Supports 640 x 480 @ 60Hz\n      - id: can_640x480px_67hz\n        type: b1\n        doc: Supports 640 x 480 @ 67Hz\n      - id: can_640x480px_72hz\n        type: b1\n        doc: Supports 640 x 480 @ 72Hz\n      - id: can_640x480px_75hz\n        type: b1\n        doc: Supports 640 x 480 @ 75Hz\n      - id: can_800x600px_56hz\n        type: b1\n        doc: Supports 800 x 600 @ 56Hz\n      - id: can_800x600px_60hz\n        type: b1\n        doc: Supports 800 x 600 @ 60Hz\n      # Byte 1: \"Established Timing II\"\n      - id: can_800x600px_72hz\n        type: b1\n        doc: Supports 800 x 600 @ 72Hz\n      - id: can_800x600px_75hz\n        type: b1\n        doc: Supports 800 x 600 @ 75Hz\n      - id: can_832x624px_75hz\n        type: b1\n        doc: Supports 832 x 624 @ 75Hz\n      - id: can_1024x768px_87hz_i\n        type: b1\n        doc: Supports 1024 x 768 @ 87Hz(I)\n      - id: can_1024x768px_60hz\n        type: b1\n        doc: Supports 1024 x 768 @ 60Hz\n      - id: can_1024x768px_70hz\n        type: b1\n        doc: Supports 1024 x 768 @ 70Hz\n      - id: can_1024x768px_75hz\n        type: b1\n        doc: Supports 1024 x 768 @ 75Hz\n      - id: can_1280x1024px_75hz\n        type: b1\n        doc: Supports 1280 x 1024 @ 75Hz\n      # Byte 2: \"Manufacturer's Timings\"\n      - id: can_1152x870px_75hz\n        type: b1\n        doc: Supports 1152 x 870 @ 75Hz\n      - id: reserved\n        type: b7\n  std_timing:\n    seq:\n      - id: horiz_active_pixels_mod\n        type: u1\n        doc: |\n          Range of horizontal active pixels, written in modified form:\n          `(horiz_active_pixels / 8) - 31`. This yields an effective\n          range of 256..2288, with steps of 8 pixels.\n      - id: aspect_ratio\n        type: b2\n        enum: aspect_ratios\n        doc: |\n          Aspect ratio of the image. Can be used to calculate number\n          of vertical pixels.\n      - id: refresh_rate_mod\n        type: b6\n        doc: |\n          Refresh rate in Hz, written in modified form: `refresh_rate\n          - 60`. This yields an effective range of 60..123 Hz.\n    instances:\n      bytes_lookahead:\n        pos: 0\n        size: 2\n      is_used:\n        value: bytes_lookahead != [0x01, 0x01]\n      horiz_active_pixels:\n        value: (horiz_active_pixels_mod + 31) * 8\n        if: is_used\n        doc: Range of horizontal active pixels.\n      refresh_rate:\n        value: refresh_rate_mod + 60\n        if: is_used\n        doc: Vertical refresh rate, Hz.\n    enums:\n      aspect_ratios:\n        0: ratio_16_10\n        1: ratio_4_3\n        2: ratio_5_4\n        3: ratio_16_9\ninstances:\n  mfg_id_ch1:\n    value: '(mfg_bytes & 0b0111110000000000) >> 10'\n  mfg_id_ch2:\n    value: '(mfg_bytes & 0b0000001111100000) >> 5'\n  mfg_id_ch3:\n    value: '(mfg_bytes & 0b0000000000011111)'\n  mfg_str:\n    value: '[mfg_id_ch1 + 0x40, mfg_id_ch2 + 0x40, mfg_id_ch3 + 0x40].as<bytes>.to_s(\"ASCII\")'\n  mfg_year:\n    value: mfg_year_mod + 1990\n  gamma:\n    value: (gamma_mod + 100) / 100.0\n    if: gamma_mod != 0xff\n"
  },
  {
    "id": "ksy_mifare_classic",
    "name": "Mifare Classic RFID tag dump",
    "category": "Hardware",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [
        "mfd"
      ],
      "description": "Mifare Classic RFID tag dump",
      "originalCategory": "hardware",
      "filePath": "hardware/mifare/mifare_classic.ksy",
      "endian": "le"
    },
    "content": "meta:\n  id: mifare_classic\n  title: Mifare Classic RFID tag dump\n  file-extension: mfd\n  xref:\n    wikidata:\n      - Q29000512 # MIFARE Classic 1k\n      - Q29000513 # MIFARE Classic 4k\n  license: BSD-2-Clause\n  ks-version: 0.9\n  endian: le\ndoc-ref: |\n  https://github.com/nfc-tools/libnfc\n  https://www.nxp.com/docs/en/data-sheet/MF1S70YYX_V1.pdf\ndoc: |\n  You can get a dump for testing from this link:\n  <https://github.com/zhovner/mfdread/raw/master/dump.mfd>\nseq:\n  - id: sectors\n    size: ((_index >= 32)?4:1)*4*16 #sorry for this doubling of `block_size` (16), but we need `sector` be self-sufficient so we cannot use _root there\n    type: sector(_index == 0)\n    repeat: eos\ntypes:\n  key:\n    seq:\n      - id: key\n        size: 6\n  sector:\n    params:\n      - id: has_manufacturer\n        type: bool\n    seq:\n      - id: manufacturer\n        type: manufacturer\n        if: has_manufacturer\n\n      - id: data_filler\n        -orig-id: abtData\n        size: _io.size - _io.pos - 16 # sizeof(trailer)\n        type: filler\n      - id: trailer\n        type: trailer\n    instances:\n      block_size:\n        value: 16\n      data:\n        value: data_filler.data\n      blocks:\n        pos: 0\n        io: data_filler._io\n        size: block_size\n        repeat: eos\n      values:\n        pos: 0\n        io: data_filler._io\n        type: values\n    types:\n      values:\n        seq:\n          - id: values\n            type: value_block\n            repeat: eos\n        types:\n          value_block:\n            seq:\n              - id: valuez\n                type: u4\n                repeat: expr\n                repeat-expr: 3\n              - id: addrz\n                type: u1\n                repeat: expr\n                repeat-expr: 4\n            instances:\n              value_valid:\n                value: 'valuez[0]==~valuez[1] and valuez[0]==valuez[2]'\n              addr_valid:\n                value: 'addrz[0]==~addrz[1] and addrz[0]==addrz[2] and addrz[1]==addrz[3]'\n              valid:\n                value: 'value_valid and addr_valid'\n              addr:\n                value: 'addrz[0]'\n                if: valid\n              value:\n                value: valuez[0]\n                if: valid\n      filler:\n        doc: \"only to create _io\"\n        seq:\n          - id: data\n            size: _io.size\n  manufacturer:\n    seq:\n      - id: nuid\n        -orig-id: abtUID\n        type: u4\n        doc: beware for 7bytes UID it goes over next fields\n      - id: bcc\n        -orig-id: btBCC\n        type: u1\n      - id: sak # beware it's not always exactly SAK\n        -orig-id: btSAK\n        type: u1\n      - id: atqa\n        -orig-id: abtATQA\n        type: u2\n      - id: manufacturer\n        -orig-id: abtManufacturer\n        size: 8\n        doc: may contain manufacture date as BCD\n  trailer:\n    seq:\n      - id: key_a\n        -orig-id: abtKeyA\n        type: key\n      - id: access_bits\n        -orig-id: abtAccessBits\n        size: 3\n        type: access_conditions\n      - id: user_byte\n        -orig-id: abtAccessBits\n        type: u1\n\n      - id: key_b\n        -orig-id: abtKeyB\n        type: key\n    instances:\n      ac_bits:\n        value: 3\n      acs_in_sector:\n        value: 4\n      ac_count_of_chunks:\n        value: ac_bits*2 #6\n\n    types:\n      access_conditions:\n        seq:\n          - id: raw_chunks\n            type: b4 # _parent.acs_in_sector\n            repeat: expr\n            repeat-expr: _parent.ac_count_of_chunks\n        instances:\n          remaps:\n            pos: 0\n            repeat: expr\n            repeat-expr: _parent.ac_bits\n            type: chunk_bit_remap(_index)\n          chunks:\n            pos: 0\n            type: valid_chunk(raw_chunks[remaps[_index].inv_chunk_no], raw_chunks[remaps[_index].chunk_no])\n            repeat: expr\n            repeat-expr: _parent.ac_bits\n          acs_raw:\n            pos: 0\n            type: ac(_index)\n            repeat: expr\n            repeat-expr: _parent.acs_in_sector\n          data_acs:\n            pos: 0\n            type: data_ac(acs_raw[_index])\n            repeat: expr\n            repeat-expr: _parent.acs_in_sector-1\n          trailer_ac:\n            pos: 0\n            type: trailer_ac(acs_raw[_parent.acs_in_sector-1])\n        types:\n          chunk_bit_remap:\n            params:\n              - id: bit_no\n                type: u1\n            instances:\n              shift_value:\n                value: (bit_no==1?-1:1)\n              chunk_no:\n                value: '((inv_chunk_no+shift_value+_parent._parent.ac_count_of_chunks)%_parent._parent.ac_count_of_chunks)'\n              inv_chunk_no:\n                value: 'bit_no+shift_value'\n          valid_chunk:\n            params:\n              - id: inv_chunk\n                type: u1\n              - id: chunk\n                type: u1\n                doc: \"c3 c2 c1 c0\"\n            instances:\n              valid:\n                value: inv_chunk ^ chunk == 0b1111\n          ac:\n            params:\n              - id: index\n                type: u1\n            instances:\n              bits:\n                pos: 0\n                repeat: expr\n                repeat-expr: _parent._parent.ac_bits\n                type: ac_bit(index, _parent.chunks[_index].chunk)\n\n              val:\n                value: (bits[2].n << 2) | (bits[1].n << 1) | bits[0].n\n                doc: \"c3 c2 c1\"\n              inv_shift_val:\n                value: (bits[0].n << 2) | (bits[1].n << 1) | bits[2].n\n\n            types:\n              ac_bit:\n                params:\n                  - id: i\n                    type: u1\n                  - id: chunk\n                    type: u1\n                instances:\n                  n:\n                    value: (chunk >> i) & 1\n                  b:\n                    value: n == 1\n\n          trailer_ac:\n            params:\n              - id: ac\n                type: ac\n            instances:\n              can_read_key_b:\n                value: ac.inv_shift_val <= 0b010\n                doc: key A is required\n              can_write_keys:\n                value: \"(ac.inv_shift_val+1)%3 != 0 and (ac.inv_shift_val<6)\"\n              can_write_access_bits:\n                value: ac.bits[2].b\n              key_b_controls_write:\n                value: not can_read_key_b\n          data_ac:\n            params:\n              - id: ac\n                type: ac\n            instances:\n              read_key_a_required:\n                value: ac.val <= 0b100\n              read_key_b_required:\n                value: ac.val <= 0b110\n              write_key_a_required:\n                value: ac.val == 0\n\n\n              write_key_b_required:\n                value: (not read_key_a_required or read_key_b_required) and not ac.bits[0].b\n              increment_available:\n                value: (not ac.bits[0].b and not read_key_a_required and not read_key_b_required) or (not ac.bits[0].b and read_key_a_required and read_key_b_required)\n              decrement_available:\n                value: (ac.bits[1].b or not ac.bits[0].b) and not ac.bits[2].b\n"
  }
];

export default {
  category: "Hardware",
  formats: hardwareFormats
};
