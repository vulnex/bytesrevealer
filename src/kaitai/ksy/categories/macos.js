/**
 * Kaitai Formats - macOS
 * 8 formats
 * Auto-generated: 2025-09-21T19:51:05.641Z
 */

export const macosFormats = [
  {
    "id": "ksy_compressed_resource",
    "name": "Compressed Macintosh resource",
    "category": "macOS",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "Compressed Macintosh resource",
      "originalCategory": "macos",
      "filePath": "macos/compressed_resource.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: compressed_resource\n  title: Compressed Macintosh resource\n  application: Mac OS\n  license: MIT\n  ks-version: \"0.9\"\n  imports:\n    - /common/bytes_with_io\n  endian: be\ndoc: |\n  Compressed Macintosh resource data,\n  as stored in resources with the \"compressed\" attribute.\n\n  Resource decompression is not documented by Apple.\n  It is mostly used internally in System 7,\n  some of Apple's own applications (such as ResEdit),\n  and also by some third-party applications.\n  Later versions of Classic Mac OS make less use of resource compression,\n  but still support it fully for backwards compatibility.\n  Carbon in Mac OS X no longer supports resource compression in any way.\n\n  The data of all compressed resources starts with a common header,\n  followed by the compressed data.\n  The data is decompressed using code in a `'dcmp'` resource.\n  Some decompressors used by Apple are included in the System file,\n  but applications can also include custom decompressors.\n  The header of the compressed data indicates the ID of the `'dcmp'` resource used to decompress the data,\n  along with some parameters for the decompressor.\ndoc-ref:\n  - 'http://www.alysis.us/arctechnology.htm'\n  - 'http://preserve.mactech.com/articles/mactech/Vol.09/09.01/ResCompression/index.html'\n  - 'https://github.com/dgelessus/python-rsrcfork/tree/f891a6e/src/rsrcfork/compress'\nseq:\n  - id: header\n    type: header\n    doc: |\n      The header of the compressed data.\n  - id: compressed_data\n    size-eos: true\n    doc: |\n      The compressed resource data.\n\n      The format of this data is completely dependent on the decompressor and its parameters,\n      as specified in the header.\n      For details about the compressed data formats implemented by Apple's decompressors,\n      see the specs in the resource_compression subdirectory.\ntypes:\n  header:\n    doc: |\n      Compressed resource data header,\n      as stored at the start of all compressed resources.\n    seq:\n      - id: common_part\n        type: common_part\n        doc: |\n          The common part of the header.\n          Among other things,\n          this part contains the header type,\n          which determines the format of the data in the type-specific part of the header.\n      - id: type_specific_part_raw_with_io\n        type: bytes_with_io\n        size: common_part.len_header - common_part._sizeof\n        doc: |\n          Use `type_specific_part_raw` instead,\n          unless you need access to this field's `_io`.\n    instances:\n      type_specific_part_raw:\n        value: type_specific_part_raw_with_io.data\n        doc: |\n          The type-specific part of the header,\n          as a raw byte array.\n      type_specific_part:\n        io: type_specific_part_raw_with_io._io\n        pos: 0\n        type:\n          switch-on: common_part.header_type\n          cases:\n            8: type_specific_part_type_8\n            9: type_specific_part_type_9\n        doc: |\n          The type-specific part of the header,\n          parsed according to the type from the common part.\n    types:\n      common_part:\n        doc: |\n          The common part of a compressed resource data header.\n          The format of this part is the same for all compressed resources.\n        seq:\n          - id: magic\n            contents: [0xa8, 0x9f, 0x65, 0x72]\n            doc: |\n              The signature of all compressed resource data.\n\n              When interpreted as MacRoman, this byte sequence decodes to `®üer`.\n          - id: len_header\n            type: u2\n            valid: 0x12\n            doc: |\n              The byte length of the entire header (common and type-specific parts).\n\n              The meaning of this field is mostly a guess,\n              as all known header types result in a total length of `0x12`.\n          - id: header_type\n            type: u1\n            doc: |\n              Type of the header.\n              This determines the format of the data in the type-specific part of the header.\n\n              The only known header type values are `8` and `9`.\n\n              Every known decompressor is only compatible with one of the header types\n              (but every header type is used by more than one decompressor).\n              Apple's decompressors with IDs 0 and 1 use header type 8,\n              and those with IDs 2 and 3 use header type 9.\n          - id: unknown\n            type: u1\n            valid: 0x01\n            doc: |\n              The meaning of this field is not known.\n              It has the value `0x01` in all known compressed resources.\n          - id: len_decompressed\n            type: u4\n            doc: |\n              The byte length of the data after decompression.\n      type_specific_part_type_8:\n        doc: |\n          The type-specific part of a compressed resource header with header type `8`.\n        seq:\n          - id: working_buffer_fractional_size\n            type: u1\n            doc: |\n              The ratio of the compressed data size to the uncompressed data size,\n              times 256.\n\n              This parameter affects the amount of memory allocated by the Resource Manager during decompression,\n              but does not have a direct effect on the decompressor\n              (except that it will misbehave if insufficient memory is provided).\n              Alternative decompressors that decompress resources into a separate buffer rather than in-place can generally ignore this parameter.\n          - id: expansion_buffer_size\n            type: u1\n            doc: |\n              The maximum number of bytes that the compressed data might \"grow\" during decompression.\n\n              This parameter affects the amount of memory allocated by the Resource Manager during decompression,\n              but does not have a direct effect on the decompressor\n              (except that it will misbehave if insufficient memory is provided).\n              Alternative decompressors that decompress resources into a separate buffer rather than in-place can generally ignore this parameter.\n          - id: decompressor_id\n            type: s2\n            doc: |\n              The ID of the `'dcmp'` resource that should be used to decompress this resource.\n          - id: reserved\n            type: u2\n            valid: 0\n            doc: |\n              The meaning of this field is not known.\n              It has the value `0` in all known compressed resources,\n              so it is most likely reserved.\n      type_specific_part_type_9:\n        doc: |\n          The type-specific part of a compressed resource header with header type `9`.\n        seq:\n          - id: decompressor_id\n            type: s2\n            doc: |\n              The ID of the `'dcmp'` resource that should be used to decompress this resource.\n          - id: decompressor_specific_parameters_with_io\n            type: bytes_with_io\n            size: 4\n            doc: |\n              Use `decompressor_specific_parameters` instead,\n              unless you need access to this field's `_io`.\n        instances:\n          decompressor_specific_parameters:\n            value: decompressor_specific_parameters_with_io.data\n            doc: |\n              Decompressor-specific parameters.\n              The exact structure and meaning of this field is different for each decompressor.\n\n              This field always has the same length,\n              but decompressors don't always use the entirety of the field,\n              so depending on the decompressor some parts of this field may be meaningless.\n"
  },
  {
    "id": "ksy_ds_store",
    "name": "macOS '.DS_Store' format",
    "category": "macOS",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [
        "DS_Store"
      ],
      "description": "macOS '.DS_Store' format",
      "originalCategory": "macos",
      "filePath": "macos/ds_store.ksy",
      "signature": {
        "offset": 0,
        "bytes": [
          0,
          0,
          0,
          1
        ]
      },
      "endian": "be"
    },
    "content": "meta:\n  id: ds_store\n  title: macOS '.DS_Store' format\n  file-extension: DS_Store\n  xref:\n    justsolve: Desktop_Services_Store\n    pronom: fmt/394\n    wikidata: Q307271\n  license: MIT\n  ks-version: 0.9\n  encoding: UTF-8\n  endian: be\ndoc: |\n  Apple macOS '.DS_Store' file format.\ndoc-ref:\n  - https://en.wikipedia.org/wiki/.DS_Store\n  - https://metacpan.org/dist/Mac-Finder-DSStore/view/DSStoreFormat.pod\n  - https://0day.work/parsing-the-ds_store-file-format/\nseq:\n  - id: alignment_header\n    contents: [0x00, 0x00, 0x00, 0x01]\n  - id: buddy_allocator_header\n    type: buddy_allocator_header\ninstances:\n  buddy_allocator_body:\n    pos: buddy_allocator_header.ofs_bookkeeping_info_block + 4\n    size: buddy_allocator_header.len_bookkeeping_info_block\n    type: buddy_allocator_body\n  block_address_mask:\n    value: 0x1f\n    doc: |\n      Bitmask used to calculate the position and the size of each block\n      of the B-tree from the block addresses.\ntypes:\n  buddy_allocator_header:\n    seq:\n      - id: magic\n        contents: [\"Bud1\"]\n        doc: Magic number 'Bud1'.\n      - id: ofs_bookkeeping_info_block\n        type: u4\n      - id: len_bookkeeping_info_block\n        type: u4\n      - id: copy_ofs_bookkeeping_info_block\n        type: u4\n        doc: Needs to match 'offset_bookkeeping_info_block'.\n      - size: 16\n        doc: |\n          Unused field which might simply be the unused space at the end of the block,\n          since the minimum allocation size is 32 bytes.\n  buddy_allocator_body:\n    seq:\n      - id: num_blocks\n        type: u4\n        doc: Number of blocks in the allocated-blocks list.\n      - size: 4\n        doc: Unknown field which appears to always be 0.\n      - id: block_addresses\n        type: block_descriptor\n        repeat: expr\n        repeat-expr: num_block_addresses\n        doc: Addresses of the different blocks.\n      - id: num_directories\n        type: u4\n        doc: Indicates the number of directory entries.\n      - id: directory_entries\n        type: directory_entry\n        repeat: expr\n        repeat-expr: num_directories\n        doc: Each directory is an independent B-tree.\n      - id: free_lists\n        type: free_list\n        repeat: expr\n        repeat-expr: num_free_lists\n    types:\n      block_descriptor:\n        seq:\n          - id: address_raw\n            type: u4\n        instances:\n          offset:\n            value: (address_raw & ~_root.block_address_mask) + 4\n          size:\n            value: 1 << (address_raw & _root.block_address_mask)\n      directory_entry:\n        seq:\n          - id: len_name\n            type: u1\n          - id: name\n            size: len_name\n            type: str\n          - id: block_id\n            type: u4\n      free_list:\n        seq:\n          - id: counter\n            type: u4\n          - id: offsets\n            type: u4\n            repeat: expr\n            repeat-expr: counter\n    instances:\n      num_block_addresses:\n        value: 256\n      num_free_lists:\n        value: 32\n      directories:\n        io: _root._io\n        type: master_block_ref(_index)\n        repeat: expr\n        repeat-expr: num_directories\n        doc: Master blocks of the different B-trees.\n  master_block_ref:\n    params:\n      - id: idx\n        type: u8\n    instances:\n      master_block:\n        pos: _parent.block_addresses[_parent.directory_entries[idx].block_id].offset\n        size: _parent.block_addresses[_parent.directory_entries[idx].block_id].size\n        type: master_block\n    types:\n      master_block:\n        seq:\n          - id: block_id\n            type: u4\n            doc: Block number of the B-tree's root node.\n          - id: num_internal_nodes\n            type: u4\n            doc: Number of internal node levels.\n          - id: num_records\n            type: u4\n            doc: Number of records in the tree.\n          - id: num_nodes\n            type: u4\n            doc: Number of nodes in the tree.\n          - type: u4\n            doc: Always 0x1000, probably the B-tree node page size.\n        instances:\n          root_block:\n            io: _root._io\n            pos: _root.buddy_allocator_body.block_addresses[block_id].offset\n            type: block\n  block:\n    seq:\n      - id: mode\n        type: u4\n        doc: If mode is 0, this is a leaf node, otherwise it is an internal node.\n      - id: counter\n        type: u4\n        doc: Number of records or number of block id + record pairs.\n      - id: data\n        type: block_data(mode)\n        repeat: expr\n        repeat-expr: counter\n    types:\n      block_data:\n        params:\n          - id: mode\n            type: u4\n        seq:\n          - id: block_id\n            type: u4\n            if: mode > 0\n          - id: record\n            type: record\n        instances:\n          block:\n            io: _root._io\n            pos: _root.buddy_allocator_body.block_addresses[block_id.as<u4>].offset\n            type: block\n            if: mode > 0\n        types:\n          record:\n            seq:\n              - id: filename\n                type: ustr\n              - id: structure_type\n                type: four_char_code\n                doc: Description of the entry's property.\n              - id: data_type\n                size: 4\n                type: str\n                doc: Data type of the value.\n              - id: value\n                type:\n                  switch-on: data_type\n                  cases:\n                    '\"long\"': u4\n                    '\"shor\"': u4\n                    '\"bool\"': u1\n                    '\"blob\"': record_blob\n                    '\"type\"': four_char_code\n                    '\"ustr\"': ustr\n                    '\"comp\"': u8\n                    '\"dutc\"': u8\n            types:\n              record_blob:\n                seq:\n                  - id: length\n                    type: u4\n                  - id: value\n                    size: length\n              ustr:\n                seq:\n                  - id: length\n                    type: u4\n                  - id: value\n                    size: 2 * length\n                    type: str\n                    encoding: UTF-16BE\n              four_char_code:\n                seq:\n                  - id: value\n                    size: 4\n                    type: str\n    instances:\n      rightmost_block:\n        io: _root._io\n        pos: _root.buddy_allocator_body.block_addresses[mode].offset\n        type: block\n        if: mode > 0\n        doc: Rightmost child block pointer.\n"
  },
  {
    "id": "ksy_mac_os_resource_snd",
    "name": "Classic MacOS Sound Resource",
    "category": "macOS",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "Classic MacOS Sound Resource",
      "originalCategory": "macos",
      "filePath": "macos/mac_os_resource_snd.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: mac_os_resource_snd\n  title: Classic MacOS Sound Resource\n  application: Sound Manager\n  xref:\n    mac-os-resource-type: 'snd '\n    wikidata: Q7564684\n  license: MIT\n  endian: be\ndoc: |\n  Sound resources were introduced in Classic MacOS with the Sound Manager program.\n  They can contain sound commands to generate sounds with given frequencies as well as sampled sound data.\n  They are mostly found in resource forks, but can occasionally appear standalone or embedded in other files.\ndoc-ref: \"https://developer.apple.com/library/archive/documentation/mac/pdf/Sound/Sound_Manager.pdf\"\nseq:\n  - id: format\n    type: u2\n  - id: num_data_formats\n    -orig-id: number_of_data_formats\n    type: u2\n    if: format == 1\n  - id: data_formats\n    type: data_format\n    repeat: expr\n    repeat-expr: num_data_formats\n    if: format == 1\n  - id: reference_count\n    type: u2\n    if: format == 2\n  - id: num_sound_commands\n    -orig-id: number_of_sound_commands\n    type: u2\n  - id: sound_commands\n    type: sound_command\n    repeat: expr\n    repeat-expr: num_sound_commands\ninstances:\n  midi_note_to_frequency:\n    value: |\n      [\n        8.18, 8.66, 9.18, 9.72, 10.30, 10.91, 11.56, 12.25,\n        12.98, 13.75, 14.57, 15.43, 16.35, 17.32, 18.35, 19.45,\n        20.60, 21.83, 23.12, 24.50, 25.96, 27.50, 29.14, 30.87,\n        32.70, 34.65, 36.71, 38.89, 41.20, 43.65, 46.25, 49.00,\n        51.91, 55.00, 58.27, 61.74, 65.41, 69.30, 73.42, 77.78,\n        82.41, 87.31, 92.50, 98.00, 103.83, 110.00, 116.54, 123.47,\n        130.81, 138.59, 146.83, 155.56, 164.81, 174.61, 185.00, 196.00,\n        207.65, 220.00, 233.08, 246.94, 261.63, 277.18, 293.66, 311.13,\n        329.63, 349.23, 369.99, 392.00, 415.30, 440.00, 466.16, 493.88,\n        523.25, 554.37, 587.33, 622.25, 659.26, 698.46, 739.99, 783.99,\n        830.61, 880.00, 932.33, 987.77, 1046.50, 1108.73, 1174.66, 1244.51,\n        1318.51, 1396.91, 1479.98, 1567.98, 1661.22, 1760.00, 1864.66, 1975.53,\n        2093.00, 2217.46, 2349.32, 2489.02, 2637.02, 2793.83, 2959.96, 3135.96,\n        3322.44, 3520.00, 3729.31, 3951.07, 4186.01, 4434.92, 4698.64, 4978.03,\n        5274.04, 5587.65, 5919.91, 6271.93, 6644.88, 7040.00, 7458.62, 7902.13,\n        8372.02, 8869.84, 9397.27, 9956.06, 10548.08, 11175.30, 11839.82, 12543.85\n      ]\n    doc: |\n      Lookup table to convert a MIDI note into a frequency in Hz\n      The lookup table represents the formula (2 ** ((midi_note - 69) / 12)) * 440\n    doc-ref: https://en.wikipedia.org/wiki/MIDI_tuning_standard\ntypes:\n  data_format:\n    seq:\n      - id: id\n        type: u2\n        enum: data_type\n      - id: options\n        type: u4\n        doc: contains initialisation options for the SndNewChannel function\n    instances:\n      wave_init_channel_mask:\n        value: 0x07\n        doc: wave table only, Sound Manager 2.0 and earlier\n      wave_init:\n        value: options & wave_init_channel_mask\n        enum: wave_init_option\n        if: id == data_type::wave_table_synth\n      init_pan_mask:\n        -orig-id: initPanMask\n        value: 0x0003\n        doc: mask for right/left pan values\n      pan_init:\n        value: options & init_pan_mask\n        enum: init_option\n      init_stereo_mask:\n        -orig-id: initStereoMask\n        value: 0x00C0\n        doc: mask for mono/stereo values\n      stereo_init:\n        value: options & init_stereo_mask\n        enum: init_option\n      init_comp_mask:\n        -orig-id: initCompMask\n        value: 0xFF00\n        doc: mask for compression IDs\n      comp_init:\n        value: options & init_comp_mask\n        enum: init_option\n  sound_command:\n    seq:\n      - id: is_data_offset\n        type: b1\n      - id: cmd\n        type: b15\n        enum: cmd_type\n      - id: param1\n        type: u2\n      - id: param2\n        type: u4\n    instances:\n      sound_header:\n        pos: param2\n        type: sound_header\n        if: is_data_offset and cmd == cmd_type::buffer_cmd\n  sound_header:\n    seq:\n      - size: 0\n        if: start_ofs < 0 # invoking the `start_ofs` value instance to save the current `_io.pos`\n      - id: sample_ptr\n        -orig-id: samplePtr\n        type: u4\n        doc: pointer to samples (or 0 if samples follow data structure)\n      - id: num_samples\n        -orig-id: length\n        type: u4\n        doc: number of samples\n        if: sound_header_type == sound_header_type::standard\n      - id: num_channels\n        -orig-id: numChannels\n        type: u4\n        doc: number of channels in sample\n        if: sound_header_type == sound_header_type::extended or sound_header_type == sound_header_type::compressed\n      - id: sample_rate\n        -orig-id: sampleRate\n        type: unsigned_fixed_point\n        doc: The rate at which the sample was originally recorded.\n      - id: loop_start\n        -orig-id: loopStart\n        type: u4\n        doc: loop point beginning\n      - id: loop_end\n        -orig-id: loopEnd\n        type: u4\n        doc: loop point ending\n      - id: encode\n        type: u1\n        enum: sound_header_type\n        doc: sample's encoding option\n      - id: midi_note\n        type: u1\n        doc: base frequency of sample, expressed as MIDI note values, 60 is middle C\n        -orig-id: baseFrequency\n      - id: extended_or_compressed\n        type: extended_or_compressed\n        if: sound_header_type == sound_header_type::extended or sound_header_type == sound_header_type::compressed\n      - id: sample_area\n        -orig-id: sampleArea\n        size: |\n          sound_header_type == sound_header_type::standard ? num_samples :\n          sound_header_type == sound_header_type::extended ? extended_or_compressed.num_frames * num_channels * extended_or_compressed.bits_per_sample / 8 :\n          _io.size - _io.pos\n        doc: sampled-sound data\n        if: sample_ptr == 0\n    instances:\n      start_ofs:\n        value: _io.pos\n      base_freqeuncy:\n        value: _root.midi_note_to_frequency[midi_note]\n        #TODO: If https://github.com/kaitai-io/kaitai_struct/issues/216 is implemented:\n        #TODO: value: (2 ** ((midi_note - 69) / 12)) * 440\n        if: midi_note >= 0 and midi_note < 128\n        doc: |\n          base frequency of sample in Hz\n          Calculated with the formula (2 ** ((midi_note - 69) / 12)) * 440\n        doc-ref: https://en.wikipedia.org/wiki/MIDI_tuning_standard\n      sound_header_type:\n        pos: start_ofs + 20\n        type: u1\n        enum: sound_header_type\n  extended_or_compressed:\n    seq:\n      - id: num_frames\n        type: u4\n      - id: aiff_sample_rate\n        size: 10\n        doc: rate of original sample (Extended80)\n      - id: marker_chunk\n        -orig-id: markerChunk\n        type: u4\n        doc: reserved\n      - id: extended\n        type: extended\n        if: _parent.sound_header_type == sound_header_type::extended\n      - id: compressed\n        type: compressed\n        if: _parent.sound_header_type == sound_header_type::compressed\n      - id: bits_per_sample\n        -orig-id: sampleSize\n        type: u2\n        doc: number of bits per sample\n      - id: reserved\n        -orig-id: futureUse1, futureUse2, futureUse3, futureUse4\n        size: 14\n        doc: reserved\n        if: _parent.sound_header_type == sound_header_type::extended\n  extended:\n    seq:\n      - id: instrument_chunk_ptr\n        -orig-id: instrumentChunks\n        type: u4\n        doc: pointer to instrument info\n      - id: aes_recording_ptr\n        -orig-id: AESRecording\n        type: u4\n        doc: pointer to audio info\n  compressed:\n    seq:\n      - id: format\n        size: 4\n        type: str\n        encoding: ASCII\n        doc: data format type\n      - id: reserved\n        -orig-id: futureUse2\n        size: 4\n      - id: state_vars_ptr\n        -orig-id: stateVars\n        type: u4\n        doc: pointer to StateBlock\n      - id: left_over_samples_ptr\n        -orig-id: leftOverSamples\n        type: u4\n        doc: pointer to LeftOverBlock\n      - id: compression_id\n        -orig-id: compressionID\n        type: s2\n        doc: ID of compression algorithm\n      - id: packet_size\n        -orig-id: packetSize\n        type: u2\n        doc: number of bits per packet\n      - id: synthesizer_id\n        -orig-id: snthID\n        type: u2\n        doc: |\n          Latest Sound Manager documentation specifies this field as:\n          This field is unused. You should set it to 0.\n          Inside Macintosh (Volume VI, 1991) specifies it as:\n          Indicates the resource ID number of the 'snth' resource that was used to compress the packets contained in the compressed sound header.\n        doc-ref: \"https://vintageapple.org/inside_o/pdf/Inside_Macintosh_Volume_VI_1991.pdf Page 22-49, absolute page number 1169 in the PDF\"\n    instances:\n      compression_type:\n        value: compression_id\n        enum: compression_type_enum\n  unsigned_fixed_point:\n    seq:\n      - id: integer_part\n        type: u2\n      - id: fraction_part\n        type: u2\n    instances:\n      value:\n        value: integer_part + fraction_part/65535.0\nenums:\n  data_type:\n    0x01: square_wave_synth\n    0x03: wave_table_synth\n    0x05: sampled_synth\n  wave_init_option:\n    0x04:\n      id: channel0\n      -orig-id: waveInitChannel0\n      doc: Play sounds through the first wave-table channel\n    0x05:\n      id: channel1\n      -orig-id: waveInitChannel1\n      doc: Play sounds through the second wave-table channel\n    0x06:\n      id: channel2\n      -orig-id: waveInitChannel2\n      doc: Play sounds through the third wave-table channel\n    0x07:\n      id: channel3\n      -orig-id: waveInitChannel3\n      doc: Play sounds through the fourth wave-table channel\n  init_option:\n    0x0002:\n      id: chan_left\n      -orig-id: initChanLeft\n      doc: left stereo channel\n    0x0003:\n      id: chan_right\n      -orig-id: initChanRight\n      doc: right stereo channel\n    0x0004:\n      id: no_interp\n      -orig-id: initNoInterp\n      doc: no linear interpolation\n    0x0008:\n      id: no_drop\n      -orig-id: initNoDrop\n      doc: no drop-sample conversion\n    0x0080:\n      id: mono\n      -orig-id: initMono\n      doc: monophonic channel\n    0x00C0:\n      id: stereo\n      -orig-id: initStereo\n      doc: stereo channel\n    0x0300:\n      id: mace3\n      -orig-id: initMACE3\n      doc: MACE 3:1\n    0x0400:\n      id: mace6\n      -orig-id: initMACE6\n      doc: MACE 6:1\n\n  cmd_type:\n    0:\n      id: null_cmd\n      -orig-id: nullCmd\n      doc: do nothing\n    3:\n      id: quiet_cmd\n      -orig-id: quietCmd\n      doc: stop a sound that is playing\n    4:\n      id: flush_cmd\n      -orig-id: flushCmd\n      doc: flush a sound channel\n    5:\n      id: re_init_cmd\n      -orig-id: reInitCmd\n      doc: reinitialize a sound channel\n    10:\n      id: wait_cmd\n      -orig-id: waitCmd\n      doc: suspend processing in a channel\n    11:\n      id: pause_cmd\n      -orig-id: pauseCmd\n      doc: pause processing in a channel\n    12:\n      id: resume_cmd\n      -orig-id: resumeCmd\n      doc: resume processing in a channel\n    13:\n      id: call_back_cmd\n      -orig-id: callBackCmd\n      doc: execute a callback procedure\n    14:\n      id: sync_cmd\n      -orig-id: syncCmd\n      doc: synchronize channels\n    15:\n      id: empty_cmd\n      -orig-id: emptyCmd\n      doc: |\n        If no other commands are pending in the sound channel after a\n        resumeCmd command, the Sound Manager sends an emptyCmd command.\n        The emptyCmd command is sent only by the Sound Manager and\n        should not be issued by your application.\n    24:\n      id: available_cmd\n      -orig-id: availableCmd\n      doc: see if initialization options are supported\n    25:\n      id: version_cmd\n      -orig-id: versionCmd\n      doc: determine version\n    26:\n      id: total_load_cmd\n      -orig-id: totalLoadCmd\n      doc: report total CPU load\n    27:\n      id: load_cmd\n      -orig-id: loadCmd\n      doc: report CPU load for a new channel\n    40:\n      id: freq_duration_cmd\n      -orig-id: freqDurationCmd\n      doc: play a note for a duration\n    41:\n      id: rest_cmd\n      -orig-id: restCmd\n      doc: rest a channel for a duration\n    42:\n      id: freq_cmd\n      -orig-id: freqCmd\n      doc: change the pitch of a sound\n    43:\n      id: amp_cmd\n      -orig-id: ampCmd\n      doc: change the amplitude of a sound\n    44:\n      id: timbre_cmd\n      -orig-id: timbreCmd\n      doc: change the timbre of a sound\n    45:\n      id: get_amp_cmd\n      -orig-id: getAmpCmd\n      doc: get the amplitude of a sound\n    46:\n      id: volume_cmd\n      -orig-id: volumeCmd\n      doc: set volume\n    47:\n      id: get_volume_cmd\n      -orig-id: getVolumeCmd\n      doc: get volume\n    60:\n      id: wave_table_cmd\n      -orig-id: waveTableCmd\n      doc: install a wave table as a voice\n    61:\n      id: phase_cmd\n      -orig-id: phaseCmd\n      doc: Not documented\n    80:\n      id: sound_cmd\n      -orig-id: soundCmd\n      doc: install a sampled sound as a voice\n    81:\n      id: buffer_cmd\n      -orig-id: bufferCmd\n      doc: play a sampled sound\n    82:\n      id: rate_cmd\n      -orig-id: rateCmd\n      doc: set the pitch of a sampled sound\n    85:\n      id: get_rate_cmd\n      -orig-id: getRateCmd\n      doc: get the pitch of a sampled sound\n  sound_header_type:\n    0x00: standard\n    0xFF: extended\n    0xFE: compressed\n  compression_type_enum:\n    -2: variable_compression\n    -1: fixed_compression\n    0: not_compressed\n    1: two_to_one\n    2: eight_to_three\n    3: three_to_one\n    4: six_to_one\n"
  },
  {
    "id": "ksy_dcmp_0",
    "name": "Compressed Macintosh resource data, Apple `'dcmp' (0)` format",
    "category": "macOS",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "Compressed Macintosh resource data, Apple `'dcmp' (0)` format",
      "originalCategory": "macos",
      "filePath": "macos/resource_compression/dcmp_0.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: dcmp_0\n  title: Compressed Macintosh resource data, Apple `'dcmp' (0)` format\n  application: Mac OS\n  license: MIT\n  ks-version: \"0.8\"\n  imports:\n    - dcmp_variable_length_integer\n  endian: be\ndoc: |\n  Compressed resource data in `'dcmp' (0)` format,\n  as stored in compressed resources with header type `8` and decompressor ID `0`.\n\n  The `'dcmp' (0)` decompressor resource is included in the System file of System 7.0 and later.\n  This compression format is used for most compressed resources in System 7.0's files.\n  This decompressor is also included with and used by some other Apple applications,\n  such as ResEdit.\n\n  This compression format supports some basic general-purpose compression schemes,\n  including backreferences to previous data,\n  run-length encoding,\n  and delta encoding.\n  It also includes some types of compression tailored specifically to Mac OS resources,\n  including a set of single-byte codes that correspond to entries in a hard-coded lookup table,\n  and a specialized kind of delta encoding for segment loader jump tables.\n\n  Almost all parts of this compression format operate on units of 2 or 4 bytes.\n  As a result,\n  it is nearly impossible to store data with an odd length in this format.\n  To work around this limitation,\n  odd-length resources are padded with an extra byte before compressing them with this format.\n  This extra byte is ignored after decompression,\n  as the real (odd) length of the resource is stored in the compressed resource header.\n\n  The `'dcmp' (1)` compression format (see dcmp_1.ksy) is very similar to this format,\n  with the main difference that it operates mostly on single bytes rather than two-byte units.\ndoc-ref: 'https://github.com/dgelessus/python-rsrcfork/blob/f891a6e/src/rsrcfork/compress/dcmp0.py'\nseq:\n  - id: chunks\n    type: chunk\n    repeat: until\n    repeat-until: _.tag == 0xff\n    doc: |\n      The sequence of chunks that make up the compressed data.\ntypes:\n  chunk:\n    doc: |\n      A single chunk of compressed data.\n      Each chunk in the compressed data expands to a sequence of bytes in the uncompressed data,\n      except when `tag == 0xff`,\n      which marks the end of the data and does not correspond to any bytes in the uncompressed data.\n\n      Most chunks are stateless and always expand to the same data,\n      regardless of where the chunk appears in the sequence.\n      However,\n      some chunks affect the behavior of future chunks,\n      or expand to different data depending on which chunks came before them.\n    seq:\n      - id: tag\n        type: u1\n        doc: |\n          The chunk's tag byte.\n          This controls the structure of the body and the meaning of the chunk.\n      - id: body\n        type:\n          switch-on: |\n            tag >= 0x00 and tag <= 0x1f ? tag_kind::literal\n            : tag >= 0x20 and tag <= 0x4a ? tag_kind::backreference\n            : tag >= 0x4b and tag <= 0xfd ? tag_kind::table_lookup\n            : tag == 0xfe ? tag_kind::extended\n            : tag == 0xff ? tag_kind::end\n            : tag_kind::invalid\n          cases:\n            'tag_kind::literal': literal_body(tag)\n            'tag_kind::backreference': backreference_body(tag)\n            'tag_kind::table_lookup': table_lookup_body(tag)\n            'tag_kind::extended': extended_body\n            'tag_kind::end': end_body\n        doc: |\n          The chunk's body.\n\n          Certain chunks do not have any data following the tag byte.\n          In this case,\n          the body is a zero-length structure.\n    enums:\n      # Internal enum, only for use in the type switch above.\n      # This is a workaround for kaitai-io/kaitai_struct#489.\n      tag_kind:\n        -1: invalid\n        0: literal\n        1: backreference\n        2: table_lookup\n        3: extended\n        4: end\n    types:\n      literal_body:\n        doc: |\n          The body of a literal data chunk.\n\n          The data that this chunk expands to is stored literally in the body (`literal`).\n          Optionally,\n          the literal data may also be stored for use by future backreference chunks (`do_store`).\n\n          The length of the literal data is stored as a number of two-byte units.\n          This means that the literal data always has an even length in bytes.\n        params:\n          - id: tag\n            type: u1\n            doc: |\n              The tag byte preceding this chunk body.\n        seq:\n          - id: len_literal_div2_separate\n            type: u1\n            if: is_len_literal_div2_separate\n            doc: |\n              The length of the literal data,\n              in two-byte units.\n\n              This field is only present if the tag byte's low nibble is zero.\n              In practice,\n              this only happens if the length is 0x10 or greater,\n              because smaller lengths can be encoded into the tag byte.\n          - id: literal\n            size: len_literal\n            doc: |\n              The literal data.\n        instances:\n          do_store:\n            value: (tag & 0x10) != 0\n            doc: |\n              Whether this literal should be stored for use by future backreference chunks.\n\n              See the documentation of the `backreference_body` type for details about backreference chunks.\n          len_literal_div2_in_tag:\n            value: tag & 0x0f\n            doc: |\n              The part of the tag byte that indicates the length of the literal data,\n              in two-byte units.\n              If this value is 0,\n              the length is stored in a separate byte after the tag byte and before the literal data.\n          is_len_literal_div2_separate:\n            value: len_literal_div2_in_tag == 0\n            doc: |\n              Whether the length of the literal is stored separately from the tag.\n          len_literal_div2:\n            value: |\n              is_len_literal_div2_separate\n              ? len_literal_div2_separate\n              : len_literal_div2_in_tag\n            doc: |\n              The length of the literal data,\n              in two-byte units.\n\n              In practice,\n              this value is always greater than zero,\n              as there is no use in storing a zero-length literal.\n          len_literal:\n            value: len_literal_div2 * 2\n            doc: |\n              The length of the literal data,\n              in bytes.\n      backreference_body:\n        doc: |\n          The body of a backreference chunk.\n\n          This chunk expands to the data stored in a preceding literal chunk,\n          indicated by an index number (`index`).\n        params:\n          - id: tag\n            type: u1\n            doc: |\n              The tag byte preceding this chunk body.\n        seq:\n          - id: index_separate_minus\n            type:\n              switch-on: tag\n              cases:\n                0x20: u1\n                0x21: u1\n                0x22: u2\n            if: is_index_separate\n            doc: |\n              The index of the referenced literal chunk,\n              stored separately from the tag.\n              The value in this field is stored minus 0x28.\n              If the tag byte is 0x21,\n              the value is also stored minus 0x100,\n              *on top of* the regular offset\n              (i. e. minus 0x128 in total).\n\n              In other words,\n              for tag bytes 0x20 and 0x21,\n              the index is actually 9 bits large,\n              with the low 8 bits stored separately and the highest bit stored in the lowest bit of the tag byte.\n\n              This field is only present if the tag byte is 0x20 through 0x22.\n              For higher tag bytes,\n              the index is encoded in the tag byte.\n              Values smaller than 0x28 cannot be stored in this field,\n              they must always be encoded in the tag byte.\n        instances:\n          is_index_separate:\n            value: tag >= 0x20 and tag <= 0x22\n            doc: |\n              Whether the index is stored separately from the tag.\n          index_in_tag:\n            value: tag - 0x23\n            doc: |\n              The index of the referenced literal chunk,\n              as stored in the tag byte.\n          index_separate:\n            value: |\n              index_separate_minus + 0x28 + (tag == 0x21 ? 0x100 : 0)\n            if: is_index_separate\n            doc: |\n              The index of the referenced literal chunk,\n              as stored separately from the tag byte,\n              with the implicit offset corrected for.\n          index:\n            value: |\n              is_index_separate ? index_separate : index_in_tag\n            doc: |\n              The index of the referenced literal chunk.\n\n              Stored literals are assigned index numbers in the order in which they appear in the compressed data,\n              starting at 0.\n              Non-stored literals are not counted in the numbering and cannot be referenced using backreferences.\n              Once an index is assigned to a stored literal,\n              it is never changed or unassigned for the entire length of the compressed data.\n\n              As the name indicates,\n              a backreference can only reference stored literal chunks found *before* the backreference,\n              not ones that come after it.\n      table_lookup_body:\n        doc: |\n          The body of a table lookup chunk.\n          This body is always empty.\n\n          This chunk always expands to two bytes (`value`),\n          determined from the tag byte using a fixed lookup table (`lookup_table`).\n          This lookup table is hardcoded in the decompressor and always the same for all compressed data.\n        params:\n          - id: tag\n            type: u1\n            doc: |\n              The tag byte preceding this chunk body.\n        seq: []\n        instances:\n          lookup_table:\n            value: |\n              [\n                [0x00, 0x00],\n                [0x4e, 0xba], [0x00, 0x08], [0x4e, 0x75], [0x00, 0x0c],\n                [0x4e, 0xad], [0x20, 0x53], [0x2f, 0x0b], [0x61, 0x00],\n                [0x00, 0x10], [0x70, 0x00], [0x2f, 0x00], [0x48, 0x6e],\n                [0x20, 0x50], [0x20, 0x6e], [0x2f, 0x2e], [0xff, 0xfc],\n                [0x48, 0xe7], [0x3f, 0x3c], [0x00, 0x04], [0xff, 0xf8],\n                [0x2f, 0x0c], [0x20, 0x06], [0x4e, 0xed], [0x4e, 0x56],\n                [0x20, 0x68], [0x4e, 0x5e], [0x00, 0x01], [0x58, 0x8f],\n                [0x4f, 0xef], [0x00, 0x02], [0x00, 0x18], [0x60, 0x00],\n                [0xff, 0xff], [0x50, 0x8f], [0x4e, 0x90], [0x00, 0x06],\n                [0x26, 0x6e], [0x00, 0x14], [0xff, 0xf4], [0x4c, 0xee],\n                [0x00, 0x0a], [0x00, 0x0e], [0x41, 0xee], [0x4c, 0xdf],\n                [0x48, 0xc0], [0xff, 0xf0], [0x2d, 0x40], [0x00, 0x12],\n                [0x30, 0x2e], [0x70, 0x01], [0x2f, 0x28], [0x20, 0x54],\n                [0x67, 0x00], [0x00, 0x20], [0x00, 0x1c], [0x20, 0x5f],\n                [0x18, 0x00], [0x26, 0x6f], [0x48, 0x78], [0x00, 0x16],\n                [0x41, 0xfa], [0x30, 0x3c], [0x28, 0x40], [0x72, 0x00],\n                [0x28, 0x6e], [0x20, 0x0c], [0x66, 0x00], [0x20, 0x6b],\n                [0x2f, 0x07], [0x55, 0x8f], [0x00, 0x28], [0xff, 0xfe],\n                [0xff, 0xec], [0x22, 0xd8], [0x20, 0x0b], [0x00, 0x0f],\n                [0x59, 0x8f], [0x2f, 0x3c], [0xff, 0x00], [0x01, 0x18],\n                [0x81, 0xe1], [0x4a, 0x00], [0x4e, 0xb0], [0xff, 0xe8],\n                [0x48, 0xc7], [0x00, 0x03], [0x00, 0x22], [0x00, 0x07],\n                [0x00, 0x1a], [0x67, 0x06], [0x67, 0x08], [0x4e, 0xf9],\n                [0x00, 0x24], [0x20, 0x78], [0x08, 0x00], [0x66, 0x04],\n                [0x00, 0x2a], [0x4e, 0xd0], [0x30, 0x28], [0x26, 0x5f],\n                [0x67, 0x04], [0x00, 0x30], [0x43, 0xee], [0x3f, 0x00],\n                [0x20, 0x1f], [0x00, 0x1e], [0xff, 0xf6], [0x20, 0x2e],\n                [0x42, 0xa7], [0x20, 0x07], [0xff, 0xfa], [0x60, 0x02],\n                [0x3d, 0x40], [0x0c, 0x40], [0x66, 0x06], [0x00, 0x26],\n                [0x2d, 0x48], [0x2f, 0x01], [0x70, 0xff], [0x60, 0x04],\n                [0x18, 0x80], [0x4a, 0x40], [0x00, 0x40], [0x00, 0x2c],\n                [0x2f, 0x08], [0x00, 0x11], [0xff, 0xe4], [0x21, 0x40],\n                [0x26, 0x40], [0xff, 0xf2], [0x42, 0x6e], [0x4e, 0xb9],\n                [0x3d, 0x7c], [0x00, 0x38], [0x00, 0x0d], [0x60, 0x06],\n                [0x42, 0x2e], [0x20, 0x3c], [0x67, 0x0c], [0x2d, 0x68],\n                [0x66, 0x08], [0x4a, 0x2e], [0x4a, 0xae], [0x00, 0x2e],\n                [0x48, 0x40], [0x22, 0x5f], [0x22, 0x00], [0x67, 0x0a],\n                [0x30, 0x07], [0x42, 0x67], [0x00, 0x32], [0x20, 0x28],\n                [0x00, 0x09], [0x48, 0x7a], [0x02, 0x00], [0x2f, 0x2b],\n                [0x00, 0x05], [0x22, 0x6e], [0x66, 0x02], [0xe5, 0x80],\n                [0x67, 0x0e], [0x66, 0x0a], [0x00, 0x50], [0x3e, 0x00],\n                [0x66, 0x0c], [0x2e, 0x00], [0xff, 0xee], [0x20, 0x6d],\n                [0x20, 0x40], [0xff, 0xe0], [0x53, 0x40], [0x60, 0x08],\n                [0x04, 0x80], [0x00, 0x68], [0x0b, 0x7c], [0x44, 0x00],\n                [0x41, 0xe8], [0x48, 0x41],\n              ]\n            doc: |\n              Fixed lookup table that maps tag byte numbers to two bytes each.\n\n              The entries in the lookup table are offset -\n              index 0 stands for tag 0x4b, 1 for 0x4c, etc.\n          value:\n            value: lookup_table[tag - 0x4b]\n            doc: |\n              The two bytes that the tag byte expands to,\n              based on the fixed lookup table.\n      extended_body:\n        doc: |\n          The body of an extended chunk.\n          The meaning of this chunk depends on the extended tag byte stored in the chunk data.\n        seq:\n          - id: tag\n            type: u1\n            doc: |\n              The chunk's extended tag byte.\n              This controls the structure of the body and the meaning of the chunk.\n          - id: body\n            type:\n              switch-on: tag\n              cases:\n                0x00: jump_table_body\n                0x02: repeat_body(tag)\n                0x03: repeat_body(tag)\n                0x04: delta_encoding_16_bit_body\n                0x06: delta_encoding_32_bit_body\n            doc: |\n              The chunk's body.\n        types:\n          jump_table_body:\n            doc: |\n              The body of a jump table chunk.\n\n              This chunk generates parts of a segment loader jump table,\n              in the format found in `'CODE' (0)` resources.\n              It expands to the following data,\n              with all non-constant numbers encoded as unsigned 16-bit big-endian integers:\n\n              * `0x3f 0x3c` (push following segment number onto stack)\n              * The segment number\n              * `0xa9 0xf0` (`_LoadSeg` trap)\n              * For each address:\n                * The address\n                * `0x3f 0x3c` (push following segment number onto stack)\n                * The segment number\n                * `0xa9 0xf0` (`_LoadSeg` trap)\n\n              Note that this generates one jump table entry without an address before it,\n              meaning that this address needs to be generated by the preceding chunk.\n              All following jump table entries are generated with the addresses encoded in this chunk.\n            seq:\n              - id: segment_number_raw\n                type: dcmp_variable_length_integer\n                doc: |\n                  Raw variable-length integer representation of `segment_number`.\n              - id: num_addresses_raw\n                type: dcmp_variable_length_integer\n                doc: |\n                  Raw variable-length integer representation of `num_addresses`.\n              - id: addresses_raw\n                type: dcmp_variable_length_integer\n                repeat: expr\n                repeat-expr: num_addresses\n                doc: |\n                  The addresses for each generated jump table entry,\n                  stored as variable-length integers.\n\n                  The first address is stored literally and must be in the range `0x0 <= x <= 0xffff`,\n                  i. e. an unsigned 16-bit integer.\n\n                  All following addresses are stored as deltas relative to the previous address.\n                  Each of these deltas is stored plus 6;\n                  this value needs to be subtracted before (or after) adding it to the previous address.\n\n                  Each delta (after subtracting 6) should be positive,\n                  and adding it to the previous address should not result in a value larger than `0xffff`,\n                  i. e. there should be no 16-bit unsigned integer wraparound.\n                  These conditions are always met in all known jump table chunks,\n                  so it is not known how the original decompressor behaves otherwise.\n            instances:\n              segment_number:\n                value: segment_number_raw.value\n                doc: |\n                  The segment number for all of the generated jump table entries.\n\n                  Although it is stored as a variable-length integer,\n                  the segment number must be in the range `0x0 <= x <= 0xffff`,\n                  i. e. an unsigned 16-bit integer.\n              num_addresses:\n                value: num_addresses_raw.value\n                doc: |\n                  The number of addresses stored in this chunk.\n\n                  This number must be greater than 0.\n          repeat_body:\n            doc: |\n              The body of a repeat chunk.\n\n              This chunk expands to a 1-byte or 2-byte value repeated a number of times,\n              i. e. it implements a form of run-length encoding.\n            params:\n              - id: tag\n                type: u1\n                doc: |\n                  The extended tag byte preceding this chunk body.\n            seq:\n              - id: to_repeat_raw\n                type: dcmp_variable_length_integer\n                doc: |\n                  Raw variable-length integer representation of `to_repeat`.\n              - id: repeat_count_m1_raw\n                type: dcmp_variable_length_integer\n                doc: |\n                  Raw variable-length integer representation of `repeat_count_m1`.\n            instances:\n              byte_count:\n                value: |\n                  tag == 0x02 ? 1\n                  : tag == 0x03 ? 2\n                  : -1\n                doc: |\n                  The length in bytes of the value to be repeated.\n                  Regardless of the byte count,\n                  the value to be repeated is stored as a variable-length integer.\n              to_repeat:\n                value: to_repeat_raw.value\n                doc: |\n                  The value to repeat.\n\n                  Although it is stored as a variable-length integer,\n                  this value must fit into an unsigned big-endian integer that is as long as `byte_count`,\n                  i. e. either 8 or 16 bits.\n              repeat_count_m1:\n                value: repeat_count_m1_raw.value\n                doc: |\n                  The number of times to repeat the value,\n                  minus one.\n\n                  This value must not be negative.\n              repeat_count:\n                value: repeat_count_m1 + 1\n                doc: |\n                  The number of times to repeat the value.\n\n                  This value must be positive.\n          delta_encoding_16_bit_body:\n            doc: |\n              The body of a 16-bit delta encoding chunk.\n\n              This chunk expands to a sequence of 16-bit big-endian integer values.\n              The first value is stored literally.\n              All following values are stored as deltas relative to the previous value.\n            seq:\n              - id: first_value_raw\n                type: dcmp_variable_length_integer\n                doc: |\n                  Raw variable-length integer representation of `first_value`.\n              - id: num_deltas_raw\n                type: dcmp_variable_length_integer\n                doc: |\n                  Raw variable-length integer representation of `num_deltas`.\n              - id: deltas\n                type: s1\n                repeat: expr\n                repeat-expr: num_deltas\n                doc: |\n                  The deltas for each value relative to the previous value.\n\n                  Each of these deltas is a signed 8-bit value.\n                  When adding the delta to the previous value,\n                  16-bit integer wraparound is performed if necessary,\n                  so that the resulting value always fits into a 16-bit signed integer.\n            instances:\n              first_value:\n                value: first_value_raw.value\n                doc: |\n                  The first value in the sequence.\n\n                  Although it is stored as a variable-length integer,\n                  this value must be in the range `-0x8000 <= x <= 0x7fff`,\n                  i. e. a signed 16-bit integer.\n              num_deltas:\n                value: num_deltas_raw.value\n                doc: |\n                  The number of deltas stored in this chunk.\n\n                  This number must not be negative.\n          delta_encoding_32_bit_body:\n            doc: |\n              The body of a 32-bit delta encoding chunk.\n\n              This chunk expands to a sequence of 32-bit big-endian integer values.\n              The first value is stored literally.\n              All following values are stored as deltas relative to the previous value.\n            seq:\n              - id: first_value_raw\n                type: dcmp_variable_length_integer\n                doc: |\n                  Raw variable-length integer representation of `first_value`.\n              - id: num_deltas_raw\n                type: dcmp_variable_length_integer\n                doc: |\n                  Raw variable-length integer representation of `num_deltas`.\n              - id: deltas_raw\n                type: dcmp_variable_length_integer\n                repeat: expr\n                repeat-expr: num_deltas\n                doc: |\n                  The deltas for each value relative to the previous value,\n                  stored as variable-length integers.\n\n                  Each of these deltas is a signed value.\n                  When adding the delta to the previous value,\n                  32-bit integer wraparound is performed if necessary,\n                  so that the resulting value always fits into a 32-bit signed integer.\n            instances:\n              first_value:\n                value: first_value_raw.value\n                doc: |\n                  The first value in the sequence.\n              num_deltas:\n                value: num_deltas_raw.value\n                doc: |\n                  The number of deltas stored in this chunk.\n\n                  This number must not be negative.\n      end_body:\n        doc: |\n          The body of an end chunk.\n          This body is always empty.\n\n          The last chunk in the compressed data must always be an end chunk.\n          An end chunk cannot appear elsewhere in the compressed data.\n        seq: []\n"
  },
  {
    "id": "ksy_dcmp_1",
    "name": "Compressed Macintosh resource data, Apple `'dcmp' (1)` format",
    "category": "macOS",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "Compressed Macintosh resource data, Apple `'dcmp' (1)` format",
      "originalCategory": "macos",
      "filePath": "macos/resource_compression/dcmp_1.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: dcmp_1\n  title: Compressed Macintosh resource data, Apple `'dcmp' (1)` format\n  application: Mac OS\n  license: MIT\n  ks-version: \"0.8\"\n  imports:\n    - dcmp_variable_length_integer\n  endian: be\ndoc: |\n  Compressed resource data in `'dcmp' (1)` format,\n  as stored in compressed resources with header type `8` and decompressor ID `1`.\n\n  The `'dcmp' (1)` decompressor resource is included in the System file of System 7.0 and later.\n  This compression format is used for a few compressed resources in System 7.0's files\n  (such as the Finder Help file).\n  This decompressor is also included with and used by some other Apple applications,\n  such as ResEdit.\n  (Note: ResEdit includes the `'dcmp' (1)` resource,\n  but none of its resources actually use this decompressor.)\n\n  This compression format supports some basic general-purpose compression schemes,\n  including backreferences to previous data and run-length encoding.\n  It also includes some types of compression tailored specifically to Mac OS resources,\n  including a set of single-byte codes that correspond to entries in a hard-coded lookup table.\n\n  The `'dcmp' (0)` compression format (see dcmp_0.ksy) is very similar to this format,\n  with the main difference that it operates mostly on units of 2 or 4 bytes.\n  This makes the ``dcmp' (0)` format more suitable for word-aligned data,\n  such as executable code, bitmaps, sounds, etc.\n  The `'dcmp' (0)` format also appears to be generally preferred over `'dcmp' (1)`,\n  with the latter only being used in resource files that contain mostly unaligned data,\n  such as text.\ndoc-ref: 'https://github.com/dgelessus/python-rsrcfork/blob/f891a6e/src/rsrcfork/compress/dcmp1.py'\nseq:\n  - id: chunks\n    type: chunk\n    repeat: until\n    repeat-until: _.tag == 0xff\n    doc: |\n      The sequence of chunks that make up the compressed data.\ntypes:\n  chunk:\n    doc: |\n      A single chunk of compressed data.\n      Each chunk in the compressed data expands to a sequence of bytes in the uncompressed data,\n      except when `tag == 0xff`,\n      which marks the end of the data and does not correspond to any bytes in the uncompressed data.\n\n      Most chunks are stateless and always expand to the same data,\n      regardless of where the chunk appears in the sequence.\n      However,\n      some chunks affect the behavior of future chunks,\n      or expand to different data depending on which chunks came before them.\n    seq:\n      - id: tag\n        type: u1\n        doc: |\n          The chunk's tag byte.\n          This controls the structure of the body and the meaning of the chunk.\n      - id: body\n        type:\n          switch-on: |\n            tag >= 0x00 and tag <= 0x1f ? tag_kind::literal\n            : tag >= 0x20 and tag <= 0xcf ? tag_kind::backreference\n            : tag >= 0xd0 and tag <= 0xd1 ? tag_kind::literal\n            : tag == 0xd2 ? tag_kind::backreference\n            : tag >= 0xd5 and tag <= 0xfd ? tag_kind::table_lookup\n            : tag == 0xfe ? tag_kind::extended\n            : tag == 0xff ? tag_kind::end\n            : tag_kind::invalid\n          cases:\n            'tag_kind::literal': literal_body(tag)\n            'tag_kind::backreference': backreference_body(tag)\n            'tag_kind::table_lookup': table_lookup_body(tag)\n            'tag_kind::extended': extended_body\n            'tag_kind::end': end_body\n        doc: |\n          The chunk's body.\n\n          Certain chunks do not have any data following the tag byte.\n          In this case,\n          the body is a zero-length structure.\n    enums:\n      # Internal enum, only for use in the type switch above.\n      # This is a workaround for kaitai-io/kaitai_struct#489.\n      tag_kind:\n        -1: invalid\n        0: literal\n        1: backreference\n        2: table_lookup\n        3: extended\n        4: end\n    types:\n      literal_body:\n        doc: |\n          The body of a literal data chunk.\n\n          The data that this chunk expands to is stored literally in the body (`literal`).\n          Optionally,\n          the literal data may also be stored for use by future backreference chunks (`do_store`).\n        params:\n          - id: tag\n            type: u1\n            doc: |\n              The tag byte preceding this chunk body.\n        seq:\n          - id: len_literal_separate\n            type: u1\n            if: is_len_literal_separate\n            doc: |\n              The length of the literal data,\n              in bytes.\n\n              This field is only present if the tag byte is 0xd0 or 0xd1.\n              In practice,\n              this only happens if the length is 0x11 or greater,\n              because smaller lengths can be encoded into the tag byte.\n          - id: literal\n            size: len_literal\n            doc: |\n              The literal data.\n        instances:\n          do_store:\n            value: |\n              is_len_literal_separate ? tag == 0xd1 : (tag & 0x10) != 0\n            doc: |\n              Whether this literal should be stored for use by future backreference chunks.\n\n              See the documentation of the `backreference_body` type for details about backreference chunks.\n          len_literal_m1_in_tag:\n            value: tag & 0x0f\n            if: not is_len_literal_separate\n            doc: |\n              The part of the tag byte that indicates the length of the literal data,\n              in bytes,\n              minus one.\n\n              If the tag byte is 0xd0 or 0xd1,\n              the length is stored in a separate byte after the tag byte and before the literal data.\n          is_len_literal_separate:\n            value: tag >= 0xd0\n            doc: |\n              Whether the length of the literal is stored separately from the tag.\n          len_literal:\n            value: |\n              is_len_literal_separate\n              ? len_literal_separate\n              : len_literal_m1_in_tag + 1\n            doc: |\n              The length of the literal data,\n              in bytes.\n\n              In practice,\n              this value is always greater than zero,\n              as there is no use in storing a zero-length literal.\n      backreference_body:\n        doc: |\n          The body of a backreference chunk.\n\n          This chunk expands to the data stored in a preceding literal chunk,\n          indicated by an index number (`index`).\n        params:\n          - id: tag\n            type: u1\n            doc: |\n              The tag byte preceding this chunk body.\n        seq:\n          - id: index_separate_minus\n            type: u1\n            if: is_index_separate\n            doc: |\n              The index of the referenced literal chunk,\n              stored separately from the tag.\n              The value in this field is stored minus 0xb0.\n\n              This field is only present if the tag byte is 0xd2.\n              For other tag bytes,\n              the index is encoded in the tag byte.\n              Values smaller than 0xb0 cannot be stored in this field,\n              they must always be encoded in the tag byte.\n        instances:\n          is_index_separate:\n            value: tag == 0xd2\n            doc: |\n              Whether the index is stored separately from the tag.\n          index_in_tag:\n            value: tag - 0x20\n            doc: |\n              The index of the referenced literal chunk,\n              as stored in the tag byte.\n          index_separate:\n            value: |\n              index_separate_minus + 0xb0\n            if: is_index_separate\n            doc: |\n              The index of the referenced literal chunk,\n              as stored separately from the tag byte,\n              with the implicit offset corrected for.\n          index:\n            value: |\n              is_index_separate ? index_separate : index_in_tag\n            doc: |\n              The index of the referenced literal chunk.\n\n              Stored literals are assigned index numbers in the order in which they appear in the compressed data,\n              starting at 0.\n              Non-stored literals are not counted in the numbering and cannot be referenced using backreferences.\n              Once an index is assigned to a stored literal,\n              it is never changed or unassigned for the entire length of the compressed data.\n\n              As the name indicates,\n              a backreference can only reference stored literal chunks found *before* the backreference,\n              not ones that come after it.\n      table_lookup_body:\n        doc: |\n          The body of a table lookup chunk.\n          This body is always empty.\n\n          This chunk always expands to two bytes (`value`),\n          determined from the tag byte using a fixed lookup table (`lookup_table`).\n          This lookup table is hardcoded in the decompressor and always the same for all compressed data.\n        params:\n          - id: tag\n            type: u1\n            doc: |\n              The tag byte preceding this chunk body.\n        seq: []\n        instances:\n          lookup_table:\n            value: |\n              [\n                [0x00, 0x00], [0x00, 0x01], [0x00, 0x02],\n                [0x00, 0x03], [0x2e, 0x01], [0x3e, 0x01], [0x01, 0x01],\n                [0x1e, 0x01], [0xff, 0xff], [0x0e, 0x01], [0x31, 0x00],\n                [0x11, 0x12], [0x01, 0x07], [0x33, 0x32], [0x12, 0x39],\n                [0xed, 0x10], [0x01, 0x27], [0x23, 0x22], [0x01, 0x37],\n                [0x07, 0x06], [0x01, 0x17], [0x01, 0x23], [0x00, 0xff],\n                [0x00, 0x2f], [0x07, 0x0e], [0xfd, 0x3c], [0x01, 0x35],\n                [0x01, 0x15], [0x01, 0x02], [0x00, 0x07], [0x00, 0x3e],\n                [0x05, 0xd5], [0x02, 0x01], [0x06, 0x07], [0x07, 0x08],\n                [0x30, 0x01], [0x01, 0x33], [0x00, 0x10], [0x17, 0x16],\n                [0x37, 0x3e], [0x36, 0x37],\n              ]\n            doc: |\n              Fixed lookup table that maps tag byte numbers to two bytes each.\n\n              The entries in the lookup table are offset -\n              index 0 stands for tag 0xd5, 1 for 0xd6, etc.\n          value:\n            value: lookup_table[tag - 0xd5]\n            doc: |\n              The two bytes that the tag byte expands to,\n              based on the fixed lookup table.\n      extended_body:\n        doc: |\n          The body of an extended chunk.\n          The meaning of this chunk depends on the extended tag byte stored in the chunk data.\n        seq:\n          - id: tag\n            type: u1\n            doc: |\n              The chunk's extended tag byte.\n              This controls the structure of the body and the meaning of the chunk.\n          - id: body\n            type:\n              switch-on: tag\n              cases:\n                0x02: repeat_body\n            doc: |\n              The chunk's body.\n        types:\n          repeat_body:\n            doc: |\n              The body of a repeat chunk.\n\n              This chunk expands to the same byte repeated a number of times,\n              i. e. it implements a form of run-length encoding.\n            seq:\n              - id: to_repeat_raw\n                type: dcmp_variable_length_integer\n                doc: |\n                  Raw variable-length integer representation of `to_repeat`.\n              - id: repeat_count_m1_raw\n                type: dcmp_variable_length_integer\n                doc: |\n                  Raw variable-length integer representation of `repeat_count_m1`.\n            instances:\n              to_repeat:\n                value: to_repeat_raw.value\n                doc: |\n                  The value to repeat.\n\n                  Although it is stored as a variable-length integer,\n                  this value must fit into an unsigned 8-bit integer.\n              repeat_count_m1:\n                value: repeat_count_m1_raw.value\n                doc: |\n                  The number of times to repeat the value,\n                  minus one.\n\n                  This value must not be negative.\n              repeat_count:\n                value: repeat_count_m1 + 1\n                doc: |\n                  The number of times to repeat the value.\n\n                  This value must be positive.\n      end_body:\n        doc: |\n          The body of an end chunk.\n          This body is always empty.\n\n          The last chunk in the compressed data must always be an end chunk.\n          An end chunk cannot appear elsewhere in the compressed data.\n        seq: []\n"
  },
  {
    "id": "ksy_dcmp_2",
    "name": "Compressed Macintosh resource data, Apple `'dcmp' (2)` format",
    "category": "macOS",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "Compressed Macintosh resource data, Apple `'dcmp' (2)` format",
      "originalCategory": "macos",
      "filePath": "macos/resource_compression/dcmp_2.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: dcmp_2\n  title: Compressed Macintosh resource data, Apple `'dcmp' (2)` format\n  application: Mac OS\n  license: MIT\n  ks-version: \"0.8\"\n  imports:\n    - /common/bytes_with_io\n  endian: be\ndoc: |\n  Compressed resource data in `'dcmp' (2)` format,\n  as stored in compressed resources with header type `9` and decompressor ID `2`.\n\n  The `'dcmp' (2)` decompressor resource is included in the System file of System 7.0 and later.\n  This compression format is used for a few compressed resources in System 7.0's files\n  (such as the System file).\n  This decompressor is also included with and used by some other Apple applications,\n  such as ResEdit.\n  (Note: ResEdit includes the `'dcmp' (2)` resource,\n  but none of its resources actually use this decompressor.)\n\n  This compression format is based on simple dictionary coding,\n  where each byte in the compressed data expands to two bytes,\n  based on a lookup table\n  (either included in the compressed data or provided by the decompressor).\n  An alternative \"tagged\" compression format is also supported,\n  which allows using two-byte literals in addition to single-byte table references,\n  at the cost of requiring an extra \"tag\" byte every 16 output bytes,\n  to differentiate literals and table references.\ndoc-ref: 'https://github.com/dgelessus/python-rsrcfork/blob/f891a6e/src/rsrcfork/compress/dcmp2.py'\nparams:\n  - id: len_decompressed\n    type: u4\n    doc: |\n      The length of the decompressed data in bytes,\n      from the compressed resource header.\n  - id: header_parameters_with_io\n    type: bytes_with_io\n    doc: |\n      The unparsed decompressor-specific parameters,\n      from the compressed resource header.\nseq:\n  - id: custom_lookup_table\n    size: 2\n    repeat: expr\n    repeat-expr: header_parameters.num_custom_lookup_table_entries\n    if: header_parameters.flags.has_custom_lookup_table\n    doc: |\n      The custom lookup table to be used instead of the default lookup table.\n  - id: data\n    type:\n      switch-on: header_parameters.flags.tagged\n      cases:\n        true: tagged_data\n        # _ is equivalent to false here.\n        # This is a workaround for kaitai-io/kaitai_struct#208 to make the compiler understand that the switch only has two cases,\n        # so that it doesn't generate a third default case that maps to a byte array type.\n        _: untagged_data\n    # The data extends to one byte before EOS if the decompressed length is odd,\n    # and otherwise extends completely to EOS.\n    size: |\n      _io.size - _io.pos - (is_len_decompressed_odd ? 1 : 0)\n    doc: |\n      The compressed data.\n      The structure of the data varies depending on whether the \"tagged\" or \"untagged\" variant of the compression format is used.\n  - id: last_byte\n    size: 1\n    if: is_len_decompressed_odd\n    doc: |\n      The last byte of the decompressed data,\n      stored literally.\n      Only present if the decompressed data has an odd length.\n\n      This special case is necessary because the compressed data is otherwise always stored in two-byte groups,\n      either literally or as table references,\n      so otherwise there would be no way to compress odd-length resources using this format.\ninstances:\n  header_parameters:\n    io: header_parameters_with_io._io\n    pos: 0\n    type: header_parameters\n    doc: |\n      The parsed decompressor-specific parameters from the compressed resource header.\n  is_len_decompressed_odd:\n    value: len_decompressed % 2 != 0\n    doc: |\n      Whether the length of the decompressed data is odd.\n      This affects the meaning of the last byte of the compressed data.\n  default_lookup_table:\n    value: |\n      [\n        [0x00, 0x00], [0x00, 0x08], [0x4e, 0xba], [0x20, 0x6e],\n        [0x4e, 0x75], [0x00, 0x0c], [0x00, 0x04], [0x70, 0x00],\n        [0x00, 0x10], [0x00, 0x02], [0x48, 0x6e], [0xff, 0xfc],\n        [0x60, 0x00], [0x00, 0x01], [0x48, 0xe7], [0x2f, 0x2e],\n        [0x4e, 0x56], [0x00, 0x06], [0x4e, 0x5e], [0x2f, 0x00],\n        [0x61, 0x00], [0xff, 0xf8], [0x2f, 0x0b], [0xff, 0xff],\n        [0x00, 0x14], [0x00, 0x0a], [0x00, 0x18], [0x20, 0x5f],\n        [0x00, 0x0e], [0x20, 0x50], [0x3f, 0x3c], [0xff, 0xf4],\n        [0x4c, 0xee], [0x30, 0x2e], [0x67, 0x00], [0x4c, 0xdf],\n        [0x26, 0x6e], [0x00, 0x12], [0x00, 0x1c], [0x42, 0x67],\n        [0xff, 0xf0], [0x30, 0x3c], [0x2f, 0x0c], [0x00, 0x03],\n        [0x4e, 0xd0], [0x00, 0x20], [0x70, 0x01], [0x00, 0x16],\n        [0x2d, 0x40], [0x48, 0xc0], [0x20, 0x78], [0x72, 0x00],\n        [0x58, 0x8f], [0x66, 0x00], [0x4f, 0xef], [0x42, 0xa7],\n        [0x67, 0x06], [0xff, 0xfa], [0x55, 0x8f], [0x28, 0x6e],\n        [0x3f, 0x00], [0xff, 0xfe], [0x2f, 0x3c], [0x67, 0x04],\n        [0x59, 0x8f], [0x20, 0x6b], [0x00, 0x24], [0x20, 0x1f],\n        [0x41, 0xfa], [0x81, 0xe1], [0x66, 0x04], [0x67, 0x08],\n        [0x00, 0x1a], [0x4e, 0xb9], [0x50, 0x8f], [0x20, 0x2e],\n        [0x00, 0x07], [0x4e, 0xb0], [0xff, 0xf2], [0x3d, 0x40],\n        [0x00, 0x1e], [0x20, 0x68], [0x66, 0x06], [0xff, 0xf6],\n        [0x4e, 0xf9], [0x08, 0x00], [0x0c, 0x40], [0x3d, 0x7c],\n        [0xff, 0xec], [0x00, 0x05], [0x20, 0x3c], [0xff, 0xe8],\n        [0xde, 0xfc], [0x4a, 0x2e], [0x00, 0x30], [0x00, 0x28],\n        [0x2f, 0x08], [0x20, 0x0b], [0x60, 0x02], [0x42, 0x6e],\n        [0x2d, 0x48], [0x20, 0x53], [0x20, 0x40], [0x18, 0x00],\n        [0x60, 0x04], [0x41, 0xee], [0x2f, 0x28], [0x2f, 0x01],\n        [0x67, 0x0a], [0x48, 0x40], [0x20, 0x07], [0x66, 0x08],\n        [0x01, 0x18], [0x2f, 0x07], [0x30, 0x28], [0x3f, 0x2e],\n        [0x30, 0x2b], [0x22, 0x6e], [0x2f, 0x2b], [0x00, 0x2c],\n        [0x67, 0x0c], [0x22, 0x5f], [0x60, 0x06], [0x00, 0xff],\n        [0x30, 0x07], [0xff, 0xee], [0x53, 0x40], [0x00, 0x40],\n        [0xff, 0xe4], [0x4a, 0x40], [0x66, 0x0a], [0x00, 0x0f],\n        [0x4e, 0xad], [0x70, 0xff], [0x22, 0xd8], [0x48, 0x6b],\n        [0x00, 0x22], [0x20, 0x4b], [0x67, 0x0e], [0x4a, 0xae],\n        [0x4e, 0x90], [0xff, 0xe0], [0xff, 0xc0], [0x00, 0x2a],\n        [0x27, 0x40], [0x67, 0x02], [0x51, 0xc8], [0x02, 0xb6],\n        [0x48, 0x7a], [0x22, 0x78], [0xb0, 0x6e], [0xff, 0xe6],\n        [0x00, 0x09], [0x32, 0x2e], [0x3e, 0x00], [0x48, 0x41],\n        [0xff, 0xea], [0x43, 0xee], [0x4e, 0x71], [0x74, 0x00],\n        [0x2f, 0x2c], [0x20, 0x6c], [0x00, 0x3c], [0x00, 0x26],\n        [0x00, 0x50], [0x18, 0x80], [0x30, 0x1f], [0x22, 0x00],\n        [0x66, 0x0c], [0xff, 0xda], [0x00, 0x38], [0x66, 0x02],\n        [0x30, 0x2c], [0x20, 0x0c], [0x2d, 0x6e], [0x42, 0x40],\n        [0xff, 0xe2], [0xa9, 0xf0], [0xff, 0x00], [0x37, 0x7c],\n        [0xe5, 0x80], [0xff, 0xdc], [0x48, 0x68], [0x59, 0x4f],\n        [0x00, 0x34], [0x3e, 0x1f], [0x60, 0x08], [0x2f, 0x06],\n        [0xff, 0xde], [0x60, 0x0a], [0x70, 0x02], [0x00, 0x32],\n        [0xff, 0xcc], [0x00, 0x80], [0x22, 0x51], [0x10, 0x1f],\n        [0x31, 0x7c], [0xa0, 0x29], [0xff, 0xd8], [0x52, 0x40],\n        [0x01, 0x00], [0x67, 0x10], [0xa0, 0x23], [0xff, 0xce],\n        [0xff, 0xd4], [0x20, 0x06], [0x48, 0x78], [0x00, 0x2e],\n        [0x50, 0x4f], [0x43, 0xfa], [0x67, 0x12], [0x76, 0x00],\n        [0x41, 0xe8], [0x4a, 0x6e], [0x20, 0xd9], [0x00, 0x5a],\n        [0x7f, 0xff], [0x51, 0xca], [0x00, 0x5c], [0x2e, 0x00],\n        [0x02, 0x40], [0x48, 0xc7], [0x67, 0x14], [0x0c, 0x80],\n        [0x2e, 0x9f], [0xff, 0xd6], [0x80, 0x00], [0x10, 0x00],\n        [0x48, 0x42], [0x4a, 0x6b], [0xff, 0xd2], [0x00, 0x48],\n        [0x4a, 0x47], [0x4e, 0xd1], [0x20, 0x6f], [0x00, 0x41],\n        [0x60, 0x0c], [0x2a, 0x78], [0x42, 0x2e], [0x32, 0x00],\n        [0x65, 0x74], [0x67, 0x16], [0x00, 0x44], [0x48, 0x6d],\n        [0x20, 0x08], [0x48, 0x6c], [0x0b, 0x7c], [0x26, 0x40],\n        [0x04, 0x00], [0x00, 0x68], [0x20, 0x6d], [0x00, 0x0d],\n        [0x2a, 0x40], [0x00, 0x0b], [0x00, 0x3e], [0x02, 0x20],\n      ]\n    doc: |\n      The default lookup table,\n      which is used if no custom lookup table is included with the compressed data.\n  lookup_table:\n    value: |\n      header_parameters.flags.has_custom_lookup_table\n      ? custom_lookup_table\n      : default_lookup_table\n    doc: |\n      The lookup table to be used for this compressed data.\ntypes:\n  header_parameters:\n    doc: |\n      Decompressor-specific parameters for this compression format,\n      as stored in the compressed resource header.\n    seq:\n      - id: unknown\n        type: u2\n        doc: |\n          The meaning of this field is unknown.\n          It does not appear to have any effect on the format of the compressed data or the decompression process.\n\n          The value of this field is usually zero and otherwise a small integer (< 10).\n          For `'lpch'` resources,\n          the value is always nonzero,\n          and sometimes larger than usual.\n      - id: num_custom_lookup_table_entries_m1\n        type: u1\n        doc: |\n          The number of entries in the custom lookup table,\n          minus one.\n\n          If the default lookup table is used rather than a custom one,\n          this value is zero.\n      - id: flags\n        type: flags\n        doc: |\n          Various flags that affect the format of the compressed data and the decompression process.\n    instances:\n      num_custom_lookup_table_entries:\n        value: num_custom_lookup_table_entries_m1 + 1\n        if: flags.has_custom_lookup_table\n        doc: |\n          The number of entries in the custom lookup table.\n          Only used if a custom lookup table is present.\n    types:\n      flags:\n        doc: |\n          Flags for the decompressor,\n          as stored in the decompressor-specific parameters.\n        seq:\n          - id: reserved\n            type: b6\n            doc: |\n              These flags have no known usage or meaning and should always be zero.\n          - id: tagged\n            type: b1\n            doc: |\n              Whether the \"tagged\" variant of this compression format should be used,\n              rather than the default \"untagged\" variant.\n          - id: has_custom_lookup_table\n            type: b1\n            doc: |\n              Whether a custom lookup table is included before the compressed data,\n              which should be used instead of the default hardcoded lookup table.\n        instances:\n          as_int:\n            pos: 0\n            type: u1\n            doc: |\n              The flags as a packed integer,\n              as they are stored in the data.\n  untagged_data:\n    doc: |\n      Compressed data in the \"untagged\" variant of the format.\n    seq:\n      - id: table_references\n        type: u1\n        repeat: eos\n        doc: |\n          References into the lookup table.\n          Each reference is an integer that is expanded to two bytes by looking it up in the table.\n  tagged_data:\n    doc: |\n      Compressed data in the \"tagged\" variant of the format.\n    seq:\n      - id: chunks\n        type: chunk\n        repeat: eos\n        doc: |\n          The tagged chunks that make up the compressed data.\n    types:\n      chunk:\n        doc: |\n          A single tagged chunk of compressed data.\n\n          Each chunk expands to 16 bytes of decompressed data.\n          In compressed form,\n          the chunks have a variable length\n          (between 9 and 17 bytes)\n          depending on the value of the tag byte.\n        seq:\n          - id: tag\n            type: b1\n            repeat: expr\n            repeat-expr: 8\n            doc: |\n              The bits of the tag byte control the format and meaning of the 8 compressed data units that follow the tag byte.\n          - id: units\n            type:\n              switch-on: tag[_index]\n              cases:\n                true: u1\n                # If false, the type is unset, i. e. a byte array.\n            # This size attribute is necessary when the tag bit is false,\n            # to set the size of the byte array to 2.\n            # When the tag bit is true,\n            # the size is implicitly set by the u1 type,\n            # so this attribute is redundant.\n            # However there is no way to set the size attribute only conditionally,\n            # so we need to include a value in all cases,\n            # even when the tag bit is true and an explicit size is not normally necessary.\n            size: |\n              tag[_index] ? 1 : 2\n            repeat: until\n            repeat-until: _index >= 7 or _io.eof\n            doc: |\n              The compressed data units in this chunk.\n\n              The format and meaning of each unit is controlled by the bit in the tag byte with the same index.\n              If the bit is 0 (false),\n              the unit is a pair of bytes,\n              which are literally copied to the decompressed data.\n              If the bit is 1 (true),\n              the unit is a reference into the lookup table,\n              an integer which is expanded to two bytes by looking it up in the table.\n"
  },
  {
    "id": "ksy_dcmp_variable_length_integer",
    "name": "Variable-length integer used in Apple `'dcmp' (0)` and `'dcmp' (1)` compressed resource formats",
    "category": "macOS",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "Variable-length integer used in Apple `'dcmp' (0)` and `'dcmp' (1)` compressed resource formats",
      "originalCategory": "macos",
      "filePath": "macos/resource_compression/dcmp_variable_length_integer.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: dcmp_variable_length_integer\n  title: Variable-length integer used in Apple `'dcmp' (0)` and `'dcmp' (1)` compressed resource formats\n  application: Mac OS\n  license: MIT\n  ks-version: \"0.8\"\n  endian: be\ndoc: |\n  A variable-length integer,\n  in the format used by the 0xfe chunks in the `'dcmp' (0)` and `'dcmp' (1)` resource compression formats.\n  See the dcmp_0 and dcmp_1 specs for more information about these compression formats.\n\n  This variable-length integer format can store an integer `x` in any of the following ways:\n\n  * In a single byte,\n    if `0 <= x <= 0x7f`\n    (7-bit unsigned integer)\n  * In 2 bytes,\n    if `-0x4000 <= x <= 0x3eff`\n    (15-bit signed integer with the highest `0x100` values unavailable)\n  * In 5 bytes, if `-0x80000000 <= x <= 0x7fffffff`\n    (32-bit signed integer)\n\n  In practice,\n  values are always stored in the smallest possible format,\n  but technically any of the larger formats could be used as well.\ndoc-ref: 'https://github.com/dgelessus/python-rsrcfork/blob/f891a6e/src/rsrcfork/compress/common.py'\nseq:\n  - id: first\n    type: u1\n    doc: |\n      The first byte of the variable-length integer.\n      This determines which storage format is used.\n\n      * For the 1-byte format,\n        this encodes the entire value of the value.\n      * For the 2-byte format,\n        this encodes the high 7 bits of the value,\n        minus `0xc0`.\n        The highest bit of the value,\n        i. e. the second-highest bit of this field,\n        is the sign bit.\n      * For the 5-byte format,\n        this is always `0xff`.\n  - id: more\n    type:\n      switch-on: first\n      cases:\n        0xff: s4\n        _: u1\n    if: first >= 0x80\n    doc: |\n      The remaining bytes of the variable-length integer.\n\n      * For the 1-byte format,\n        this is not present.\n      * For the 2-byte format,\n        this encodes the low 8 bits of the value.\n      * For the 5-byte format,\n        this encodes the entire value.\ninstances:\n  value:\n    value: |\n      first == 0xff ? more\n      : first >= 0x80 ? (first << 8 | more) - 0xc000\n      : first\n    doc: |\n      The decoded value of the variable-length integer.\n"
  },
  {
    "id": "ksy_resource_fork",
    "name": "Macintosh resource fork data",
    "category": "macOS",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [
        "rsrc",
        "dfont"
      ],
      "description": "Macintosh resource fork data",
      "originalCategory": "macos",
      "filePath": "macos/resource_fork.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: resource_fork\n  title: Macintosh resource fork data\n  application: Mac OS\n  file-extension:\n    - rsrc # Resource fork data stored in a separate file (as a data fork)\n    - dfont # Datafork font suitcase (a special case of the above, used by certain Mac fonts)\n  xref:\n    justsolve: Resource_Fork\n    wikidata: Q3933446\n  license: MIT\n  ks-version: \"0.9\"\n  imports:\n    - /common/bytes_with_io\n  endian: be\ndoc: |\n  The data format of Macintosh resource forks,\n  used on Classic Mac OS and Mac OS X/macOS to store additional structured data along with a file's main data (the data fork).\n  The kinds of data stored in resource forks include:\n\n  * Document resources:\n    images, sounds, etc. used by a document\n  * Application resources:\n    graphics, GUI layouts, localizable strings,\n    and even code used by an application, a library, or system files\n  * Common metadata:\n    custom icons and version metadata that could be displayed by the Finder\n  * Application-specific metadata:\n    because resource forks follow a common format,\n    other applications can store new metadata in them,\n    even if the original application does not recognize or understand it\n\n  Macintosh file systems (MFS, HFS, HFS+, APFS) support resource forks natively,\n  which allows storing resources along with any file.\n  Non-Macintosh file systems and protocols have little or no support for resource forks,\n  so the resource fork data must be stored in some other way when using such file systems or protocols.\n  Various file formats and tools exist for this purpose,\n  such as BinHex, MacBinary, AppleSingle, AppleDouble, or QuickTime RezWack.\n  In some cases,\n  resource forks are stored as plain data in separate files with a .rsrc extension,\n  even on Mac systems that natively support resource forks.\n\n  On modern Mac OS X/macOS systems,\n  resource forks are used far less commonly than on classic Mac OS systems,\n  because of compatibility issues with other systems and historical limitations in the format.\n  Modern macOS APIs and libraries do not use resource forks,\n  and the legacy Carbon API that still used them has been deprecated since OS X 10.8.\n  Despite this,\n  even current macOS systems still use resource forks for certain purposes,\n  such as custom file icons.\ndoc-ref:\n  - 'https://developer.apple.com/library/archive/documentation/mac/pdf/MoreMacintoshToolbox.pdf#page=151 Inside Macintosh, More Macintosh Toolbox, Resource Manager, Resource Manager Reference, Resource File Format'\n  - 'https://www.pagetable.com/?p=50 Inside Macintosh, Volume I, The Resource Manager, Format of a Resource File'\n  - 'https://github.com/kreativekorp/ksfl/wiki/Macintosh-Resource-File-Format'\n  - 'https://github.com/dgelessus/mac_file_format_docs/blob/master/README.md#resource-forks'\nseq:\n  - id: header\n    type: file_header\n    doc: The resource file's header information.\n  - id: system_data\n    size: 112\n    doc: |\n      System-reserved data area.\n      This field can generally be ignored when reading and writing.\n\n      This field is used by the Classic Mac OS Finder as temporary storage space.\n      It usually contains parts of the file metadata (name, type/creator code, etc.).\n      Any existing data in this field is ignored and overwritten.\n\n      In resource files written by Mac OS X,\n      this field is set to all zero bytes.\n  - id: application_data\n    size: 128\n    doc: |\n      Application-specific data area.\n      This field can generally be ignored when reading and writing.\n\n      According to early revisions of Inside Macintosh,\n      this field is \"available for application data\".\n      In practice, it is almost never used for this purpose,\n      and usually contains only junk data.\n\n      In resource files written by Mac OS X,\n      this field is set to all zero bytes.\ninstances:\n  data_blocks_with_io:\n    pos: header.ofs_data_blocks\n    size: header.len_data_blocks\n    type: bytes_with_io\n    doc: |\n      Use `data_blocks` instead,\n      unless you need access to this instance's `_io`.\n  data_blocks:\n    value: data_blocks_with_io.data\n    doc: |\n      Storage area for the data blocks of all resources.\n\n      These data blocks are not required to appear in any particular order,\n      and there may be unused space between and around them.\n\n      In practice,\n      the data blocks in newly created resource files are usually contiguous.\n      When existing resources are shortened,\n      the Mac OS resource manager leaves unused space where the now removed resource data was,\n      as this is quicker than moving the following resource data into the newly freed space.\n      Such unused space may be cleaned up later when the resource manager \"compacts\" the resource file,\n      which happens when resources are removed entirely,\n      or when resources are added or grown so that more space is needed in the data area.\n  resource_map:\n    pos: header.ofs_resource_map\n    size: header.len_resource_map\n    type: resource_map\n    doc: The resource file's resource map.\ntypes:\n  file_header:\n    doc: |\n      Resource file header,\n      containing the offsets and lengths of the resource data area and resource map.\n    seq:\n      - id: ofs_data_blocks\n        type: u4\n        doc: |\n          Offset of the resource data area,\n          from the start of the resource file.\n\n          In practice,\n          this should always be `256`,\n          i. e. the resource data area should directly follow the application-specific data area.\n      - id: ofs_resource_map\n        type: u4\n        doc: |\n          Offset of the resource map,\n          from the start of the resource file.\n\n          In practice,\n          this should always be `ofs_data_blocks + len_data_blocks`,\n          i. e. the resource map should directly follow the resource data area.\n      - id: len_data_blocks\n        type: u4\n        doc: |\n          Length of the resource data area.\n      - id: len_resource_map\n        type: u4\n        doc: |\n          Length of the resource map.\n\n          In practice,\n          this should always be `_root._io.size - ofs_resource_map`,\n          i. e. the resource map should extend to the end of the resource file.\n  data_block:\n    doc: |\n      A resource data block,\n      as stored in the resource data area.\n\n      Each data block stores the data contained in a resource,\n      along with its length.\n    seq:\n      - id: len_data\n        type: u4\n        doc: |\n          The length of the resource data stored in this block.\n      - id: data\n        size: len_data\n        doc: |\n          The data stored in this block.\n  resource_map:\n    doc: |\n      Resource map,\n      containing information about the resources in the file and where they are located in the data area.\n    seq:\n      - id: reserved_file_header_copy\n        type: file_header\n        doc: Reserved space for a copy of the resource file header.\n      - id: reserved_next_resource_map_handle\n        type: u4\n        doc: Reserved space for a handle to the next loaded resource map in memory.\n      - id: reserved_file_reference_number\n        type: u2\n        doc: Reserved space for the resource file's file reference number.\n      - id: file_attributes\n        type: file_attributes\n        size: 2\n        doc: The resource file's attributes.\n      - id: ofs_type_list\n        type: u2\n        doc: |\n          Offset of the resource type list,\n          from the start of the resource map.\n\n          In practice,\n          this should always be `sizeof<resource_map>`,\n          i. e. the resource type list should directly follow the resource map.\n      - id: ofs_names\n        type: u2\n        doc: |\n          Offset of the resource name area,\n          from the start of the resource map.\n    instances:\n      type_list_and_reference_lists:\n        pos: ofs_type_list\n        size: ofs_names - ofs_type_list\n        type: type_list_and_reference_lists\n        doc: The resource map's resource type list, followed by the resource reference list area.\n      names_with_io:\n        pos: ofs_names\n        size-eos: true\n        type: bytes_with_io\n        doc: |\n          Use `names` instead,\n          unless you need access to this instance's `_io`.\n      names:\n        value: names_with_io.data\n        doc: Storage area for the names of all resources.\n    types:\n      file_attributes:\n        doc: |\n          A resource file's attributes,\n          as stored in the resource map.\n\n          These attributes are sometimes also referred to as resource map attributes,\n          because of where they are stored in the file.\n        seq:\n          - id: resources_locked\n            type: b1\n            doc: |\n              TODO What does this attribute actually do,\n              and how is it different from `read_only`?\n\n              This attribute is undocumented and not defined in <CarbonCore/Resources.h>,\n              but ResEdit has a checkbox called \"Resources Locked\" for this attribute.\n          - id: reserved0\n            type: b6\n            doc: |\n              These attributes have no known usage or meaning and should always be zero.\n          - id: printer_driver_multifinder_compatible\n            type: b1\n            doc: |\n              Indicates that this printer driver is compatible with MultiFinder,\n              i. e. can be used simultaneously by multiple applications.\n              This attribute is only meant to be set on printer driver resource forks.\n\n              This attribute is not documented in Inside Macintosh and is not defined in <CarbonCore/Resources.h>.\n              It is documented in technote PR510,\n              and ResEdit has a checkbox called \"Printer Driver MultiFinder Compatible\" for this attribute.\n            doc-ref: https://developer.apple.com/library/archive/technotes/pr/pr_510.html Apple Technical Note PR510 - Printer Driver Q&As, section '\"Printer driver is MultiFinder compatible\" bit'\n          - id: no_write_changes\n            -orig-id: mapReadOnly\n            type: b1\n            doc: |\n              Indicates that the Resource Manager should not write any changes from memory into the resource file.\n              Any modification operations requested by the application will return successfully,\n              but will not actually update the resource file.\n\n              TODO Is this attribute supposed to be set on disk or only in memory?\n          - id: needs_compact\n            -orig-id: mapCompact\n            type: b1\n            doc: |\n              Indicates that the resource file should be compacted the next time it is written by the Resource Manager.\n              This attribute is only meant to be set in memory;\n              it is cleared when the resource file is written to disk.\n\n              This attribute is mainly used internally by the Resource Manager,\n              but may also be set manually by the application.\n          - id: map_needs_write\n            -orig-id: mapChanged\n            type: b1\n            doc: |\n              Indicates that the resource map has been changed in memory and should be written to the resource file on the next update.\n              This attribute is only meant to be set in memory;\n              it is cleared when the resource file is written to disk.\n\n              This attribute is mainly used internally by the Resource Manager,\n              but may also be set manually by the application.\n          - id: reserved1\n            type: b5\n            doc: |\n              These attributes have no known usage or meaning and should always be zero.\n        instances:\n          as_int:\n            pos: 0\n            type: u2\n            doc: |\n              The attributes as a packed integer,\n              as they are stored in the file.\n      type_list_and_reference_lists:\n        doc: |\n          Resource type list and storage area for resource reference lists in the resource map.\n\n          The two parts are combined into a single type here for technical reasons:\n          the start of the resource reference list area is not stored explicitly in the file,\n          instead it always starts directly after the resource type list.\n          The simplest way to implement this is by placing both types into a single `seq`.\n        seq:\n          - id: type_list\n            type: type_list\n            doc: The resource map's resource type list.\n          - id: reference_lists\n            size-eos: true\n            doc: |\n              Storage area for the resource map's resource reference lists.\n\n              According to Inside Macintosh,\n              the reference lists are stored contiguously,\n              in the same order as their corresponding resource type list entries.\n        types:\n          type_list:\n            doc: Resource type list in the resource map.\n            seq:\n              - id: num_types_m1\n                type: u2\n                doc: |\n                  The number of resource types in this list,\n                  minus one.\n\n                  If the resource list is empty,\n                  the value of this field is `0xffff`,\n                  i. e. `-1` truncated to a 16-bit unsigned integer.\n              - id: entries\n                type: type_list_entry\n                repeat: expr\n                repeat-expr: num_types\n                doc: Entries in the resource type list.\n            instances:\n              num_types:\n                # The modulo 0x10000 simulates 16-bit unsigned integer wraparound,\n                # so that empty lists are handled correctly (see doc for num_types_m1).\n                value: (num_types_m1 + 1) % 0x10000\n                doc: The number of resource types in this list.\n            types:\n              type_list_entry:\n                doc: |\n                  A single entry in the resource type list.\n\n                  Each entry corresponds to exactly one resource reference list.\n                seq:\n                  - id: type\n                    size: 4\n                    doc: The four-character type code of the resources in the reference list.\n                  - id: num_references_m1\n                    type: u2\n                    doc: |\n                      The number of resources in the reference list for this type,\n                      minus one.\n\n                      Empty reference lists should never exist.\n                  - id: ofs_reference_list\n                    type: u2\n                    doc: |\n                      Offset of the resource reference list for this resource type,\n                      from the start of the resource type list.\n\n                      Although the offset is relative to the start of the type list,\n                      it should never point into the type list itself,\n                      but into the reference list storage area that directly follows it.\n                      That is,\n                      it should always be at least `_parent._sizeof`.\n                instances:\n                  num_references:\n                    # Reference lists should never be empty,\n                    # but just in case simulate the wraparound behavior here as well.\n                    value: (num_references_m1 + 1) % 0x10000\n                    doc: The number of resources in the reference list for this type.\n                  reference_list:\n                    io: _parent._parent._io\n                    pos: ofs_reference_list\n                    type: reference_list(num_references)\n                    doc: |\n                      The resource reference list for this resource type.\n          reference_list:\n            doc: |\n              A resource reference list,\n              as stored in the reference list area.\n\n              Each reference list has exactly one matching entry in the resource type list,\n              and describes all resources of a single type in the file.\n            params:\n              - id: num_references\n                type: u2\n                doc: |\n                  The number of references in this resource reference list.\n\n                  This information needs to be passed in as a parameter,\n                  because it is stored in the reference list's type list entry,\n                  and not in the reference list itself.\n            seq:\n              - id: references\n                type: reference\n                repeat: expr\n                repeat-expr: num_references\n                doc: The resource references in this reference list.\n            types:\n              reference:\n                doc: A single resource reference in a resource reference list.\n                seq:\n                  - id: id\n                    type: s2\n                    doc: ID of the resource described by this reference.\n                  - id: ofs_name\n                    type: u2\n                    doc: |\n                      Offset of the name for the resource described by this reference,\n                      from the start of the resource name area.\n\n                      If the resource has no name,\n                      the value of this field is `0xffff`\n                      i. e. `-1` truncated to a 16-bit unsigned integer.\n                  - id: attributes\n                    type: attributes\n                    size: 1\n                    doc: Attributes of the resource described by this reference.\n                  - id: ofs_data_block\n                    type: b24 # 3-byte unsigned integer, packed together with the previous 1-byte field.\n                    doc: |\n                      Offset of the data block for the resource described by this reference,\n                      from the start of the resource data area.\n                  - id: reserved_handle\n                    type: u4\n                    doc: Reserved space for the resource's handle in memory.\n                instances:\n                  name:\n                    io: _root.resource_map.names_with_io._io\n                    pos: ofs_name\n                    type: name\n                    if: ofs_name != 0xffff\n                    doc: |\n                      The name (if any) of the resource described by this reference.\n                  data_block:\n                    io: _root.data_blocks_with_io._io\n                    pos: ofs_data_block\n                    type: data_block\n                    doc: |\n                      The data block containing the data for the resource described by this reference.\n                types:\n                  attributes:\n                    doc: |\n                      A resource's attributes,\n                      as stored in a resource reference.\n                    seq:\n                      - id: system_reference\n                        -orig-id: resSysRef\n                        type: b1\n                        doc: |\n                          Indicates that this resource reference is a system reference rather than a regular local reference.\n                          This attribute is nearly undocumented.\n                          For all practical purposes,\n                          it should be considered reserved and should always be zero.\n\n                          This attribute was last documented in the Promotional Edition of Inside Macintosh,\n                          in the Resource Manager chapter,\n                          on pages 37-41,\n                          in a \"System References\" section that calls itself \"of historical interest only\".\n                          The final versions of Inside Macintosh only mention this attribute as \"reserved for use by the Resource Manager\".\n                          <CarbonCore/Resources.h> contains a `resSysRefBit` constant,\n                          but no corresponding `resSysRef` constant like for all other resource attributes.\n\n                          According to the Inside Macintosh Promotional Edition,\n                          a system reference was effectively an alias pointing to a resource stored in the system file,\n                          possibly with a different ID and name (but not type) than the system reference.\n                          If this attribute is set,\n                          `ofs_data_block` is ignored and should be zero,\n                          and `reserved_handle` contains\n                          (in its high and low two bytes, respectively)\n                          the ID and name offset of the real system resource that this system reference points to.\n\n                          TODO Do any publicly available Mac OS versions support system references,\n                          and do any real files/applications use them?\n                          So far the answer seems to be no,\n                          but I would like to be proven wrong!\n                      - id: load_into_system_heap\n                        -orig-id: resSysHeap\n                        type: b1\n                        doc: |\n                          Indicates that this resource should be loaded into the system heap if possible,\n                          rather than the application heap.\n\n                          This attribute is only meant to be used by Mac OS itself,\n                          for System and Finder resources,\n                          and not by normal applications.\n\n                          This attribute may be set both in memory and on disk,\n                          but it only has any meaning while the resource file is loaded into memory.\n                      - id: purgeable\n                        -orig-id: resPurgeable\n                        type: b1\n                        doc: |\n                          Indicates that this resource's data should be purgeable by the Mac OS Memory Manager.\n                          This allows the resource data to be purged from memory if space is needed on the heap.\n                          Purged resources can later be reloaded from disk if their data is needed again.\n\n                          If the `locked` attribute is set,\n                          this attribute has no effect\n                          (i. e. locked resources are never purgeable).\n\n                          This attribute may be set both in memory and on disk,\n                          but it only has any meaning while the resource file is loaded into memory.\n                      - id: locked\n                        -orig-id: resLocked\n                        type: b1\n                        doc: |\n                          Indicates that this resource's data should be locked to the Mac OS Memory Manager.\n                          This prevents the resource data from being moved when the heap is compacted.\n\n                          This attribute may be set both in memory and on disk,\n                          but it only has any meaning while the resource file is loaded into memory.\n                      - id: protected\n                        -orig-id: resProtected\n                        type: b1\n                        doc: |\n                          Indicates that this resource should be protected (i. e. unmodifiable) in memory.\n                          This prevents the application from using the Resource Manager to change the resource's data or metadata,\n                          or delete it.\n                          The only exception are the resource's attributes,\n                          which can always be changed,\n                          even for protected resources.\n                          This allows protected resources to be unprotected again by the application.\n\n                          This attribute may be set both in memory and on disk,\n                          but it only has any meaning while the resource file is loaded into memory.\n                      - id: preload\n                        -orig-id: resPreload\n                        type: b1\n                        doc: |\n                          Indicates that this resource's data should be immediately loaded into memory when the resource file is opened.\n\n                          This attribute may be set both in memory and on disk,\n                          but it only has any meaning when the resource file is first opened.\n                      - id: needs_write\n                        -orig-id: resChanged\n                        type: b1\n                        doc: |\n                          Indicates that this resource's data has been changed in memory and should be written to the resource file on the next update.\n                          This attribute is only meant to be set in memory;\n                          it is cleared when the resource file is written to disk.\n\n                          This attribute is used internally by the Resource Manager and should not be set manually by the application.\n                      - id: compressed\n                        -orig-id: resCompressed\n                        type: b1\n                        doc: |\n                          Indicates that this resource's data is compressed.\n                          Compressed resource data is decompressed transparently by the Resource Manager when reading.\n\n                          For a detailed description of the structure of compressed resources as they are stored in the file,\n                          see the compressed_resource.ksy spec.\n                    instances:\n                      as_int:\n                        pos: 0\n                        type: u1\n                        doc: |\n                          The attributes as a packed integer,\n                          as they are stored in the file.\n      name:\n        doc: |\n          A resource name,\n          as stored in the resource name storage area in the resource map.\n\n          The resource names are not required to appear in any particular order.\n          There may be unused space between and around resource names,\n          but in practice they are often contiguous.\n        seq:\n          - id: len_value\n            type: u1\n            doc: |\n              The length of the resource name, in bytes.\n          - id: value\n            size: len_value\n            doc: |\n              The resource name.\n\n              This field is exposed as a byte array,\n              because there is no universal encoding for resource names.\n              Most Classic Mac software does not deal with encodings explicitly and instead assumes that all strings,\n              including resource names,\n              use the system encoding,\n              which varies depending on the system language.\n              This means that resource names can use different encodings depending on what system language they were created with.\n\n              Many resource names are plain ASCII,\n              meaning that the encoding often does not matter\n              (because all Mac OS encodings are ASCII-compatible).\n              For non-ASCII resource names,\n              the most common encoding is perhaps MacRoman\n              (used for English and other Western languages),\n              but other encodings are also sometimes used,\n              especially for software in non-Western languages.\n\n              There is no requirement that all names in a single resource file use the same encoding.\n              For example,\n              localized software may have some (but not all) of its resource names translated.\n              For non-Western languages,\n              this can lead to some resource names using MacRoman,\n              and others using a different encoding.\n"
  }
];

export default {
  category: "macOS",
  formats: macosFormats
};
