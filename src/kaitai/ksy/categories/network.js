/**
 * Kaitai Formats - Network
 * 25 formats
 * Auto-generated: 2025-09-21T19:51:05.642Z
 */

export const networkFormats = [
  {
    "id": "ksy_bitcoin_transaction",
    "name": "Bitcoin Transaction",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "Bitcoin Transaction",
      "originalCategory": "network",
      "filePath": "network/bitcoin_transaction.ksy",
      "endian": "le"
    },
    "content": "meta:\n  id: bitcoin_transaction\n  title: Bitcoin Transaction\n  license: MIT\n  endian: le\ndoc-ref: |\n  https://bitcoin.org/en/developer-guide#transactions\n  https://en.bitcoin.it/wiki/Transaction\nseq:\n  - id: version\n    type: u4\n    doc: |\n      Version number.\n  - id: num_vins\n    type: u1\n    doc: |\n      Number of input transactions.\n  - id: vins\n    type: vin\n    repeat: expr\n    repeat-expr: num_vins\n    doc: |\n      Input transactions.\n      An input refers to an output from a previous transaction.\n  - id: num_vouts\n    type: u1\n    doc: |\n      Number of output transactions.\n  - id: vouts\n    type: vout\n    repeat: expr\n    repeat-expr: num_vouts\n    doc: |\n      Output transactions.\n  - id: locktime\n    type: u4\ntypes:\n  vin:\n    seq:\n      - id: txid\n        size: 32\n        doc: |\n          Previous transaction hash.\n      - id: output_id\n        type: u4\n        doc: |\n          ID indexing an ouput of the transaction refered by txid.\n          This output will be used as an input in the present transaction.\n      - id: len_script\n        type: u1\n        doc: |\n          ScriptSig's length.\n      - id: script_sig\n        size: len_script\n        type: script_signature\n        doc: |\n          ScriptSig.\n        doc-ref: |\n          https://en.bitcoin.it/wiki/Transaction#Input\n          https://en.bitcoin.it/wiki/Script\n      - id: end_of_vin\n        contents: [0xff, 0xff, 0xff, 0xff]\n        doc: |\n          Magic number indicating the end of the current input.\n    types:\n      script_signature:\n        seq:\n          - id: len_sig_stack\n            type: u1\n          - id: der_sig\n            type: der_signature\n            doc: |\n              DER-encoded ECDSA signature.\n            doc-ref: |\n              https://en.wikipedia.org/wiki/X.690#DER_encoding\n              https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm\n          - id: sig_type\n            type: u1\n            enum: sighash_type\n            doc: |\n              Type of signature.\n          - id: len_pubkey_stack\n            type: u1\n          - id: pubkey\n            type: public_key\n            doc: |\n              Public key (bitcoin address of the recipient).\n        types:\n          der_signature:\n            seq:\n              - id: sequence\n                contents: [0x30]\n              - id: len_sig\n                type: u1\n              - id: sep_1\n                contents: [0x02]\n              - id: len_sig_r\n                type: u1\n                doc: |\n                  'r' value's length.\n              - id: sig_r\n                size: len_sig_r\n                doc: |\n                  'r' value of the ECDSA signature.\n                doc-ref: 'https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm'\n              - id: sep_2\n                contents: [0x02]\n              - id: len_sig_s\n                type: u1\n                doc: |\n                  's' value's length.\n              - id: sig_s\n                size: len_sig_s\n                doc: |\n                  's' value of the ECDSA signature.\n                doc-ref: 'https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm'\n          public_key:\n            seq:\n              - id: type\n                type: u1\n              - id: x\n                size: 32\n                doc: |\n                  'x' coordinate of the public key on the elliptic curve.\n              - id: y\n                size: 32\n                doc: |\n                  'y' coordinate of the public key on the elliptic curve.\n        enums:\n          sighash_type:\n            1: sighash_all\n            2: sighash_none\n            3: sighash_single\n            80: sighash_anyonecanpay\n  vout:\n    seq:\n      - id: amount\n        type: u8\n        doc: |\n          Number of Satoshis to be transfered.\n      - id: len_script\n        type: u1\n        doc: |\n          ScriptPubKey's length.\n      - id: script_pub_key\n        size: len_script\n        doc: |\n          ScriptPubKey.\n        doc-ref: |\n          https://en.bitcoin.it/wiki/Transaction#Output\n          https://en.bitcoin.it/wiki/Script\n"
  },
  {
    "id": "ksy_dime_message",
    "name": "DIME (Direct Internet Message Encapsulation) Message",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [
        "dim",
        "dime"
      ],
      "description": "DIME (Direct Internet Message Encapsulation) Message",
      "originalCategory": "network",
      "filePath": "network/dime_message.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: dime_message\n  title: DIME (Direct Internet Message Encapsulation) Message\n  file-extension:\n    - dim\n    - dime\n  xref:\n    mime: application/dime\n    wikidata: Q1227457\n  license: CC0-1.0\n  bit-endian: be\n  endian: be\n  encoding: ASCII\ndoc: |\n  Direct Internet Message Encapsulation (DIME)\n  is an old Microsoft specification for sending and receiving\n  SOAP messages along with additional attachments,\n  like binary files, XML fragments, and even other\n  SOAP messages, using standard transport protocols like HTTP.\n\n  Sample file: `curl -LO\n  https://github.com/kaitai-io/kaitai_struct_formats/files/5894723/scanner_withoptions.dump.gz\n  && gunzip scanner_withoptions.dump.gz`\ndoc-ref:\n  - https://datatracker.ietf.org/doc/html/draft-nielsen-dime-02\n  - https://learn.microsoft.com/en-us/archive/msdn-magazine/2002/december/sending-files-attachments-and-soap-messages-via-dime\n  - http://imrannazar.com/Parsing-the-DIME-Message-Format\nseq:\n  - id: records\n    type: record\n    repeat: eos\ntypes:\n  padding:\n    doc: padding to the next 4-byte boundary\n    seq:\n      - id: boundary_padding\n        size: (- _io.pos) % 4\n  option_field:\n    doc: the option field of the record\n    seq:\n      - id: option_elements\n        type: option_element\n        repeat: eos\n  option_element:\n    doc: one element of the option field\n    seq:\n      - id: element_format\n        type: u2\n      - id: len_element\n        type: u2\n      - id: element_data\n        size: len_element\n  record:\n    doc: each individual fragment of the message\n    seq:\n      - id: version\n        doc: DIME format version (always 1)\n        type: b5\n      - id: is_first_record\n        doc: Set if this is the first record in the message\n        type: b1\n      - id: is_last_record\n        doc: Set if this is the last record in the message\n        type: b1\n      - id: is_chunk_record\n        doc: Set if the file contained in this record is chunked into multiple records\n        type: b1\n      - id: type_format\n        doc: Indicates the structure and format of the value of the TYPE field\n        enum: type_formats\n        type: b4\n      - id: reserved\n        doc: Reserved for future use\n        type: b4\n      - id: len_options\n        doc: Length of the Options field\n        type: u2\n      - id: len_id\n        doc: Length of the ID field\n        type: u2\n      - id: len_type\n        doc: Length of the Type field\n        type: u2\n      - id: len_data\n        doc: Length of the Data field\n        type: u4\n      - id: options\n        size: len_options\n        type: option_field\n      - id: options_padding\n        type: padding\n      - id: id\n        doc: Unique identifier of the file (set in the first record of file)\n        type: str\n        size: len_id\n      - id: id_padding\n        type: padding\n      - id: type\n        doc: Specified type in the format set with type_format\n        type: str\n        size: len_type\n      - id: type_padding\n        type: padding\n      - id: data\n        doc: The file data\n        size: len_data\n      - id: data_padding\n        type: padding\nenums:\n  type_formats:\n    0: unchanged\n    1: media_type\n    2: absolute_uri\n    3: unknown\n    4: none\n"
  },
  {
    "id": "ksy_dns_packet",
    "name": "DNS (Domain Name Service) packet",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "DNS (Domain Name Service) packet",
      "originalCategory": "network",
      "filePath": "network/dns_packet.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: dns_packet\n  title: DNS (Domain Name Service) packet\n  xref:\n    rfc: 1035\n    wikidata: Q8767\n  license: CC0-1.0\n  encoding: utf-8\n  endian: be\ndoc: |\n  (No support for Auth-Name + Add-Name for simplicity)\nseq:\n  - id: transaction_id\n    doc: \"ID to keep track of request/responces\"\n    type: u2\n  - id: flags\n    type: packet_flags\n  - id: qdcount\n    doc: \"How many questions are there\"\n    if: flags.is_opcode_valid\n    type: u2\n  - id: ancount\n    doc: \"Number of resource records answering the question\"\n    if: flags.is_opcode_valid\n    type: u2\n  - id: nscount\n    doc: \"Number of resource records pointing toward an authority\"\n    if: flags.is_opcode_valid\n    type: u2\n  - id: arcount\n    doc: \"Number of resource records holding additional information\"\n    if: flags.is_opcode_valid\n    type: u2\n  - id: queries\n    if: flags.is_opcode_valid\n    type: query\n    repeat: expr\n    repeat-expr: qdcount\n  - id: answers\n    if: flags.is_opcode_valid\n    type: answer\n    repeat: expr\n    repeat-expr: ancount\n  - id: authorities\n    if: flags.is_opcode_valid\n    type: answer\n    repeat: expr\n    repeat-expr: nscount\n  - id: additionals\n    if: flags.is_opcode_valid\n    type: answer\n    repeat: expr\n    repeat-expr: arcount\ntypes:\n  query:\n    seq:\n      - id: name\n        type: domain_name\n      - id: type\n        type: u2\n        enum: type_type\n      - id: query_class\n        type: u2\n        enum: class_type\n  answer:\n    seq:\n      - id: name\n        type: domain_name\n      - id: type\n        type: u2\n        enum: type_type\n      - id: answer_class\n        type: u2\n        enum: class_type\n      - id: ttl\n        doc: \"Time to live (in seconds)\"\n        type: s4\n      - id: rdlength\n        doc: \"Length in octets of the following payload\"\n        type: u2\n      - id: payload\n        size: rdlength\n        type:\n          switch-on: type\n          cases:\n            \"type_type::ptr\": domain_name\n            \"type_type::a\": address\n            \"type_type::aaaa\": address_v6\n            \"type_type::cname\": domain_name\n            \"type_type::soa\": authority_info\n            \"type_type::mx\": mx_info\n            \"type_type::ns\": domain_name\n            \"type_type::srv\": service\n            \"type_type::txt\": txt_body\n  domain_name:\n    seq:\n      - id: name\n        type: label\n        repeat: until\n        doc: \"Repeat until the length is 0 or it is a pointer (bit-hack to get around lack of OR operator)\"\n        repeat-until: \"_.length == 0 or _.length >= 192\"\n  label:\n    seq:\n      - id: length\n        doc: \"RFC1035 4.1.4: If the first two bits are raised it's a pointer-offset to a previously defined name\"\n        type: u1\n      - id: pointer\n        if: \"is_pointer\"\n        type: pointer_struct\n      - id: name\n        if: \"not is_pointer\"\n        doc: \"Otherwise its a string the length of the length value\"\n        type: str\n        size: length\n    instances:\n      is_pointer:\n        value: length >= 192\n  pointer_struct:\n    seq:\n      - id: value\n        doc: \"Read one byte, then offset to that position, read one domain-name and return\"\n        type: u1\n    instances:\n      contents:\n        io: _root._io\n        pos: value + ((_parent.length - 192) << 8)\n        type: domain_name\n  address:\n    seq:\n      - id: ip\n        size: 4\n  address_v6:\n    seq:\n      - id: ip_v6\n        size: 16\n  packet_flags:\n    seq:\n      - id: flag\n        type: u2\n    instances:\n      qr:\n        value: (flag & 0b1000_0000_0000_0000) >> 15\n      opcode:\n        value: (flag & 0b0111_1000_0000_0000) >> 11\n      aa:\n        value: (flag & 0b0000_0100_0000_0000) >> 10\n      tc:\n        value: (flag & 0b0000_0010_0000_0000) >> 9\n      rd:\n        value: (flag & 0b0000_0001_0000_0000) >> 8\n      ra:\n        value: (flag & 0b0000_0000_1000_0000) >> 7\n      z:\n        value: (flag & 0b0000_0000_0100_0000) >> 6\n      ad:\n        value: (flag & 0b0000_0000_0010_0000) >> 5\n      cd:\n        value: (flag & 0b0000_0000_0001_0000) >> 4\n      rcode:\n        value: (flag & 0b0000_0000_0000_1111) >> 0\n      is_opcode_valid:\n        value: opcode == 0 or opcode == 1 or opcode == 2\n  service:\n    seq:\n      - id: priority\n        type: u2\n      - id: weight\n        type: u2\n      - id: port\n        type: u2\n      - id: target\n        type: domain_name\n  txt:\n    seq:\n      - id: length\n        type: u1\n      - id: text\n        type: str\n        size: length\n  txt_body:\n    seq:\n      - id: data\n        type: txt\n        repeat: eos\n  authority_info:\n    seq:\n      - id: primary_ns\n        type: domain_name\n      - id: resoponsible_mailbox\n        type: domain_name\n      - id: serial\n        type: u4\n      - id: refresh_interval\n        type: u4\n      - id: retry_interval\n        type: u4\n      - id: expire_limit\n        type: u4\n      - id: min_ttl\n        type: u4\n  mx_info:\n    seq:\n      - id: preference\n        type: u2\n      - id: mx\n        type: domain_name\nenums:\n  class_type:\n    1: in_class\n    2: cs\n    3: ch\n    4: hs\n  type_type:\n    1: a\n    2: ns\n    3: md\n    4: mf\n    5: cname\n    6: soa\n    7: mb\n    8: mg\n    9: mr\n    10: \"null\"\n    11: wks\n    12: ptr\n    13: hinfo\n    14: minfo\n    15: mx\n    16: txt\n    28: aaaa\n    33: srv\n"
  },
  {
    "id": "ksy_ethernet_frame",
    "name": "Ethernet frame (layer 2, IEEE 802.3)",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "Ethernet frame (layer 2, IEEE 802.3)",
      "originalCategory": "network",
      "filePath": "network/ethernet_frame.ksy"
    },
    "content": "meta:\n  id: ethernet_frame\n  title: Ethernet frame (layer 2, IEEE 802.3)\n  xref:\n    ieee: 802.3\n    wikidata: Q11331406\n  license: CC0-1.0\n  ks-version: 0.8\n  imports:\n    - /network/ipv4_packet\n    - /network/ipv6_packet\ndoc: |\n  Ethernet frame is a OSI data link layer (layer 2) protocol data unit\n  for Ethernet networks. In practice, many other networks and/or\n  in-file dumps adopted the same format for encapsulation purposes.\ndoc-ref: https://ieeexplore.ieee.org/document/7428776\nseq:\n  - id: dst_mac\n    size: 6\n    doc: Destination MAC address\n  - id: src_mac\n    size: 6\n    doc: Source MAC address\n  - id: ether_type_1\n    type: u2be\n    enum: ether_type_enum\n    doc: Either ether type or TPID if it is a IEEE 802.1Q frame\n  - id: tci\n    type: tag_control_info\n    if: ether_type_1 == ether_type_enum::ieee_802_1q_tpid\n  - id: ether_type_2\n    type: u2be\n    enum: ether_type_enum\n    if: ether_type_1 == ether_type_enum::ieee_802_1q_tpid\n  - id: body\n    size-eos: true\n    type:\n      switch-on: ether_type\n      cases:\n        'ether_type_enum::ipv4': ipv4_packet\n        'ether_type_enum::ipv6': ipv6_packet\ninstances:\n  ether_type:\n    value: |\n      (ether_type_1 == ether_type_enum::ieee_802_1q_tpid) ? ether_type_2 : ether_type_1\n    doc: |\n      Ether type can be specied in several places in the frame. If\n      first location bears special marker (0x8100), then it is not the\n      real ether frame yet, an additional payload (`tci`) is expected\n      and real ether type is upcoming next.\ntypes:\n  tag_control_info:\n    doc: |\n      Tag Control Information (TCI) is an extension of IEEE 802.1Q to\n      support VLANs on normal IEEE 802.3 Ethernet network.\n    seq:\n      - id: priority\n        type: b3\n        doc: |\n          Priority Code Point (PCP) is used to specify priority for\n          different kinds of traffic.\n      - id: drop_eligible\n        type: b1\n        doc: |\n          Drop Eligible Indicator (DEI) specifies if frame is eligible\n          to dropping while congestion is detected for certain classes\n          of traffic.\n      - id: vlan_id\n        type: b12\n        doc: |\n          VLAN Identifier (VID) specifies which VLAN this frame\n          belongs to.\nenums:\n  # https://www.iana.org/assignments/ieee-802-numbers/ieee-802-numbers.xhtml\n  ether_type_enum:\n    0x0800: ipv4\n    0x0801: x_75_internet\n    0x0802: nbs_internet\n    0x0803: ecma_internet\n    0x0804: chaosnet\n    0x0805: x_25_level_3\n    0x0806: arp\n    0x8100: ieee_802_1q_tpid\n    0x86dd: ipv6\n    #0x88a8: ieee_802_1ad_tpid\n"
  },
  {
    "id": "ksy_hccap",
    "name": "Hashcat capture file (old version)",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [
        "hccap"
      ],
      "description": "Hashcat capture file (old version)",
      "originalCategory": "network",
      "filePath": "network/hccap.ksy",
      "endian": "le"
    },
    "content": "meta:\n  id: hccap\n  title: Hashcat capture file (old version)\n  application:\n    - Hashcat\n    - aircrack-ng\n  file-extension: hccap\n  license: Unlicense\n  encoding: utf-8\n  endian: le\ndoc: |\n  Native format of Hashcat password \"recovery\" utility.\n\n  A sample of file for testing can be downloaded from\n  <https://web.archive.org/web/20150220013635if_/http://hashcat.net:80/misc/example_hashes/hashcat.hccap>\ndoc-ref: https://hashcat.net/wiki/doku.php?id=hccap\nseq:\n  - id: records\n    type: hccap_record\n    repeat: eos\ntypes:\n  hccap_record:\n    seq:\n      - id: essid\n        size: 36\n      - id: mac_ap\n        -orig-id: ap_mac\n        size: 6\n        doc: The BSSID (MAC address) of the access point\n      - id: mac_station\n        -orig-id: station_mac\n        size: 6\n        doc: The MAC address of a client connecting to the access point\n      - id: nonce_station\n        -orig-id: station_nonce\n        size: 32\n        doc: Nonce (random salt) generated by the client connecting to the access point.\n      - id: nonce_ap\n        -orig-id: ap_nonce\n        size: 32\n        doc: Nonce (random salt) generated by the access point.\n      - id: eapol_buffer\n        type: eapol_dummy\n        size: 256\n        doc: Buffer for EAPOL data, only first `len_eapol` bytes are used\n      - id: len_eapol\n        -orig-id: eapol_size\n        type: u4\n        doc: Size of EAPOL data\n      - id: keyver\n        type: u4\n        doc: |\n          The flag used to distinguish WPA from WPA2 ciphers. Value of\n          1 means WPA, other - WPA2.\n      - id: keymic\n        size: 16\n        doc: |\n          The final hash value. MD5 for WPA and SHA-1 for WPA2\n          (truncated to 128 bit).\n    instances:\n      eapol:\n        io: eapol_buffer._io\n        pos: 0\n        size: len_eapol\n  eapol_dummy: {}\n"
  },
  {
    "id": "ksy_hccapx",
    "name": "Hashcat capture file",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [
        "hccapx"
      ],
      "description": "Hashcat capture file",
      "originalCategory": "network",
      "filePath": "network/hccapx.ksy",
      "endian": "le"
    },
    "content": "meta:\n  id: hccapx\n  title: Hashcat capture file\n  application:\n    - Hashcat\n    - aircrack-ng\n  file-extension: hccapx\n  license: Unlicense\n  endian: le\ndoc: |\n  Native format of Hashcat password \"recovery\" utility\ndoc-ref: https://hashcat.net/wiki/doku.php?id=hccapx\nseq:\n  - id: records\n    type: hccapx_record\n    repeat: eos\ntypes:\n  hccapx_record:\n    seq:\n      - id: magic\n        contents: \"HCPX\"\n      - id: version\n        type: u4\n        doc: The version number of the .hccapx file format.\n      - id: ignore_replay_counter\n        type: b1\n        doc: |\n          Indicates if the message pair matching was done based on\n          replay counter or not.\n\n          Whenever it was set to 1 it means that the replay counter\n          was ignored (i.e. it was not considered at all by the\n          matching algorithm).\n\n          Hashcat currently does not perform any particular action\n          based on this bit, but nonetheless this information could be\n          crucial for some 3th party tools and for\n          analysis/statistics. There could be some opportunity to\n          implement some further logic based on this particular\n          information also within hashcat (in the future).\n      - id: message_pair\n        type: b7\n        doc: |\n          The message_pair value describes which messages of the 4-way\n          handshake were combined to form the .hccapx structure. It is\n          always a pair of 2 messages: 1 from the AP (access point)\n          and 1 from the STA (client).\n\n          Furthermore, the message_pair value also gives a hint from\n          which of the 2 messages the EAPOL origins. This is\n          interesting data, but not necessarily needed for hashcat to\n          be able to crack the hash.\n\n          On the other hand, it could be very important to know if\n          \"only\" message 1 and message 2 were captured or if for\n          instance message 3 and/or message 4 were captured too. If\n          message 3 and/or message 4 were captured it should be a hard\n          evidence that the connection was established and that the\n          password the client used was the correct one.\n      - id: len_essid\n        -orig-id: essid_len\n        type: u1\n      - id: essid\n        size: len_essid\n      - id: padding1\n        size: 32 - len_essid\n      - id: keyver\n        type: u1\n        doc: |\n          The flag used to distinguish WPA from WPA2 ciphers. Value of\n          1 means WPA, other - WPA2.\n      - id: keymic\n        size: 16\n        doc: |\n          The final hash value. MD5 for WPA and SHA-1 for WPA2\n          (truncated to 128 bit).\n      - id: mac_ap\n        size: 6\n        doc: The BSSID (MAC address) of the access point.\n      - id: nonce_ap\n        size: 32\n        doc: Nonce (random salt) generated by the access point.\n      - id: mac_station\n        -orig-id: mac_sta\n        size: 6\n        doc: The MAC address of the client connecting to the access point.\n      - id: nonce_station\n        -orig-id: nonce_sta\n        size: 32\n        doc: Nonce (random salt) generated by the client connecting to the access point.\n      - id: len_eapol\n        -orig-id: eapol_len\n        type: u2\n        doc: The length of the EAPOL data.\n      - id: eapol\n        size: len_eapol\n      - id: padding2\n        size: 256 - len_eapol\n"
  },
  {
    "id": "ksy_icmp_packet",
    "name": "ICMP network packet",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "ICMP network packet",
      "originalCategory": "network",
      "filePath": "network/icmp_packet.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: icmp_packet\n  title: ICMP network packet\n  xref:\n    rfc: 792\n    wikidata: Q13162\n  license: CC0-1.0\n  endian: be\nseq:\n  - id: icmp_type\n    type: u1\n    enum: icmp_type_enum\n  - id: destination_unreachable\n    type: destination_unreachable_msg\n    if: icmp_type == icmp_type_enum::destination_unreachable\n  - id: time_exceeded\n    type: time_exceeded_msg\n    if: icmp_type == icmp_type_enum::time_exceeded\n  - id: echo\n    type: echo_msg\n    if: icmp_type == icmp_type_enum::echo or icmp_type == icmp_type_enum::echo_reply\nenums:\n  icmp_type_enum:\n    0: echo_reply\n    3: destination_unreachable\n    4: source_quench\n    5: redirect\n    8: echo\n    11: time_exceeded\ntypes:\n  destination_unreachable_msg:\n    seq:\n      - id: code\n        type: u1\n        enum: destination_unreachable_code\n      - id: checksum\n        type: u2\n    enums:\n      destination_unreachable_code:\n        0: net_unreachable\n        1: host_unreachable\n        2: protocol_unreachable\n        3: port_unreachable\n        4: fragmentation_needed_and_df_set\n        5: source_route_failed\n        6: dst_net_unkown\n        7: sdt_host_unkown\n        8: src_isolated\n        9: net_prohibited_by_admin\n        10: host_prohibited_by_admin\n        11: net_unreachable_for_tos\n        12: host_unreachable_for_tos\n        13: communication_prohibited_by_admin\n        14: host_precedence_violation\n        15: precedence_cuttoff_in_effect\n  time_exceeded_msg:\n    seq:\n      - id: code\n        type: u1\n        enum: time_exceeded_code\n      - id: checksum\n        type: u2\n    enums:\n      time_exceeded_code:\n        0: time_to_live_exceeded_in_transit\n        1: fragment_reassembly_time_exceeded\n  echo_msg:\n    seq:\n      - id: code\n        contents: [0]\n      - id: checksum\n        type: u2\n      - id: identifier\n        type: u2\n      - id: seq_num\n        type: u2\n      - id: data\n        size-eos: true\n"
  },
  {
    "id": "ksy_ipv4_packet",
    "name": "IPv4 network packet",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "IPv4 network packet",
      "originalCategory": "network",
      "filePath": "network/ipv4_packet.ksy"
    },
    "content": "meta:\n  id: ipv4_packet\n  title: IPv4 network packet\n  xref:\n    rfc: 791\n    wikidata: Q11103\n  license: CC0-1.0\n  ks-version: 0.8\n  imports:\n    - /network/protocol_body\nseq:\n  - id: b1\n    type: u1\n  - id: b2\n    type: u1\n  - id: total_length\n    type: u2be\n  - id: identification\n    type: u2be\n  - id: b67\n    type: u2be\n  - id: ttl\n    type: u1\n  - id: protocol\n    type: u1\n  - id: header_checksum\n    type: u2be\n  - id: src_ip_addr\n    size: 4\n  - id: dst_ip_addr\n    size: 4\n  - id: options\n    type: ipv4_options\n    size: ihl_bytes - 20\n  - id: body\n    size: total_length - ihl_bytes\n    type: protocol_body(protocol)\ninstances:\n  version:\n    value: (b1 & 0xf0) >> 4\n  ihl:\n    value: b1 & 0xf\n  ihl_bytes:\n    value: ihl * 4\ntypes:\n  ipv4_options:\n    seq:\n      - id: entries\n        type: ipv4_option\n        repeat: eos\n  ipv4_option:\n    seq:\n      - id: b1\n        type: u1\n      - id: len\n        type: u1\n      - id: body\n        size: 'len > 2 ? len - 2 : 0'\n    instances:\n      copy:\n        value: (b1 & 0b10000000) >> 7\n      opt_class:\n        value: (b1 & 0b01100000) >> 5\n      number:\n        value: (b1 & 0b00011111)\n"
  },
  {
    "id": "ksy_ipv6_packet",
    "name": "IPv6 network packet",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "IPv6 network packet",
      "originalCategory": "network",
      "filePath": "network/ipv6_packet.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: ipv6_packet\n  title: IPv6 network packet\n  license: CC0-1.0\n  ks-version: 0.8\n  imports:\n    - /network/protocol_body\n  endian: be\nseq:\n  - id: version\n    type: b4\n  - id: traffic_class\n    type: b8\n  - id: flow_label\n    type: b20\n  - id: payload_length\n    type: u2\n  - id: next_header_type\n    type: u1\n  - id: hop_limit\n    type: u1\n  - id: src_ipv6_addr\n    size: 16\n  - id: dst_ipv6_addr\n    size: 16\n  - id: next_header\n    type: protocol_body(next_header_type)\n  - id: rest\n    size-eos: true\n"
  },
  {
    "id": "ksy_microsoft_network_monitor_v2",
    "name": "Microsoft Network Monitor V2",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [
        "cap"
      ],
      "description": "",
      "originalCategory": "network",
      "filePath": "network/microsoft_network_monitor_v2.ksy",
      "signature": {
        "offset": 0,
        "bytes": [
          71,
          77,
          66,
          85
        ]
      },
      "endian": "le"
    },
    "content": "meta:\n  id: microsoft_network_monitor_v2\n  application: Microsoft Network Monitor, v2.x\n  file-extension: cap\n  license: CC0-1.0\n  xref:\n    pronom: fmt/778\n    wikidata: Q47245444\n  ks-version: 0.7\n  imports:\n    - /network/ethernet_frame\n    - /windows/windows_systemtime\n  endian: le\ndoc: |\n  Microsoft Network Monitor (AKA Netmon) is a proprietary Microsoft's\n  network packet sniffing and analysis tool. It can save captured\n  traffic as .cap files, which usually contain the packets and may\n  contain some additional info - enhanced network info, calculated\n  statistics, etc.\n\n  There are at least 2 different versions of the format: v1 and\n  v2. Netmon v3 seems to use the same file format as v1.\ndoc-ref: https://learn.microsoft.com/en-us/windows/win32/netmon2/capturefile-header-values\nseq:\n  - id: signature\n    contents: GMBU\n  - id: version_minor\n    type: u1\n    doc: Format version (minor), BCD\n  - id: version_major\n    type: u1\n    doc: Format version (major), BCD\n  - id: mac_type\n    type: u2\n    enum: linktype\n    doc: Network topology type of captured data\n  - id: time_capture_start\n    type: windows_systemtime\n    doc: Timestamp of capture start\n  - id: frame_table_ofs\n    type: u4\n  - id: frame_table_len\n    type: u4\n  - id: user_data_ofs\n    type: u4\n  - id: user_data_len\n    type: u4\n  - id: comment_ofs\n    type: u4\n  - id: comment_len\n    type: u4\n  - id: statistics_ofs\n    type: u4\n  - id: statistics_len\n    type: u4\n  - id: network_info_ofs\n    type: u4\n  - id: network_info_len\n    type: u4\n  - id: conversation_stats_ofs\n    type: u4\n  - id: conversation_stats_len\n    type: u4\ninstances:\n  frame_table:\n    pos: frame_table_ofs\n    size: frame_table_len\n    type: frame_index\n    doc: Index that is used to access individual captured frames\ntypes:\n  frame_index:\n    seq:\n      - id: entries\n        type: frame_index_entry\n        repeat: eos\n  frame_index_entry:\n    doc: |\n      Each index entry is just a pointer to where the frame data is\n      stored in the file.\n    seq:\n      - id: ofs\n        doc: Absolute pointer to frame data in the file\n        type: u4\n    instances:\n      body:\n        io: _root._io\n        pos: ofs\n        type: frame\n        doc: Frame body itself\n  frame:\n    doc: |\n      A container for actually captured network data. Allow to\n      timestamp individual frames and designates how much data from\n      the original packet was actually written into the file.\n    doc-ref: https://learn.microsoft.com/en-us/windows/win32/netmon2/frame\n    seq:\n      - id: ts_delta\n        type: u8\n        doc: Time stamp - usecs since start of capture\n      - id: orig_len\n        type: u4\n        doc: Actual length of packet\n      - id: inc_len\n        type: u4\n        doc: Number of octets captured in file\n      - id: body\n        size: inc_len\n        doc: Actual packet captured from the network\n        type:\n          switch-on: _root.mac_type\n          cases:\n            'linktype::ethernet': ethernet_frame\n# Duplicate from pcap.ksy - should disappear from here as soon as\n# we'll get shared enums working\nenums:\n  linktype:\n    # https://www.tcpdump.org/linktypes.html\n    0: null_linktype\n    1: ethernet\n    3: ax25\n    6: ieee802_5\n    7: arcnet_bsd\n    8: slip\n    9: ppp\n    10: fddi\n    50: ppp_hdlc\n    51: ppp_ether\n    100: atm_rfc1483\n    101: raw\n    104: c_hdlc\n    105: ieee802_11\n    107: frelay\n    108: loop\n    113: linux_sll\n    114: ltalk\n    117: pflog\n    119: ieee802_11_prism\n    122: ip_over_fc\n    123: sunatm\n    127: ieee802_11_radiotap\n    129: arcnet_linux\n    138: apple_ip_over_ieee1394\n    139: mtp2_with_phdr\n    140: mtp2\n    141: mtp3\n    142: sccp\n    143: docsis\n    144: linux_irda\n    147: user0\n    148: user1\n    149: user2\n    150: user3\n    151: user4\n    152: user5\n    153: user6\n    154: user7\n    155: user8\n    156: user9\n    157: user10\n    158: user11\n    159: user12\n    160: user13\n    161: user14\n    162: user15\n    163: ieee802_11_avs\n    165: bacnet_ms_tp\n    166: ppp_pppd\n    169: gprs_llc\n    170: gpf_t\n    171: gpf_f\n    177: linux_lapd\n    187: bluetooth_hci_h4\n    189: usb_linux\n    192: ppi\n    195: ieee802_15_4\n    196: sita\n    197: erf\n    201: bluetooth_hci_h4_with_phdr\n    202: ax25_kiss\n    203: lapd\n    204: ppp_with_dir\n    205: c_hdlc_with_dir\n    206: frelay_with_dir\n    209: ipmb_linux\n    215: ieee802_15_4_nonask_phy\n    220: usb_linux_mmapped\n    224: fc_2\n    225: fc_2_with_frame_delims\n    226: ipnet\n    227: can_socketcan\n    228: ipv4\n    229: ipv6\n    230: ieee802_15_4_nofcs\n    231: dbus\n    235: dvb_ci\n    236: mux27010\n    237: stanag_5066_d_pdu\n    239: nflog\n    240: netanalyzer\n    241: netanalyzer_transparent\n    242: ipoib\n    243: mpeg_2_ts\n    244: ng40\n    245: nfc_llcp\n    247: infiniband\n    248: sctp\n    249: usbpcap\n    250: rtac_serial\n    251: bluetooth_le_ll\n    253: netlink\n    254: bluetooth_linux_monitor\n    255: bluetooth_bredr_bb\n    256: bluetooth_le_ll_with_phdr\n    257: profibus_dl\n    258: pktap\n    259: epon\n    260: ipmi_hpm_2\n    261: zwave_r1_r2\n    262: zwave_r3\n    263: wattstopper_dlm\n    264: iso_14443\n"
  },
  {
    "id": "ksy_packet_ppi",
    "name": "Packet Ppi",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "",
      "originalCategory": "network",
      "filePath": "network/packet_ppi.ksy",
      "endian": "le"
    },
    "content": "meta:\n  id: packet_ppi\n  license: CC0-1.0\n  imports:\n    - /network/ethernet_frame\n  endian: le\ndoc: |\n  PPI is a standard for link layer packet encapsulation, proposed as\n  generic extensible container to store both captured in-band data and\n  out-of-band data. Originally it was developed to provide 802.11n\n  radio information, but can be used for other purposes as well.\n\n  Sample capture:\n  <https://wiki.wireshark.org/uploads/27707187aeb30df68e70c8fb9d614981/http.cap>\ndoc-ref: >-\n  https://web.archive.org/web/20090206112419/https://www.cacetech.com/documents/PPI_Header_format_1.0.1.pdf\n  PPI header format spec, section 3\nseq:\n  - id: header\n    type: packet_ppi_header\n  - id: fields\n    type: packet_ppi_fields\n    size: header.pph_len - 8 # sizeof(packet_ppi_header)\n  - id: body\n    size-eos: true\n    type:\n      switch-on: header.pph_dlt\n      cases:\n        'linktype::ppi': packet_ppi\n        'linktype::ethernet': ethernet_frame\ntypes:\n  packet_ppi_header:\n    doc-ref: >-\n      https://web.archive.org/web/20090206112419/https://www.cacetech.com/documents/PPI_Header_format_1.0.1.pdf\n      PPI header format spec, section 3.1\n    seq:\n      - id: pph_version\n        type: u1\n      - id: pph_flags\n        type: u1\n      - id: pph_len\n        type: u2\n      - id: pph_dlt\n        type: u4\n        enum: linktype\n  packet_ppi_fields:\n    seq:\n      - id: entries\n        type: packet_ppi_field\n        repeat: eos\n  packet_ppi_field:\n    doc-ref: >-\n      https://web.archive.org/web/20090206112419/https://www.cacetech.com/documents/PPI_Header_format_1.0.1.pdf\n      PPI header format spec, section 3.1\n    seq:\n      - id: pfh_type\n        type: u2\n        enum: pfh_type\n      - id: pfh_datalen\n        type: u2\n      - id: body\n        size: pfh_datalen\n        type:\n          switch-on: pfh_type\n          cases:\n            'pfh_type::radio_802_11_common': radio_802_11_common_body\n            'pfh_type::radio_802_11n_mac_ext': radio_802_11n_mac_ext_body\n            'pfh_type::radio_802_11n_mac_phy_ext': radio_802_11n_mac_phy_ext_body\n  radio_802_11_common_body:\n    doc-ref: >-\n      https://web.archive.org/web/20090206112419/https://www.cacetech.com/documents/PPI_Header_format_1.0.1.pdf\n      PPI header format spec, section 4.1.2\n    seq:\n      - id: tsf_timer\n        type: u8\n      - id: flags\n        type: u2\n      - id: rate\n        type: u2\n      - id: channel_freq\n        type: u2\n      - id: channel_flags\n        type: u2\n      - id: fhss_hopset\n        type: u1\n      - id: fhss_pattern\n        type: u1\n      - id: dbm_antsignal\n        type: s1\n      - id: dbm_antnoise\n        type: s1\n  radio_802_11n_mac_ext_body:\n    doc-ref: >-\n      https://web.archive.org/web/20090206112419/https://www.cacetech.com/documents/PPI_Header_format_1.0.1.pdf\n      PPI header format spec, section 4.1.3\n    seq:\n      - id: flags\n        type: mac_flags\n      - id: a_mpdu_id\n        type: u4\n      - id: num_delimiters\n        type: u1\n      - id: reserved\n        size: 3\n  radio_802_11n_mac_phy_ext_body:\n    doc-ref: >-\n      https://web.archive.org/web/20090206112419/https://www.cacetech.com/documents/PPI_Header_format_1.0.1.pdf\n      PPI header format spec, section 4.1.4\n    seq:\n      - id: flags\n        type: mac_flags\n      - id: a_mpdu_id\n        type: u4\n      - id: num_delimiters\n        type: u1\n      - id: mcs\n        type: u1\n        doc: Modulation Coding Scheme (MCS)\n      - id: num_streams\n        type: u1\n        doc: Number of spatial streams (0 = unknown)\n      - id: rssi_combined\n        type: u1\n        doc: RSSI (Received Signal Strength Indication), combined from all active antennas / channels\n      - id: rssi_ant_ctl\n        type: u1\n        doc: RSSI (Received Signal Strength Indication) for antennas 0-3, control channel\n        repeat: expr\n        repeat-expr: 4\n      - id: rssi_ant_ext\n        type: u1\n        doc: RSSI (Received Signal Strength Indication) for antennas 0-3, extension channel\n        repeat: expr\n        repeat-expr: 4\n      - id: ext_channel_freq\n        type: u2\n        doc: Extension channel frequency (MHz)\n      - id: ext_channel_flags\n        type: channel_flags\n        doc: Extension channel flags\n      - id: rf_signal_noise\n        type: signal_noise\n        repeat: expr\n        repeat-expr: 4\n        doc: Signal + noise values for antennas 0-3\n      - id: evm\n        type: u4\n        repeat: expr\n        repeat-expr: 4\n        doc: EVM (Error Vector Magnitude) for chains 0-3\n    types:\n      channel_flags:\n        seq:\n          # First byte\n          - id: spectrum_2ghz\n            type: b1\n            doc: 2 GHz spectrum\n          - id: ofdm\n            type: b1\n            doc: OFDM (Orthogonal Frequency-Division Multiplexing)\n          - id: cck\n            type: b1\n            doc: CCK (Complementary Code Keying)\n          - id: turbo\n            type: b1\n          # Unused LSB of first byte + MSB of second byte\n          - id: unused\n            type: b8\n          # Second byte\n          - id: gfsk\n            type: b1\n            doc: Gaussian Frequency Shift Keying\n          - id: dyn_cck_ofdm\n            type: b1\n            doc: Dynamic CCK-OFDM\n          - id: only_passive_scan\n            type: b1\n            doc: Only passive scan allowed\n          - id: spectrum_5ghz\n            type: b1\n            doc: 5 GHz spectrum\n      signal_noise:\n        doc: RF signal + noise pair at a single antenna\n        seq:\n          - id: signal\n            type: s1\n            doc: RF signal, dBm\n          - id: noise\n            type: s1\n            doc: RF noise, dBm\n  mac_flags:\n    seq:\n      - id: unused1\n        type: b1\n      - id: aggregate_delimiter\n        type: b1\n        doc: Aggregate delimiter CRC error after this frame\n      - id: more_aggregates\n        type: b1\n        doc: More aggregates\n      - id: aggregate\n        type: b1\n        doc: Aggregate\n      - id: dup_rx\n        type: b1\n        doc: Duplicate RX\n      - id: rx_short_guard\n        type: b1\n        doc: RX short guard interval (SGI)\n      - id: is_ht_40\n        type: b1\n        doc: true = HT40, false = HT20\n      - id: greenfield\n        type: b1\n        doc: Greenfield\n      - id: unused2\n        size: 3\nenums:\n  pfh_type:\n    2: radio_802_11_common\n    3: radio_802_11n_mac_ext\n    4: radio_802_11n_mac_phy_ext\n    5: spectrum_map\n    6: process_info\n    7: capture_info\n\n  # FIXME: this is copy-paste from pcap.ksy, remove after\n  # implementation of enum sharing / parametric types\n  linktype:\n    # https://www.tcpdump.org/linktypes.html\n    0: null_linktype\n    1: ethernet\n    3: ax25\n    6: ieee802_5\n    7: arcnet_bsd\n    8: slip\n    9: ppp\n    10: fddi\n    50: ppp_hdlc\n    51: ppp_ether\n    100: atm_rfc1483\n    101: raw\n    104: c_hdlc\n    105: ieee802_11\n    107: frelay\n    108: loop\n    113: linux_sll\n    114: ltalk\n    117: pflog\n    119: ieee802_11_prism\n    122: ip_over_fc\n    123: sunatm\n    127: ieee802_11_radiotap\n    129: arcnet_linux\n    138: apple_ip_over_ieee1394\n    139: mtp2_with_phdr\n    140: mtp2\n    141: mtp3\n    142: sccp\n    143: docsis\n    144: linux_irda\n    147: user0\n    148: user1\n    149: user2\n    150: user3\n    151: user4\n    152: user5\n    153: user6\n    154: user7\n    155: user8\n    156: user9\n    157: user10\n    158: user11\n    159: user12\n    160: user13\n    161: user14\n    162: user15\n    163: ieee802_11_avs\n    165: bacnet_ms_tp\n    166: ppp_pppd\n    169: gprs_llc\n    170: gpf_t\n    171: gpf_f\n    177: linux_lapd\n    187: bluetooth_hci_h4\n    189: usb_linux\n    192: ppi\n    195: ieee802_15_4\n    196: sita\n    197: erf\n    201: bluetooth_hci_h4_with_phdr\n    202: ax25_kiss\n    203: lapd\n    204: ppp_with_dir\n    205: c_hdlc_with_dir\n    206: frelay_with_dir\n    209: ipmb_linux\n    215: ieee802_15_4_nonask_phy\n    220: usb_linux_mmapped\n    224: fc_2\n    225: fc_2_with_frame_delims\n    226: ipnet\n    227: can_socketcan\n    228: ipv4\n    229: ipv6\n    230: ieee802_15_4_nofcs\n    231: dbus\n    235: dvb_ci\n    236: mux27010\n    237: stanag_5066_d_pdu\n    239: nflog\n    240: netanalyzer\n    241: netanalyzer_transparent\n    242: ipoib\n    243: mpeg_2_ts\n    244: ng40\n    245: nfc_llcp\n    247: infiniband\n    248: sctp\n    249: usbpcap\n    250: rtac_serial\n    251: bluetooth_le_ll\n    253: netlink\n    254: bluetooth_linux_monitor\n    255: bluetooth_bredr_bb\n    256: bluetooth_le_ll_with_phdr\n    257: profibus_dl\n    258: pktap\n    259: epon\n    260: ipmi_hpm_2\n    261: zwave_r1_r2\n    262: zwave_r3\n    263: wattstopper_dlm\n    264: iso_14443\n"
  },
  {
    "id": "ksy_pcap",
    "name": "Pcap",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [
        "pcap",
        "pcapdump"
      ],
      "description": "",
      "originalCategory": "network",
      "filePath": "network/pcap.ksy",
      "endian": "le"
    },
    "content": "meta:\n  id: pcap\n  file-extension:\n    - pcap\n    - pcapdump\n  xref:\n    forensicswiki: pcap\n    justsolve: PCAP\n    pronom: fmt/779\n    wikidata: Q28009435\n  license: CC0-1.0\n  ks-version: 0.8\n  imports:\n    - /network/ethernet_frame\n    - /network/packet_ppi\n  endian: le\ndoc: |\n  PCAP (named after libpcap / winpcap) is a popular format for saving\n  network traffic grabbed by network sniffers. It is typically\n  produced by tools like [tcpdump](https://www.tcpdump.org/) or\n  [Wireshark](https://www.wireshark.org/).\ndoc-ref: https://wiki.wireshark.org/Development/LibpcapFileFormat\nseq:\n  - id: hdr\n    type: header\n  - id: packets\n    type: packet\n    repeat: eos\ntypes:\n  header:\n    doc-ref: 'https://wiki.wireshark.org/Development/LibpcapFileFormat#Global_Header'\n    seq:\n      - id: magic_number\n        contents: [0xd4, 0xc3, 0xb2, 0xa1]\n      - id: version_major\n        type: u2\n        valid:\n          eq: 2\n      - id: version_minor\n        type: u2\n      - id: thiszone\n        type: s4\n        doc: |\n          Correction time in seconds between UTC and the local\n          timezone of the following packet header timestamps.\n      - id: sigfigs\n        type: u4\n        doc: |\n          In theory, the accuracy of time stamps in the capture; in\n          practice, all tools set it to 0.\n      - id: snaplen\n        type: u4\n        doc: |\n          The \"snapshot length\" for the capture (typically 65535 or\n          even more, but might be limited by the user), see: incl_len\n          vs. orig_len.\n      - id: network\n        type: u4\n        enum: linktype\n        doc: |\n          Link-layer header type, specifying the type of headers at\n          the beginning of the packet.\n  packet:\n    doc-ref: 'https://wiki.wireshark.org/Development/LibpcapFileFormat#Record_.28Packet.29_Header'\n    seq:\n      - id: ts_sec\n        type: u4\n      - id: ts_usec\n        type: u4\n      - id: incl_len\n        type: u4\n        doc: Number of bytes of packet data actually captured and saved in the file.\n      - id: orig_len\n        type: u4\n        doc: Length of the packet as it appeared on the network when it was captured.\n      - id: body\n        size: \"incl_len < _root.hdr.snaplen ? incl_len : _root.hdr.snaplen\"\n        type:\n          switch-on: _root.hdr.network\n          cases:\n            'linktype::ppi': packet_ppi\n            'linktype::ethernet': ethernet_frame\n        doc-ref: 'https://wiki.wireshark.org/Development/LibpcapFileFormat#Packet_Data'\nenums:\n  linktype:\n    # https://www.tcpdump.org/linktypes.html\n    0: null_linktype\n    1: ethernet\n    2: exp_ethernet\n    3: ax25\n    4: pronet\n    5: chaos\n    6: ieee802_5\n    7: arcnet_bsd\n    8: slip\n    9: ppp\n    10: fddi\n    32: redback_smartedge\n    50: ppp_hdlc\n    51: ppp_ether\n    99: symantec_firewall\n    100: atm_rfc1483\n    101: raw\n    104: c_hdlc\n    105: ieee802_11\n    106: atm_clip\n    107: frelay\n    108: loop\n    109: enc\n    112: netbsd_hdlc\n    113: linux_sll\n    114: ltalk\n    115: econet\n    116: ipfilter\n    117: pflog\n    118: cisco_ios\n    119: ieee802_11_prism\n    120: aironet_header\n    122: ip_over_fc\n    123: sunatm\n    124: rio\n    125: pci_exp\n    126: aurora\n    127: ieee802_11_radiotap\n    128: tzsp\n    129: arcnet_linux\n    130: juniper_mlppp\n    131: juniper_mlfr\n    132: juniper_es\n    133: juniper_ggsn\n    134: juniper_mfr\n    135: juniper_atm2\n    136: juniper_services\n    137: juniper_atm1\n    138: apple_ip_over_ieee1394\n    139: mtp2_with_phdr\n    140: mtp2\n    141: mtp3\n    142: sccp\n    143: docsis\n    144: linux_irda\n    145: ibm_sp\n    146: ibm_sn\n    147: user0\n    148: user1\n    149: user2\n    150: user3\n    151: user4\n    152: user5\n    153: user6\n    154: user7\n    155: user8\n    156: user9\n    157: user10\n    158: user11\n    159: user12\n    160: user13\n    161: user14\n    162: user15\n    163: ieee802_11_avs\n    164: juniper_monitor\n    165: bacnet_ms_tp\n    166: ppp_pppd\n    167: juniper_pppoe\n    168: juniper_pppoe_atm\n    169: gprs_llc\n    170: gpf_t\n    171: gpf_f\n    172: gcom_t1e1\n    173: gcom_serial\n    174: juniper_pic_peer\n    175: erf_eth\n    176: erf_pos\n    177: linux_lapd\n    178: juniper_ether\n    179: juniper_ppp\n    180: juniper_frelay\n    181: juniper_chdlc\n    182: mfr\n    183: juniper_vp\n    184: a429\n    185: a653_icm\n    186: usb_freebsd\n    187: bluetooth_hci_h4\n    188: ieee802_16_mac_cps\n    189: usb_linux\n    190: can20b\n    191: ieee802_15_4_linux\n    192: ppi\n    193: ieee802_16_mac_cps_radio\n    194: juniper_ism\n    195: ieee802_15_4_withfcs\n    196: sita\n    197: erf\n    198: raif1\n    199: ipmb_kontron\n    200: juniper_st\n    201: bluetooth_hci_h4_with_phdr\n    202: ax25_kiss\n    203: lapd\n    204: ppp_with_dir\n    205: c_hdlc_with_dir\n    206: frelay_with_dir\n    207: lapb_with_dir\n    209: ipmb_linux\n    210: flexray\n    211: most\n    212: lin\n    213: x2e_serial\n    214: x2e_xoraya\n    215: ieee802_15_4_nonask_phy\n    216: linux_evdev\n    217: gsmtap_um\n    218: gsmtap_abis\n    219: mpls\n    220: usb_linux_mmapped\n    221: dect\n    222: aos\n    223: wihart\n    224: fc_2\n    225: fc_2_with_frame_delims\n    226: ipnet\n    227: can_socketcan\n    228: ipv4\n    229: ipv6\n    230: ieee802_15_4_nofcs\n    231: dbus\n    232: juniper_vs\n    233: juniper_srx_e2e\n    234: juniper_fibrechannel\n    235: dvb_ci\n    236: mux27010\n    237: stanag_5066_d_pdu\n    238: juniper_atm_cemic\n    239: nflog\n    240: netanalyzer\n    241: netanalyzer_transparent\n    242: ipoib\n    243: mpeg_2_ts\n    244: ng40\n    245: nfc_llcp\n    246: pfsync\n    247: infiniband\n    248: sctp\n    249: usbpcap\n    250: rtac_serial\n    251: bluetooth_le_ll\n    252: wireshark_upper_pdu\n    253: netlink\n    254: bluetooth_linux_monitor\n    255: bluetooth_bredr_bb\n    256: bluetooth_le_ll_with_phdr\n    257: profibus_dl\n    258: pktap\n    259: epon\n    260: ipmi_hpm_2\n    261: zwave_r1_r2\n    262: zwave_r3\n    263: wattstopper_dlm\n    264: iso_14443\n    265: rds\n    266: usb_darwin\n    267: openflow\n    268: sdlc\n    269: ti_lln_sniffer\n    270: loratap\n    271: vsock\n    272: nordic_ble\n    273: docsis31_xra31\n    274: ethernet_mpacket\n    275: displayport_aux\n    276: linux_sll2\n    277: sercos_monitor\n    278: openvizsla\n    279: ebhscr\n    280: vpp_dispatch\n    281: dsa_tag_brcm\n    282: dsa_tag_brcm_prepend\n    283: ieee802_15_4_tap\n    284: dsa_tag_dsa\n    285: dsa_tag_edsa\n    286: elee\n    287:\n      id: zwave_serial\n      -orig-id: LINKTYPE_Z_WAVE_SERIAL # `Z_WAVE` instead of `ZWAVE` is a name\n                                       # inconsistency (other labels use `ZWAVE`)\n    288: usb_2_0\n    289: atsc_alp\n    290: etw\n    291: netanalyzer_ng\n    292: zboss_ncp\n    293: usb_2_0_low_speed\n    294: usb_2_0_full_speed\n    295: usb_2_0_high_speed\n    296: auerswald_log\n    297: zwave_tap\n    298: silabs_debug_channel\n    299: fira_uci\n"
  },
  {
    "id": "ksy_protocol_body",
    "name": "Protocol Body",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "",
      "originalCategory": "network",
      "filePath": "network/protocol_body.ksy"
    },
    "content": "meta:\n  id: protocol_body\n  license: CC0-1.0\n  ks-version: 0.8\n  imports:\n    - /network/tcp_segment\n    - /network/icmp_packet\n    - /network/udp_datagram\n    - /network/ipv4_packet\n    - /network/ipv6_packet\ndoc: |\n  Protocol body represents particular payload on transport level (OSI\n  layer 4).\n\n  Typically this payload in encapsulated into network level (OSI layer\n  3) packet, which includes \"protocol number\" field that would be used\n  to decide what's inside the payload and how to parse it. Thanks to\n  IANA's standardization effort, multiple network level use the same\n  IDs for these payloads named \"protocol numbers\".\n\n  This is effectively a \"router\" type: it expects to get protocol\n  number as a parameter, and then invokes relevant type parser based\n  on that parameter.\ndoc-ref: https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml\nparams:\n  - id: protocol_num\n    type: u1\n    doc: Protocol number as an integer.\nseq:\n  - id: body\n    type:\n      switch-on: protocol\n      cases:\n        'protocol_enum::hopopt': option_hop_by_hop\n        'protocol_enum::tcp': tcp_segment\n        'protocol_enum::icmp': icmp_packet\n        'protocol_enum::udp': udp_datagram\n        'protocol_enum::ipv4': ipv4_packet\n        'protocol_enum::ipv6': ipv6_packet\n        'protocol_enum::ipv6_nonxt': no_next_header\ninstances:\n  protocol:\n    value: protocol_num\n    enum: protocol_enum\ntypes:\n  no_next_header:\n    doc: Dummy type for IPv6 \"no next header\" type, which signifies end of headers chain.\n  option_hop_by_hop:\n    seq:\n      - id: next_header_type\n        type: u1\n      - id: hdr_ext_len\n        type: u1\n      - id: body\n        size: 'hdr_ext_len > 0 ? hdr_ext_len - 1 : 1'\n      - id: next_header\n        type: protocol_body(next_header_type)\nenums:\n  protocol_enum:\n    0: hopopt\n    1: icmp\n    2: igmp\n    3: ggp\n    4: ipv4\n    5: st\n    6: tcp\n    7: cbt\n    8: egp\n    9: igp\n    10: bbn_rcc_mon\n    11: nvp_ii\n    12: pup\n    13: argus\n    14: emcon\n    15: xnet\n    16: chaos\n    17: udp\n    18: mux\n    19: dcn_meas\n    20: hmp\n    21: prm\n    22: xns_idp\n    23: trunk_1\n    24: trunk_2\n    25: leaf_1\n    26: leaf_2\n    27: rdp\n    28: irtp\n    29: iso_tp4\n    30: netblt\n    31: mfe_nsp\n    32: merit_inp\n    33: dccp\n    34: x_3pc\n    35: idpr\n    36: xtp\n    37: ddp\n    38: idpr_cmtp\n    39: tp_plus_plus\n    40: il\n    41: ipv6\n    42: sdrp\n    43: ipv6_route\n    44: ipv6_frag\n    45: idrp\n    46: rsvp\n    47: gre\n    48: dsr\n    49: bna\n    50: esp\n    51: ah\n    52: i_nlsp\n    53: swipe\n    54: narp\n    55: mobile\n    56: tlsp\n    57: skip\n    58: ipv6_icmp\n    59: ipv6_nonxt\n    60: ipv6_opts\n    61: any_host_internal_protocol\n    62: cftp\n    63: any_local_network\n    64: sat_expak\n    65: kryptolan\n    66: rvd\n    67: ippc\n    68: any_distributed_file_system\n    69: sat_mon\n    70: visa\n    71: ipcv\n    72: cpnx\n    73: cphb\n    74: wsn\n    75: pvp\n    76: br_sat_mon\n    77: sun_nd\n    78: wb_mon\n    79: wb_expak\n    80: iso_ip\n    81: vmtp\n    82: secure_vmtp\n    83: vines\n    84: ttp_or_iptm\n    85: nsfnet_igp\n    86: dgp\n    87: tcf\n    88: eigrp\n    89: ospfigp\n    90: sprite_rpc\n    91: larp\n    92: mtp\n    93: ax_25\n    94: ipip\n    95: micp\n    96: scc_sp\n    97: etherip\n    98: encap\n    99: any_private_encryption_scheme\n    100: gmtp\n    101: ifmp\n    102: pnni\n    103: pim\n    104: aris\n    105: scps\n    106: qnx\n    107: a_n\n    108: ipcomp\n    109: snp\n    110: compaq_peer\n    111: ipx_in_ip\n    112: vrrp\n    113: pgm\n    114: any_0_hop\n    115: l2tp\n    116: ddx\n    117: iatp\n    118: stp\n    119: srp\n    120: uti\n    121: smp\n    122: sm\n    123: ptp\n    124: isis_over_ipv4\n    125: fire\n    126: crtp\n    127: crudp\n    128: sscopmce\n    129: iplt\n    130: sps\n    131: pipe\n    132: sctp\n    133: fc\n    134: rsvp_e2e_ignore\n    135: mobility_header\n    136: udplite\n    137: mpls_in_ip\n    138: manet\n    139: hip\n    140: shim6\n    141: wesp\n    142: rohc\n    255: reserved_255\n"
  },
  {
    "id": "ksy_rtcp_payload",
    "name": "rtcp network payload (single udp packet)",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "rtcp network payload (single udp packet)",
      "originalCategory": "network",
      "filePath": "network/rtcp_payload.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: rtcp_payload\n  title: rtcp network payload (single udp packet)\n  xref:\n    justsolve: RTP\n    wikidata: Q749940\n  license: CC0-1.0\n  ks-version: 0.7\n  endian: be\n\ndoc: RTCP is the Real-Time Control Protocol\n\ndoc-ref: https://www.rfc-editor.org/rfc/rfc3550\n\nseq:\n  - id: rtcp_packets\n    type: rtcp_packet\n    repeat: eos\n\ntypes:\n  rtcp_packet:\n    seq:\n      - id: version\n        type: b2\n      - id: padding\n        type: b1\n      - id: subtype\n        type: b5\n      - id: payload_type\n        type: u1\n        enum: payload_type\n      - id: length\n        type: u2\n      - id: body\n        size: 4 * length\n        type:\n          switch-on: payload_type\n          cases:\n            'payload_type::sr': sr_packet\n            'payload_type::rr': rr_packet\n            'payload_type::sdes': sdes_packet\n            'payload_type::psfb': psfb_packet\n            'payload_type::rtpfb': rtpfb_packet\n\n  sr_packet:\n    seq:\n      - id: ssrc\n        type: u4\n      - id: ntp_msw\n        type: u4\n      - id: ntp_lsw\n        type: u4\n      - id: rtp_timestamp\n        type: u4\n      - id: sender_packet_count\n        type: u4\n      - id: sender_octet_count\n        type: u4\n      - id: report_block\n        type: report_block\n        repeat: expr\n        repeat-expr: _parent.subtype\n    instances:\n      ntp:\n        value: (ntp_msw << 32) & ntp_lsw\n\n  rr_packet:\n    seq:\n      - id: ssrc\n        type: u4\n      - id: report_block\n        type: report_block\n        repeat: expr\n        repeat-expr: _parent.subtype\n\n  report_block:\n    seq:\n      - id: ssrc_source\n        type: u4\n      - id: lost_val\n        type: u1\n      - id: highest_seq_num_received\n        type: u4\n      - id: interarrival_jitter\n        type: u4\n      - id: lsr\n        type: u4\n      - id: dlsr\n        type: u4\n    instances:\n      fraction_lost:\n        value: lost_val >> 24\n      cumulative_packets_lost:\n        value: lost_val & 0x00ffffff\n\n  sdes_packet:\n    seq:\n      - id: source_chunk\n        type: source_chunk\n        repeat: expr\n        repeat-expr: source_count\n    instances:\n      source_count:\n        value: _parent.subtype\n\n  source_chunk:\n    seq:\n      - id: ssrc\n        type: u4\n      - id: sdes_tlv\n        type: sdes_tlv\n        repeat: eos\n\n  sdes_tlv:\n    seq:\n      - id: type\n        type: u1\n        enum: sdes_subtype\n      - id: length\n        type: u1\n        if: type != sdes_subtype::pad\n      - id: value\n        size: length\n        if: type != sdes_subtype::pad\n\n  rtpfb_packet:\n    seq:\n      - id: ssrc\n        type: u4\n      - id: ssrc_media_source\n        type: u4\n      - id: fci_block\n        type:\n          switch-on: fmt\n          cases:\n            'rtpfb_subtype::transport_feedback': rtpfb_transport_feedback_packet\n        size-eos: true\n    instances:\n      fmt:\n        value: _parent.subtype\n        enum: rtpfb_subtype\n\n  rtpfb_transport_feedback_packet:\n    seq:\n      - id: base_sequence_number\n        type: u2\n      - id: packet_status_count\n        type: u2\n      - id: b4\n        type: u4\n      - id: remaining\n        size-eos: true\n    instances:\n      reference_time:\n        value: b4 >> 8\n      fb_pkt_count:\n        value: b4 & 0xff\n      packet_status:\n        size: 0\n      recv_delta:\n        size: 0\n\n  packet_status_chunk:\n    seq:\n      - id: t\n        type: b1\n      - id: s2\n        type: b2\n        if: t.to_i == 0\n      - id: s1\n        type: b1\n        if: t.to_i == 1\n      - id: rle\n        type: b13\n        if: t.to_i == 0\n      - id: symbol_list\n        type: b14\n        if: t.to_i == 1\n    instances:\n      s:\n        value: '(t.to_i == 0) ? s2 : (s1.to_i == 0 ? 1 : 0)'\n\n  psfb_packet:\n    seq:\n      - id: ssrc\n        type: u4\n      - id: ssrc_media_source\n        type: u4\n      - id: fci_block\n        type:\n          switch-on: fmt\n          cases:\n            'psfb_subtype::afb': psfb_afb_packet\n        size-eos: true\n    instances:\n      fmt:\n        value: _parent.subtype\n        enum: psfb_subtype\n\n  psfb_afb_packet:\n    seq:\n      - id: uid\n        type: u4\n      - id: contents\n        type:\n          switch-on: uid\n          cases:\n            0x52454d42: psfb_afb_remb_packet\n        size-eos: true\n\n  psfb_afb_remb_packet:\n    seq:\n      - id: num_ssrc\n        type: u1\n      - id: br_exp\n        type: b6\n      - id: br_mantissa\n        type: b18\n      - id: ssrc_list\n        type: u4\n        repeat: expr\n        repeat-expr: num_ssrc\n    instances:\n      max_total_bitrate:\n        value: br_mantissa * (1<<br_exp)\n\n\n\nenums:\n  payload_type:\n    192: fir\n    193: nack\n    195: ij\n    200: sr\n    201: rr\n    202: sdes\n    203: bye\n    204: app\n    205: rtpfb\n    206: psfb\n    207: xr\n    208: avb\n    209: rsi\n  sdes_subtype:\n    0: pad\n    1: cname\n    2: name\n    3: email\n    4: phone\n    5: loc\n    6: tool\n    7: note\n    8: priv\n  psfb_subtype:\n    1: pli\n    2: sli\n    3: rpsi\n    4: fir\n    5: tstr\n    6: tstn\n    7: vbcm\n    15: afb\n  rtpfb_subtype:\n    1: nack\n    3: tmmbr\n    4: tmmbn\n    5: rrr\n    15: transport_feedback\n"
  },
  {
    "id": "ksy_rtp_packet",
    "name": "RTP (Real-time Transport Protocol)",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "RTP (Real-time Transport Protocol)",
      "originalCategory": "network",
      "filePath": "network/rtp_packet.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: rtp_packet\n  title: RTP (Real-time Transport Protocol)\n  xref:\n    justsolve: RTP\n    rfc:\n      - 3550\n      - 3551\n    wikidata: Q321213\n  license: Unlicense\n  endian: be\ndoc: |\n  The Real-time Transport Protocol (RTP) is a widely used network\n  protocol for transmitting audio or video. It usually works with the\n  RTP Control Protocol (RTCP). The transmission can be based on\n  Transmission Control Protocol (TCP) or User Datagram Protocol (UDP).\nseq:\n  - id: version\n    type: b2\n  - id: has_padding\n    type: b1\n  - id: has_extension\n    type: b1\n  - id: csrc_count\n    type: b4\n  - id: marker\n    type: b1\n  - id: payload_type\n    type: b7\n    enum: payload_type_enum\n  - id: sequence_number\n    type: u2\n  - id: timestamp\n    type: u4\n  - id: ssrc\n    type: u4\n  - id: header_extension\n    type: header_extention\n    if: has_extension\n  - id: data\n    size: _io.size - _io.pos - len_padding\n    doc: Payload without padding.\n  - id: padding\n    size: len_padding\ninstances:\n  len_padding_if_exists:\n    pos: _io.size - 1\n    type: u1\n    if: has_padding\n    doc: |\n      If padding bit is enabled, last byte of data contains number of\n      bytes appended to the payload as padding.\n  len_padding:\n    value: 'has_padding ? len_padding_if_exists : 0'\n    doc: Always returns number of padding bytes to in the payload.\ntypes:\n  header_extention:\n    seq:\n      - id: id\n        type: u2\n      - id: length\n        type: u2\nenums:\n  # https://datatracker.ietf.org/doc/html/rfc3551#section-6\n  payload_type_enum:\n    0: pcmu\n    1: reserved1\n    2: reserved2\n    3: gsm\n    4: g723\n    5: dvi4_1\n    6: dvi4_2\n    7: lpc\n    8: pcma\n    9: g722\n    10: l16_1\n    11: l16_2\n    12: qcelp\n    13: cn\n    14: mpa\n    15: g728\n    16: dvi4_3\n    17: dvi4_4\n    18: g729\n    19: reserved19\n    20: unassigned20\n    21: unassigned21\n    22: unassigned22\n    23: unassigned23\n    24: unassigned24\n    25: celb\n    26: jpeg\n    27: unassigned27\n    28: nv\n    29: unassigned29\n    30: unassigned30\n    31: h261\n    32: mpv\n    33: mp2t\n    34: h263\n    96: mpeg_ps\n"
  },
  {
    "id": "ksy_rtpdump",
    "name": "Rtpdump (rtptools)",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [
        "rtp",
        "rtpdump"
      ],
      "description": "Rtpdump (rtptools)",
      "originalCategory": "network",
      "filePath": "network/rtpdump.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: rtpdump\n  title: Rtpdump (rtptools)\n  file-extension:\n    - rtp\n    - rtpdump\n  license: Unlicense\n  imports:\n    - /network/rtp_packet\n  endian: be\ndoc: |\n  rtpdump is a format used by rtptools to record and replay\n  rtp data from network capture.\ndoc-ref: https://chromium.googlesource.com/external/webrtc/stable/talk/+/master/media/base/rtpdump.h\nseq:\n  - id: file_header\n    type: header_t\n  - id: packets\n    type: packet_t\n    repeat: eos\ntypes:\n  header_t:\n    seq:\n      - id: shebang\n        contents: '#!rtpplay1.0'\n      - id: space\n        contents: ' '\n      - id: ip\n        type: str\n        encoding: ascii\n        terminator: 0x2f # '/'\n      - id: port\n        type: str\n        encoding: ascii\n        terminator: 0x0a # '\\n'\n      - id: start_sec\n        type: u4\n        doc: |\n          start of recording, the seconds part.\n      - id: start_usec\n        type: u4\n        doc: |\n          start of recording, the microseconds part.\n      - id: ip2\n        type: u4\n        doc: |\n          network source.\n      - id: port2\n        type: u2\n        doc: |\n          port.\n      - id: padding\n        type: u2\n        doc: |\n          2 bytes padding.\n  packet_t:\n    seq:\n      - id: length\n        type: u2\n        doc: |\n          packet length (including this header).\n      - id: len_body\n        type: u2\n        doc: |\n          payload length.\n      - id: packet_usec\n        type: u4\n        doc: |\n          timestamp of packet since the start.\n      - id: body\n        size: len_body\n        type: rtp_packet\n"
  },
  {
    "id": "ksy_some_ip",
    "name": "AUTOSAR SOME/IP",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "AUTOSAR SOME/IP",
      "originalCategory": "network",
      "filePath": "network/some_ip/some_ip.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: some_ip\n  title: AUTOSAR SOME/IP\n  license: CC0-1.0\n  ks-version: 0.9\n  endian: be\n  imports:\n    - /network/some_ip/some_ip_sd\n\ndoc: |\n  SOME/IP (Scalable service-Oriented MiddlewarE over IP) is an automotive/embedded\n  communication protocol which supports remoteprocedure calls, event notifications\n  and the underlying serialization/wire format.\n\ndoc-ref: https://www.autosar.org/fileadmin/standards/foundation/19-11/AUTOSAR_PRS_SOMEIPProtocol.pdf\n\nseq:\n  - id: header\n    type: header\n  - id: payload\n    size: header.length - 8\n    type:\n      switch-on: header.message_id.value\n      cases:\n        0xffff8100: some_ip_sd\n\ntypes:\n  header:\n    seq:\n      - id: message_id\n        type: message_id\n        size: 4\n        doc: |\n          The Message ID shall be a 32 Bit identifier that is used to identify\n          the RPC call to a method of an application or to identify an event.\n      - id: length\n        type: u4\n        doc: |\n          [PRS_SOMEIP_00042] Length field shall contain the length in Byte\n          starting from Request ID/Client ID until the end of the SOME/IP message.\n      - id: request_id\n        type: request_id\n        size: 4\n        doc: |\n          The Request ID allows a provider and subscriber to differentiate\n          multiple parallel uses of the same method, event, getter or setter.\n      - id: protocol_version\n        type: u1\n        doc: |\n          The Protocol Version identifies the used SOME/IP Header format\n          (not including the Payload format).\n      - id: interface_version\n        type: u1\n        doc: |\n          Interface Version shall be an 8 Bit field that contains the\n          MajorVersion of the Service Interface.\n      - id: message_type\n        type: u1\n        enum: message_type_enum\n        doc: |\n          The Message Type field is used to differentiate different types of\n          messages.\n        doc-ref: AUTOSAR_PRS_SOMEIPProtocol.pdf - Table 4.4\n      - id: return_code\n        type: u1\n        enum: return_code_enum\n        doc: |\n          The Return Code shall be used to signal whether a request was\n          successfully processed.\n        doc-ref: AUTOSAR_PRS_SOMEIPProtocol.pdf - Table 4.5\n\n    types:\n      message_id:\n        seq:\n          - id: service_id\n            type: u2\n            doc: Service ID\n          - id: sub_id\n            type: b1\n            doc: Single bit to flag, if there is a Method or a Event ID\n          - id: method_id\n            type: b15\n            if: sub_id == false\n            doc: Method ID\n            doc-ref: AUTOSAR_PRS_SOMEIPProtocol.pdf - Table 4.1.\n          - id: event_id\n            type: b15\n            if: sub_id == true\n            doc: Event ID\n            doc-ref: AUTOSAR_PRS_SOMEIPProtocol.pdf - Table 4.6\n        doc: |\n          [PRS_SOMEIP_00035] The assignment of the Message ID shall be up to\n          the user. However, the Message ID shall be unique for the whole\n          system (i.e. the vehicle). TheMessage ID is similar to a CAN ID and\n          should be handled via a comparable process.\n          [PRS_SOMEIP_00038] Message IDs of method calls shall be structured in\n          the ID with 2^16 services with 2^15 methods.\n        doc-ref: AUTOSAR_PRS_SOMEIPProtocol.pdf 4.1.1.1  Message ID\n\n        instances:\n          value:\n            pos: 0\n            type: u4\n            doc: The value provides the undissected Message ID\n\n      request_id:\n        seq:\n          - id: client_id\n            type: u2\n          - id: session_id\n            type: u2\n        doc: |\n          The Request ID allows a provider and subscriber to differentiate\n          multiple parallel usesof the same method, event, getter or setter.\n        doc-ref: AUTOSAR_PRS_SOMEIPProtocol.pdf - section 4.1.1.3  Request ID\n\n        instances:\n          value:\n            pos: 0\n            type: u4\n            doc: The value provides the undissected Request ID\n\n    instances:\n      is_valid_service_discovery:\n        value: message_id.value == 0xffff8100 and protocol_version == 0x01 and interface_version == 0x01 and message_type == message_type_enum::notification and return_code == return_code_enum::ok\n        doc: auxillary value\n        doc-ref: AUTOSAR_PRS_SOMEIPServiceDiscoveryProtocol.pdf - section 4.1.2.1 General Requirements\n\n    enums:\n      message_type_enum:\n        0x00 : request\n        0x01 : request_no_return\n        0x02 : notification\n        0x40 : request_ack\n        0x41 : request_no_return_ack\n        0x42 : notification_ack\n        0x80 : response\n        0x81 : error\n        0xc0 : response_ack\n        0xc1 : error_ack\n\n      return_code_enum:\n        0x00 : ok\n        0x01 : not_ok\n        0x02 : unknown_service\n        0x03 : unknown_method\n        0x04 : not_ready\n        0x05 : not_reachable\n        0x06 : time_out\n        0x07 : wrong_protocol_version\n        0x08 : wrong_interface_version\n        0x09 : malformed_message\n        0x0a : wrong_message_type\n"
  },
  {
    "id": "ksy_some_ip_container",
    "name": "AUTOSAR SOME/IP container",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "AUTOSAR SOME/IP container",
      "originalCategory": "network",
      "filePath": "network/some_ip/some_ip_container.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: some_ip_container\n  title: AUTOSAR SOME/IP container\n  license: CC0-1.0\n  ks-version: 0.9\n  endian: be\n  imports:\n    - /network/some_ip/some_ip\n\nseq:\n  - id: some_ip_packages\n    type: some_ip\n    repeat: eos\n"
  },
  {
    "id": "ksy_some_ip_sd",
    "name": "AUTOSAR SOME/IP Service Discovery",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "AUTOSAR SOME/IP Service Discovery",
      "originalCategory": "network",
      "filePath": "network/some_ip/some_ip_sd.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: some_ip_sd\n  title: AUTOSAR SOME/IP Service Discovery\n  license: CC0-1.0\n  ks-version: 0.9\n  endian: be\n  imports:\n    - /network/some_ip/some_ip_sd_entries\n    - /network/some_ip/some_ip_sd_options\n\ndoc: |\n  The main tasks of the Service Discovery Protocol are communicating the\n  availability of functional entities called services in the in-vehicle\n  communication as well as controlling the send behavior of event messages.\n  This allows sending only event messages to receivers requiring them (Publish/Subscribe).\n  The solution described here is also known as SOME/IP-SD\n  (Scalable service-Oriented MiddlewarE over IP - Service Discovery).\ndoc-ref: https://www.autosar.org/fileadmin/standards/foundation/19-11/AUTOSAR_PRS_SOMEIPServiceDiscoveryProtocol.pdf\n\nseq:\n  - id: flags\n    type: sd_flags\n    doc: The SOME/IP-SD Header shall start with an 8 Bit field called flags.\n  - id: reserved\n    size: 3\n  - id: len_entries\n    type: u4\n  - id: entries\n    type: some_ip_sd_entries\n    size: len_entries\n  - id: len_options\n    type: u4\n  - id: options\n    type: some_ip_sd_options\n    size: len_options\n\ntypes:\n  sd_flags:\n    seq:\n      - id: reboot\n        type: b1\n      - id: unicast\n        type: b1\n      - id: initial_data\n        type: b1\n      - id: reserved\n        type: b5\n    doc-ref: AUTOSAR_PRS_SOMEIPServiceDiscoveryProtocol.pdf - Figure 4.3\n"
  },
  {
    "id": "ksy_some_ip_sd_entries",
    "name": "AUTOSAR SOME/IP Service Discovery Entries",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "AUTOSAR SOME/IP Service Discovery Entries",
      "originalCategory": "network",
      "filePath": "network/some_ip/some_ip_sd_entries.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: some_ip_sd_entries\n  title: AUTOSAR SOME/IP Service Discovery Entries\n  license: CC0-1.0\n  ks-version: 0.9\n  endian: be\n\ndoc: |\n  The entries are used to synchronize the state of services instances and the\n  Publish/-Subscribe handling.\ndoc-ref: |\n  https://www.autosar.org/fileadmin/standards/foundation/19-11/AUTOSAR_PRS_SOMEIPServiceDiscoveryProtocol.pdf\n  - section 4.1.2.3  Entry Format\n\nseq:\n  - id: entries\n    type: sd_entry\n    repeat: eos\n\ntypes:\n  sd_entry:\n    seq:\n    - id: header\n      type: sd_entry_header\n    - id: content\n      type:\n        switch-on: header.type\n        cases:\n          entry_types::find : sd_service_entry\n          entry_types::offer : sd_service_entry\n          entry_types::subscribe : sd_eventgroup_entry\n          entry_types::subscribe_ack : sd_eventgroup_entry\n\n    types:\n      sd_entry_header:\n        seq:\n          - id: type\n            type: u1\n            enum: entry_types\n          - id: index_first_options\n            type: u1\n          - id: index_second_options\n            type: u1\n          - id: number_first_options\n            type: b4\n          - id: number_second_options\n            type: b4\n          - id: service_id\n            type: u2\n          - id: instance_id\n            type: u2\n          - id: major_version\n            type: u1\n          - id: ttl\n            type: b24\n\n      sd_service_entry:\n        seq:\n          - id: minor_version\n            type: u4\n\n      sd_eventgroup_entry:\n        seq:\n          - id: reserved\n            type: u1\n          - id: initial_data_requested\n            type: b1\n          - id: reserved2\n            type: b3\n          - id: counter\n            type: b4\n          - id: event_group_id\n            type: u2\n\n    enums:\n      entry_types:\n        0x00 : find\n        0x01 : offer\n        0x06 : subscribe\n        0x07 : subscribe_ack\n"
  },
  {
    "id": "ksy_some_ip_sd_options",
    "name": "AUTOSAR SOME/IP Service Discovery Options",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "AUTOSAR SOME/IP Service Discovery Options",
      "originalCategory": "network",
      "filePath": "network/some_ip/some_ip_sd_options.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: some_ip_sd_options\n  title: AUTOSAR SOME/IP Service Discovery Options\n  license: CC0-1.0\n  ks-version: 0.9\n  endian: be\n\ndoc: |\n  FormatOptions are used to transport additional information to the entries.\n  This includes forinstance the information how a service instance is\n  reachable (IP-Address, TransportProtocol, Port Number).\ndoc-ref: |\n  https://www.autosar.org/fileadmin/standards/foundation/19-11/AUTOSAR_PRS_SOMEIPServiceDiscoveryProtocol.pdf\n  - section 4.1.2.4 Options Format\n\nseq:\n  - id: entries\n    type: sd_option\n    repeat: eos\n\ntypes:\n  sd_option:\n    seq:\n    - id: header\n      type: sd_option_header\n    - id: content\n      type:\n        switch-on: header.type\n        cases:\n          option_types::configuration_option : sd_configuration_option\n          option_types::load_balancing_option : sd_load_balancing_option\n          option_types::ipv4_endpoint_option : sd_ipv4_endpoint_option\n          option_types::ipv6_endpoint_option : sd_ipv6_endpoint_option\n          option_types::ipv4_multicast_option : sd_ipv4_multicast_option\n          option_types::ipv6_multicast_option : sd_ipv6_multicast_option\n          option_types::ipv4_sd_endpoint_option : sd_ipv4_sd_endpoint_option\n          option_types::ipv6_sd_endpoint_option : sd_ipv6_sd_endpoint_option\n\n    types:\n      sd_option_header:\n        seq:\n          - id: length\n            type: u2\n          - id: type\n            type: u1\n            enum: option_types\n\n      sd_configuration_option:\n        seq:\n          - id: reserved\n            type: u1\n          - id: configurations\n            type: sd_config_strings_container\n            size: _parent.header.length - 1\n\n      sd_config_strings_container:\n        seq:\n          - id: config_strings\n            type: sd_config_string\n            repeat: eos\n\n      sd_config_string:\n        seq:\n          - id: length\n            type: u1\n          - id: config\n            type: sd_config_kv_pair\n            size: length\n            if: length != 0\n\n      sd_config_kv_pair:\n        seq:\n        - id: key\n          type: str\n          terminator: 0x3D\n          encoding: ASCII\n        - id: value\n          type: str\n          size-eos: true\n          encoding: ASCII\n\n\n      sd_load_balancing_option:\n        seq:\n          - id: reserved\n            type: u1\n          - id: priority\n            type: u2\n          - id: weight\n            type: u2\n\n      sd_ipv4_endpoint_option:\n        seq:\n          - id: reserved\n            type: u1\n          - id: address\n            size: 4\n          - id: reserved2\n            type: u1\n          - id: l4_protocol\n            type: u1\n          - id: port\n            type: u2\n\n      sd_ipv6_endpoint_option:\n        seq:\n          - id: reserved\n            type: u1\n          - id: address\n            size: 16\n          - id: reserved2\n            type: u1\n          - id: l4_protocol\n            type: u1\n          - id: port\n            type: u2\n\n      sd_ipv4_multicast_option:\n        seq:\n          - id: reserved\n            type: u1\n          - id: address\n            size: 4\n          - id: reserved2\n            type: u1\n          - id: l4_protocol\n            type: u1\n          - id: port\n            type: u2\n\n      sd_ipv6_multicast_option:\n        seq:\n          - id: reserved\n            type: u1\n          - id: address\n            size: 16\n          - id: reserved2\n            type: u1\n          - id: l4_protocol\n            type: u1\n          - id: port\n            type: u2\n\n      sd_ipv4_sd_endpoint_option:\n        seq:\n          - id: reserved\n            type: u1\n          - id: address\n            size: 4\n          - id: reserved2\n            type: u1\n          - id: l4_protocol\n            type: u1\n          - id: port\n            type: u2\n\n      sd_ipv6_sd_endpoint_option:\n        seq:\n          - id: reserved\n            type: u1\n          - id: address\n            size: 16\n          - id: reserved2\n            type: u1\n          - id: l4_protocol\n            type: u1\n          - id: port\n            type: u2\n\n    enums:\n      option_types:\n        0x01 : configuration_option\n        0x02 : load_balancing_option\n        0x04 : ipv4_endpoint_option\n        0x06 : ipv6_endpoint_option\n        0x14 : ipv4_multicast_option\n        0x16 : ipv6_multicast_option\n        0x24 : ipv4_sd_endpoint_option\n        0x26 : ipv6_sd_endpoint_option\n"
  },
  {
    "id": "ksy_tcp_segment",
    "name": "TCP (Transmission Control Protocol) segment",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "TCP (Transmission Control Protocol) segment",
      "originalCategory": "network",
      "filePath": "network/tcp_segment.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: tcp_segment\n  title: TCP (Transmission Control Protocol) segment\n  xref:\n    rfc:\n      - 793\n      - 1323\n      - 9293\n    wikidata: Q8803\n  license: CC0-1.0\n  endian: be\n  ks-version: '0.10'\ndoc: |\n  TCP is one of the core Internet protocols on transport layer (AKA\n  OSI layer 4), providing stateful connections with error checking,\n  guarantees of delivery, order of segments and avoidance of duplicate\n  delivery.\nseq:\n  - id: src_port\n    type: u2\n    doc: Source port\n  - id: dst_port\n    type: u2\n    doc: Destination port\n  - id: seq_num\n    type: u4\n    doc: Sequence number\n  - id: ack_num\n    type: u4\n    doc: Acknowledgment number\n  - id: data_offset\n    type: b4\n    doc: Data offset (in 32-bit words from the beginning of this type, normally 32 or can be extended if there are any TCP options or padding is present)\n  - id: reserved\n    type: b4\n  - id: flags\n    type: flags\n  - id: window_size\n    type: u2\n  - id: checksum\n    type: u2\n  - id: urgent_pointer\n    type: u2\n  - id: options\n    size: (data_offset * 4) - 20\n    if: ((data_offset * 4) - 20) != 0\n  - id: body\n    size-eos: true\ntypes:\n  flags:\n    doc: |\n      TCP header flags as defined \"TCP Header Flags\" registry.\n    to-string: |\n      (cwr ? \"|CWR\" : \"\") +\n      (ece ? \"|ECE\" : \"\") +\n      (urg ? \"|URG\" : \"\") +\n      (ack ? \"|ACK\" : \"\") +\n      (psh ? \"|PSH\" : \"\") +\n      (rst ? \"|RST\" : \"\") +\n      (syn ? \"|SYN\" : \"\") +\n      (fin ? \"|FIN\" : \"\")\n    seq:\n      - id: cwr\n        type: b1\n        doc: Congestion Window Reduced\n      - id: ece\n        type: b1\n        doc: ECN-Echo\n      - id: urg\n        type: b1\n        doc: Urgent pointer field is significant\n      - id: ack\n        type: b1\n        doc: Acknowledgment field is significant\n      - id: psh\n        type: b1\n        doc: Push function\n      - id: rst\n        type: b1\n        doc: Reset the connection\n      - id: syn\n        type: b1\n        doc: Synchronize sequence numbers\n      - id: fin\n        type: b1\n        doc: No more data from sender\n"
  },
  {
    "id": "ksy_tls_client_hello",
    "name": "Tls Client Hello",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "",
      "originalCategory": "network",
      "filePath": "network/tls_client_hello.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: tls_client_hello\n  xref:\n    rfc: 5246 # TLS 1.2\n    wikidata: Q206494 # TLS\n  license: MIT\n  endian: be\n\nseq:\n  - id: version\n    type: version\n\n  - id: random\n    type: random\n\n  - id: session_id\n    type: session_id\n\n  - id: cipher_suites\n    type: cipher_suites\n\n  - id: compression_methods\n    type: compression_methods\n\n  - id: extensions\n    type: extensions\n    if: _io.eof == false\n\ntypes:\n  version:\n    seq:\n      - id: major\n        type: u1\n\n      - id: minor\n        type: u1\n\n  random:\n    seq:\n      - id: gmt_unix_time\n        type: u4\n\n      - id: random\n        size: 28\n\n  session_id:\n    seq:\n      - id: len\n        type: u1\n\n      - id: sid\n        size: len\n\n  cipher_suites:\n    seq:\n      - id: len\n        type: u2\n\n      - id: cipher_suites\n        type: u2\n        repeat: expr\n        repeat-expr: len/2\n\n  compression_methods:\n    seq:\n      - id: len\n        type: u1\n\n      - id: compression_methods\n        size: len\n\n  extensions:\n    seq:\n      - id: len\n        type: u2\n\n      - id: extensions\n        type: extension\n        repeat: eos\n\n  extension:\n    seq:\n      - id: type\n        type: u2\n\n      - id: len\n        type: u2\n\n      - id: body\n        size: len\n        type:\n          switch-on: type\n          cases:\n            0: sni\n            16: alpn\n\n  sni:\n    seq:\n      - id: list_length\n        type: u2\n\n      - id: server_names\n        type: server_name\n        repeat: eos\n\n  server_name:\n    seq:\n      - id: name_type\n        type: u1\n\n      - id: length\n        type: u2\n\n      - id: host_name\n        size: length\n\n  alpn:\n    seq:\n      - id: ext_len\n        type: u2\n\n      - id: alpn_protocols\n        type: protocol\n        repeat: eos\n\n  protocol:\n    seq:\n      - id: strlen\n        type: u1\n\n      - id: name\n        size: strlen\n"
  },
  {
    "id": "ksy_udp_datagram",
    "name": "UDP (User Datagram Protocol) datagram",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "UDP (User Datagram Protocol) datagram",
      "originalCategory": "network",
      "filePath": "network/udp_datagram.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: udp_datagram\n  title: UDP (User Datagram Protocol) datagram\n  xref:\n    rfc: 768\n    wikidata: Q11163\n  license: CC0-1.0\n  endian: be\ndoc: |\n  UDP is a simple stateless transport layer (AKA OSI layer 4)\n  protocol, one of the core Internet protocols. It provides source and\n  destination ports, basic checksumming, but provides not guarantees\n  of delivery, order of packets, or duplicate delivery.\nseq:\n  - id: src_port\n    type: u2\n  - id: dst_port\n    type: u2\n  - id: length\n    type: u2\n  - id: checksum\n    type: u2\n  - id: body\n    size: length - 8\n"
  },
  {
    "id": "ksy_websocket",
    "name": "WebSocket",
    "category": "Network",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "WebSocket",
      "originalCategory": "network",
      "filePath": "network/websocket.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: websocket\n  title: WebSocket\n  xref:\n    rfc: 6455\n    wikidata: Q859938\n  license: CC0-1.0\n  endian: be\ndoc: |\n  The WebSocket protocol establishes a two-way communication channel via TCP.\n  Messages are made up of one or more dataframes, and are delineated by\n  frames with the `fin` bit set.\nseq:\n  - id: initial_frame\n    type: initial_frame\n  - id: trailing_frames\n    type: dataframe\n    if: initial_frame.header.finished != true\n    repeat: until\n    repeat-until: _.header.finished\n\ntypes:\n  frame_header:\n    seq:\n      - id: finished\n        -orig-id: fin\n        type: b1\n      - id: reserved\n        -orig-id: 'rsv1, rsv2, rsv3'\n        type: b3\n      - id: opcode\n        enum: opcode\n        type: b4\n      - id: is_masked\n        type: b1\n      - id: len_payload_primary\n        type: b7\n      - id: len_payload_extended_1\n        type: u2\n        if: len_payload_primary == 126\n      - id: len_payload_extended_2\n        type: u4\n        if: len_payload_primary == 127\n      - id: mask_key\n        type: u4\n        if: is_masked\n    instances:\n      len_payload:\n        value: |\n          len_payload_primary <= 125 ? len_payload_primary : (\n            len_payload_primary == 126 ? len_payload_extended_1 : len_payload_extended_2\n          )\n\n  initial_frame:\n    seq:\n      - id: header\n        type: frame_header\n      - id: payload_bytes\n        size: header.len_payload\n        if: 'header.opcode != opcode::text'\n      - id: payload_text\n        size: header.len_payload\n        type: str\n        encoding: UTF-8\n        if: 'header.opcode == opcode::text'\n\n  dataframe:\n    seq:\n      - id: header\n        type: frame_header\n      - id: payload_bytes\n        size: header.len_payload\n        if: '_root.initial_frame.header.opcode != opcode::text'\n      - id: payload_text\n        size: header.len_payload\n        type: str\n        encoding: UTF-8\n        if: '_root.initial_frame.header.opcode == opcode::text'\n\nenums:\n  opcode:\n    0: continuation\n    1: text\n    2: binary\n    3: reserved_3\n    4: reserved_4\n    5: reserved_5\n    6: reserved_6\n    7: reserved_7\n    8: close\n    9: ping\n    0xA: pong\n    0xB: reserved_control_b\n    0xC: reserved_control_c\n    0xD: reserved_control_d\n    0xE: reserved_control_e\n    0xF: reserved_control_f\n"
  }
];

export default {
  category: "Network",
  formats: networkFormats
};
