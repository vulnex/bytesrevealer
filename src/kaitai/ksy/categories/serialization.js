/**
 * Kaitai Formats - Serialization
 * 9 formats
 * Auto-generated: 2025-09-21T19:51:05.642Z
 */

export const serializationFormats = [
  {
    "id": "ksy_asn1_der",
    "name": "ASN.1 DER (Abstract Syntax Notation One, Distinguished Encoding Rules)",
    "category": "Serialization",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [
        "der"
      ],
      "description": "ASN.1 DER (Abstract Syntax Notation One, Distinguished Encoding Rules)",
      "originalCategory": "serialization",
      "filePath": "serialization/asn1/asn1_der.ksy"
    },
    "content": "meta:\n  id: asn1_der\n  title: ASN.1 DER (Abstract Syntax Notation One, Distinguished Encoding Rules)\n  file-extension: der\n  xref:\n    justsolve: DER\n    wikidata: Q28600469\n  license: CC0-1.0\ndoc: |\n  ASN.1 (Abstract Syntax Notation One) DER (Distinguished Encoding\n  Rules) is a standard-backed serialization scheme used in many\n  different use-cases. Particularly popular usage scenarios are X.509\n  certificates and some telecommunication / networking protocols.\n\n  DER is self-describing encoding scheme which allows representation\n  of simple, atomic data elements, such as strings and numbers, and\n  complex objects, such as sequences of other elements.\n\n  DER is a subset of BER (Basic Encoding Rules), with an emphasis on\n  being non-ambiguous: there's always exactly one canonical way to\n  encode a data structure defined in terms of ASN.1 using DER.\n\n  This spec allows full parsing of format syntax, but to understand\n  the semantics, one would typically require a dictionary of Object\n  Identifiers (OIDs), to match OID bodies against some human-readable\n  list of constants. OIDs are covered by many different standards,\n  so typically it's simpler to use a pre-compiled list of them, such\n  as:\n\n  * <https://www.cs.auckland.ac.nz/~pgut001/dumpasn1.cfg>\n  * <http://oid-info.com/>\n  * <https://www.alvestrand.no/objectid/top.html>\ndoc-ref: https://www.itu.int/itu-t/recommendations/rec.aspx?rec=12483&lang=en\n-webide-representation: 't={type_tag}, b={body}'\nseq:\n  - id: type_tag\n    type: u1\n    enum: type_tag\n  - id: len\n    type: len_encoded\n  - id: body\n    size: len.result\n    type:\n      switch-on: type_tag\n      cases:\n        'type_tag::object_id': body_object_id\n        'type_tag::sequence_10': body_sequence\n        'type_tag::sequence_30': body_sequence\n        'type_tag::set': body_sequence\n        'type_tag::utf8string': body_utf8string\n        'type_tag::printable_string': body_printable_string\ntypes:\n  len_encoded:\n    -webide-representation: 'v={result:dec}'\n    seq:\n      - id: b1\n        type: u1\n      - id: int2\n        type: u2be\n        if: b1 == 0x82\n      - id: int1\n        type: u1\n        if: b1 == 0x81\n    instances:\n      result:\n        value: '(b1 == 0x81) ? int1 : ((b1 == 0x82) ? int2 : b1)'\n        -webide-parse-mode: eager\n  body_sequence:\n    -webide-representation: '[...]'\n    seq:\n      - id: entries\n        type: asn1_der\n        repeat: eos\n  body_utf8string:\n    -webide-representation: '{str}'\n    seq:\n      - id: str\n        type: str\n        size-eos: true\n        encoding: UTF-8\n  body_printable_string:\n    -webide-representation: '{str}'\n    seq:\n      - id: str\n        type: str\n        size-eos: true\n        encoding: ASCII # actually a subset of ASCII\n  body_object_id:\n    -webide-representation: '{first:dec}.{second:dec}.{rest}'\n    doc-ref: https://learn.microsoft.com/en-us/windows/win32/seccertenroll/about-object-identifier\n    seq:\n      - id: first_and_second\n        type: u1\n      - id: rest\n        size-eos: true\n    instances:\n      first:\n        value: first_and_second / 40\n      second:\n        value: first_and_second % 40\nenums:\n  type_tag:\n    0: end_of_content\n    0x1: boolean\n    0x2: integer\n    0x3: bit_string\n    0x4: octet_string\n    0x5: null_value\n    0x6: object_id\n    0x7: object_descriptor\n    0x8: external\n    0x9: real\n    0xa: enumerated\n    0xb: embedded_pdv\n    0xc: utf8string\n    0xd: relative_oid\n    0x10: sequence_10\n    0x13: printable_string\n    0x16: ia5string\n    0x30: sequence_30\n    0x31: set\n"
  },
  {
    "id": "ksy_bson",
    "name": "Bson",
    "category": "Serialization",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [
        "bson"
      ],
      "description": "",
      "originalCategory": "serialization",
      "filePath": "serialization/bson.ksy",
      "signature": {
        "offset": 0,
        "bytes": [
          0
        ]
      },
      "endian": "le"
    },
    "content": "meta:\n  id: bson\n  file-extension: bson\n  xref:\n    justsolve: BSON\n    mime: application/bson\n    wikidata: Q2661480\n  license: CC0-1.0\n  endian: le\ndoc: >\n  BSON, short for Binary JSON, is a binary-encoded serialization of JSON-like documents. Like JSON, BSON supports the embedding of documents and arrays within other documents and arrays. BSON also contains extensions that allow representation of data types that are not part of the JSON spec. For example, BSON has a Date type and a BinData type.\n  BSON can be compared to binary interchange formats, like Protocol Buffers. BSON is more \"schemaless\" than Protocol Buffers, which can give it an advantage in flexibility but also a slight disadvantage in space efficiency (BSON has overhead for field names within the serialized data).\n  BSON was designed to have the following three characteristics:\n    * Lightweight. Keeping spatial overhead to a minimum is important for any data representation format, especially when used over the network.\n    * Traversable. BSON is designed to be traversed easily. This is a vital property in its role as the primary data representation for MongoDB.\n    * Efficient. Encoding data to BSON and decoding from BSON can be performed very quickly in most languages due to the use of C data types.\nseq:\n  - id: len\n    type: s4\n    doc: \"Total number of bytes comprising the document.\"\n  - id: fields\n    type: elements_list\n    size: len - 5\n  - id: terminator\n    contents: [0]\ntypes:\n  code_with_scope:\n    seq:\n      - id: id\n        type: s4\n      - id: source\n        type: string\n      - id: scope\n        type: bson\n        doc: \"mapping from identifiers to values, representing the scope in which the string should be evaluated.\"\n  elements_list:\n    seq:\n      - id: elements\n        type: element\n        repeat: eos\n  reg_ex:\n    seq:\n      - id: pattern\n        type: cstring\n      - id: options\n        type: cstring\n  string:\n    seq:\n      - id: len\n        type: s4\n      - id: str\n        type: str\n        encoding: UTF-8\n        size: len-1\n      - id: terminator\n        contents: [0]\n  cstring:\n    seq:\n      - id: str\n        type: strz\n        encoding: UTF-8\n        doc: \"MUST NOT contain '\\\\x00', hence it is not full UTF-8.\"\n  f16:\n    doc: \"128-bit IEEE 754-2008 decimal floating point\"\n    seq:\n      - id: str\n        type: b1\n      - id: exponent\n        type: b15\n      - id: significand_hi\n        type: b49\n      - id: significand_lo\n        type: u8\n  object_id:\n    doc-ref: https://www.mongodb.com/docs/manual/reference/method/ObjectId/\n    seq:\n      - id: epoch_time\n        type: u4\n        doc: \"seconds since the Unix epoch\"\n      - id: machine_id\n        type: u3\n      - id: process_id\n        type: u2\n      - id: counter\n        type: u3\n        doc: \"counter, starting with a random value.\"\n  db_pointer:\n    seq:\n      - id: namespace\n        type: string\n      - id: id\n        type: object_id\n  timestamp:\n    doc: \"Special internal type used by MongoDB replication and sharding. First 4 bytes are an increment, second 4 are a timestamp.\"\n    seq:\n      - id: increment\n        type: u4\n      - id: timestamp\n        type: u4\n  bin_data:\n    doc: \"The BSON \\\"binary\\\" or \\\"BinData\\\" datatype is used to represent arrays of bytes. It is somewhat analogous to the Java notion of a ByteArray. BSON binary values have a subtype. This is used to indicate what kind of data is in the byte array. Subtypes from zero to 127 are predefined or reserved. Subtypes from 128-255 are user-defined.\"\n    seq:\n      - id: len\n        type: s4\n      - id: subtype\n        type: u1\n        enum: subtype\n      - id: content\n        size: len\n        type:\n          switch-on: subtype\n          cases:\n            'subtype::byte_array_deprecated': byte_array_deprecated\n    types:\n      byte_array_deprecated:\n        doc: \"The BSON \\\"binary\\\" or \\\"BinData\\\" datatype is used to represent arrays of bytes. It is somewhat analogous to the Java notion of a ByteArray. BSON binary values have a subtype. This is used to indicate what kind of data is in the byte array. Subtypes from zero to 127 are predefined or reserved. Subtypes from 128-255 are user-defined.\"\n        seq:\n          - id: len\n            type: s4\n          - id: content\n            size: len\n    enums:\n      subtype:\n        0x00: generic #Generic binary subtype\n        0x01: function\n        0x02: byte_array_deprecated #This used to be the default subtype, but was deprecated in favor of \\\\x00. Drivers and tools should be sure to handle \\\\x02 appropriately. The structure of the binary data (the byte* array in the binary non-terminal) must be an int32 followed by a (byte*). The int32 is the number of bytes in the repetition.\n        0x03: uuid_deprecated #This used to be the UUID subtype, but was deprecated in favor of \\\\x04. Drivers and tools for languages with a native UUID type should handle \\\\x03 appropriately.\n        0x04: uuid\n        0x05: md5\n        0x80: custom #\\\\x80-\\\\xFF \"User defined\" subtypes. The binary data can be anything.\n  element:\n    seq:\n      - id: type_byte\n        type: u1\n        enum: bson_type\n      - id: name\n        type: cstring\n      - id: content\n        #if: \"(type!=type::undefined && type!=type::null && type!=type::min_key && type!=type::max_key)\"\n        type:\n          switch-on: type_byte\n          cases:\n            'bson_type::number_double': f8\n            'bson_type::string': string\n            'bson_type::document': bson\n            'bson_type::array': bson\n            'bson_type::bin_data': bin_data\n            'bson_type::object_id': object_id\n            'bson_type::boolean': u1\n            'bson_type::utc_datetime': s8 #The int64 is UTC milliseconds since the Unix epoch.\n            'bson_type::reg_ex': reg_ex\n            'bson_type::db_pointer': db_pointer\n            'bson_type::javascript': string\n            'bson_type::symbol': string # a programming language (e.g., Python) symbol\n            'bson_type::code_with_scope': code_with_scope\n            'bson_type::number_int': s4\n            'bson_type::timestamp': timestamp\n            'bson_type::number_long': s8\n            'bson_type::number_decimal': f16\n    enums:\n      bson_type:\n        0x00: end_of_object\n        0x01: number_double\n        0x02: string\n        0x03: document\n        0x04: array #The document for an array is a normal BSON document with integer values for the keys, starting with 0 and continuing sequentially. For example, the array ['red', 'blue'] would be encoded as the document {'0': 'red', '1': 'blue'}. The keys must be in ascending numerical order.\n        0x05: bin_data #This is the most commonly used binary subtype and should be the 'default' for drivers and tools.\n        0x06: undefined\n        0x07: object_id\n        0x08: boolean\n        0x09: utc_datetime\n        0x0a: jst_null\n        0x0b: reg_ex\n        0x0c: db_pointer\n        0x0d: javascript\n        0x0e: symbol\n        0x0f: code_with_scope\n        0x10: number_int\n        0x11: timestamp\n        0x12: number_long\n        0x13: number_decimal\n        0x7f: max_key #Special type which compares higher than all other possible BSON element values.\n        -1: min_key #Special type which compares lower than all other possible BSON element values.\n  u3:\n    doc: |\n      Implements unsigned 24-bit (3 byte) integer.\n    seq:\n      - id: b1\n        type: u1\n      - id: b2\n        type: u1\n      - id: b3\n        type: u1\n    instances:\n      value:\n        value: 'b1 | (b2 << 8) | (b3 << 16)'\n"
  },
  {
    "id": "ksy_chrome_pak",
    "name": "Chrome PAK serialization format",
    "category": "Serialization",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [
        "pak"
      ],
      "description": "Chrome PAK serialization format",
      "originalCategory": "serialization",
      "filePath": "serialization/chrome_pak.ksy",
      "endian": "le"
    },
    "content": "meta:\n  id: chrome_pak\n  title: Chrome PAK serialization format\n  file-extension: pak\n  tags:\n    - archive\n    - serialization\n  license: CC0-1.0\n  endian: le\ndoc: |\n  Format mostly used by Google Chrome and various Android apps to store\n  resources such as translated strings, help messages and images.\ndoc-ref:\n  - https://web.archive.org/web/20220126211447/https://dev.chromium.org/developers/design-documents/linuxresourcesandlocalizedstrings # version 4\n  - https://chromium.googlesource.com/chromium/src/tools/grit/+/3c36f27/grit/format/data_pack.py # version 4\n  - https://chromium.googlesource.com/chromium/src/tools/grit/+/8a23eae/grit/format/data_pack.py # version 5\nseq:\n  - id: version\n    type: u4\n    valid:\n      any-of: [4, 5]\n    doc: only versions 4 and 5 are supported\n  - id: num_resources_v4\n    type: u4\n    if: version == 4\n  - id: encoding\n    type: u1\n    enum: encodings\n    doc: |\n      Character encoding of all text resources in the PAK file. Note that\n      the file can **always** contain binary resources, this only applies to\n      those that are supposed to hold text.\n\n      In practice, this will probably always be `encodings::utf8` - I haven't\n      seen any organic file that would state otherwise. `UTF8` is also usually\n      hardcoded in Python scripts from the GRIT repository that generate .pak\n      files (for example\n      [`pak_util.py:79`](https://chromium.googlesource.com/chromium/src/tools/grit/+/8a23eae/pak_util.py#79)).\n  - id: v5_part\n    type: header_v5_part\n    if: version == 5\n  - id: resources\n    type: resource(_index, _index < num_resources)\n    repeat: expr\n    repeat-expr: num_resources + 1\n    doc: |\n      The length is calculated by looking at the offset of\n      the next item, so an extra entry is stored with id 0\n      and offset pointing to the end of the resources.\n  - id: aliases\n    type: alias\n    repeat: expr\n    repeat-expr: num_aliases\ninstances:\n  num_resources:\n    value: 'version == 5 ? v5_part.num_resources : num_resources_v4'\n  num_aliases:\n    value: 'version == 5 ? v5_part.num_aliases : 0'\ntypes:\n  header_v5_part:\n    seq:\n      - id: encoding_padding\n        size: 3\n      - id: num_resources\n        type: u2\n      - id: num_aliases\n        type: u2\n  resource:\n    -webide-representation: '{id:dec} - o:{ofs_body} s:{len_body}'\n    params:\n      - id: idx\n        type: s4\n      - id: has_body\n        type: bool\n    seq:\n      - id: id\n        type: u2\n      - id: ofs_body\n        type: u4\n    instances:\n      len_body:\n        value: _parent.resources[idx + 1].ofs_body - ofs_body\n        if: has_body\n        doc: MUST NOT be accessed until the next `resource` is parsed\n      body:\n        pos: ofs_body\n        size: len_body\n        if: has_body\n        doc: MUST NOT be accessed until the next `resource` is parsed\n  alias:\n    -webide-representation: '{id:dec} -> resources[{resource_idx:dec}] ({resource})'\n    seq:\n      - id: id\n        type: u2\n      - id: resource_idx\n        type: u2\n        valid:\n          max: _parent.num_resources - 1\n    instances:\n      resource:\n        value: _parent.resources[resource_idx]\nenums:\n  encodings:\n    0:\n      id: binary\n      doc: file is not expected to contain any text resources\n    1:\n      id: utf8\n      doc: all text resources are encoded in UTF-8\n    2:\n      id: utf16\n      doc: all text resources are encoded in UTF-16\n"
  },
  {
    "id": "ksy_google_protobuf",
    "name": "Google Protocol Buffers (protobuf)",
    "category": "Serialization",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "Google Protocol Buffers (protobuf)",
      "originalCategory": "serialization",
      "filePath": "serialization/google_protobuf.ksy"
    },
    "content": "meta:\n  id: google_protobuf\n  title: Google Protocol Buffers (protobuf)\n  xref:\n    justsolve: Protobuf\n    wikidata: Q1645574\n  license: MIT\n  ks-version: 0.7\n  imports:\n    - /common/vlq_base128_le\ndoc: |\n  Google Protocol Buffers (AKA protobuf) is a popular data\n  serialization scheme used for communication protocols, data storage,\n  etc. There are implementations are available for almost every\n  popular language. The focus points of this scheme are brevity (data\n  is encoded in a very size-efficient manner) and extensibility (one\n  can add keys to the structure, while keeping it readable in previous\n  version of software).\n\n  Protobuf uses semi-self-describing encoding scheme for its\n  messages. It means that it is possible to parse overall structure of\n  the message (skipping over fields one can't understand), but to\n  fully understand the message, one needs a protocol definition file\n  (`.proto`). To be specific:\n\n  * \"Keys\" in key-value pairs provided in the message are identified\n    only with an integer \"field tag\". `.proto` file provides info on\n    which symbolic field names these field tags map to.\n  * \"Keys\" also provide something called \"wire type\". It's not a data\n    type in its common sense (i.e. you can't, for example, distinguish\n    `sint32` vs `uint32` vs some enum, or `string` from `bytes`), but\n    it's enough information to determine how many bytes to\n    parse. Interpretation of the value should be done according to the\n    type specified in `.proto` file.\n  * There's no direct information on which fields are optional /\n    required, which fields may be repeated or constitute a map, what\n    restrictions are placed on fields usage in a single message, what\n    are the fields' default values, etc, etc.\ndoc-ref: https://protobuf.dev/programming-guides/encoding/\nseq:\n  - id: pairs\n    type: pair\n    repeat: eos\n    doc: Key-value pairs which constitute a message\ntypes:\n  pair:\n    doc: Key-value pair\n    seq:\n      - id: key\n        type: vlq_base128_le\n        doc: |\n          Key is a bit-mapped variable-length integer: lower 3 bits\n          are used for \"wire type\", and everything higher designates\n          an integer \"field tag\".\n      - id: value\n        doc: |\n          Value that corresponds to field identified by\n          `field_tag`. Type is determined approximately: there is\n          enough information to parse it unambiguously from a stream,\n          but further infromation from `.proto` file is required to\n          interprete it properly.\n        type:\n          switch-on: wire_type\n          cases:\n            'wire_types::varint': vlq_base128_le\n            'wire_types::len_delimited': delimited_bytes\n            'wire_types::bit_64': u8le\n            'wire_types::bit_32': u4le\n    instances:\n      wire_type:\n        value: 'key.value & 0b111'\n        enum: wire_types\n        doc: |\n          \"Wire type\" is a part of the \"key\" that carries enough\n          information to parse value from the wire, i.e. read correct\n          amount of bytes, but there's not enough informaton to\n          interprete in unambiguously. For example, one can't clearly\n          distinguish 64-bit fixed-sized integers from 64-bit floats,\n          signed zigzag-encoded varints from regular unsigned varints,\n          arbitrary bytes from UTF-8 encoded strings, etc.\n      field_tag:\n        value: 'key.value >> 3'\n        doc: |\n          Identifies a field of protocol. One can look up symbolic\n          field name in a `.proto` file by this field tag.\n    enums:\n      wire_types:\n        0: varint\n        1: bit_64\n        2: len_delimited\n        3: group_start\n        4: group_end\n        5: bit_32\n  delimited_bytes:\n    seq:\n      - id: len\n        type: vlq_base128_le\n      - id: body\n        size: len.value\n"
  },
  {
    "id": "ksy_microsoft_cfb",
    "name": "Microsoft Compound File Binary (CFB), AKA OLE (Object Linking and Embedding) file format",
    "category": "Serialization",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "Microsoft Compound File Binary (CFB), AKA OLE (Object Linking and Embedding) file format",
      "originalCategory": "serialization",
      "filePath": "serialization/microsoft_cfb.ksy",
      "endian": "le"
    },
    "content": "meta:\n  id: microsoft_cfb\n  title: Microsoft Compound File Binary (CFB), AKA OLE (Object Linking and Embedding) file format\n  xref:\n    justsolve: Microsoft_Compound_File\n    loc:\n      - fdd000380 # CFB 3\n      - fdd000392 # CFB 4\n    wikidata: Q5156830\n  license: CC0-1.0\n  endian: le\nseq:\n  - id: header\n    type: cfb_header\ninstances:\n  sector_size:\n    value: '1 << header.sector_shift'\n  fat:\n    pos: sector_size\n    size: header.size_fat * sector_size\n    type: fat_entries\n  dir:\n    pos: (header.ofs_dir + 1) * sector_size\n    type: dir_entry\ntypes:\n  cfb_header:\n    seq:\n      - id: signature\n        contents: [0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1]\n        doc: Magic bytes that confirm that this is a CFB file\n      - id: clsid\n        contents: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n        doc: Reserved class ID field, must be all 0\n      - id: version_minor\n        type: u2\n      - id: version_major\n        type: u2\n      - id: byte_order\n        contents: [0xfe, 0xff]\n        doc: In theory, specifies a byte order. In practice, no other values besides FE FF (which imply little endian order) are used.\n      - id: sector_shift\n        type: u2\n        doc: For major version 3, must be 0x9 (sector size = 512 bytes). For major version 4, must be 0xc (sector size = 4096 bytes).\n      - id: mini_sector_shift\n        type: u2\n      - id: reserved1\n        size: 6\n      - id: size_dir\n        type: s4\n        doc: Number of directory sectors in this file. For major version 3, must be 0.\n      - id: size_fat\n        type: s4\n        doc: Number of FAT sectors in this file.\n      - id: ofs_dir\n        type: s4\n        doc: Starting sector number for directory stream.\n      - id: transaction_seq\n        type: s4\n        doc: A transaction sequence number, which is incremented each time the file is saved if transactions are implemented, 0 otherwise.\n      - id: mini_stream_cutoff_size\n        type: s4\n      - id: ofs_mini_fat\n        type: s4\n        doc: Starting sector number for mini FAT.\n      - id: size_mini_fat\n        type: s4\n        doc: Number of mini FAT sectors in this file.\n      - id: ofs_difat\n        type: s4\n        doc: Starting sector number for DIFAT.\n      - id: size_difat\n        type: s4\n        doc: Number of DIFAT sectors in this file.\n      - id: difat\n        repeat: expr\n        repeat-expr: 109\n        type: s4\n  fat_entries:\n    seq:\n      - id: entries\n        type: s4\n        repeat: eos\n  dir_entry:\n    seq:\n      - id: name\n        type: str\n        size: 64\n        encoding: UTF-16LE\n      - id: name_len\n        type: u2\n      - id: object_type\n        type: u1\n        enum: obj_type\n      - id: color_flag\n        type: u1\n        enum: rb_color\n      - id: left_sibling_id\n        type: s4\n      - id: right_sibling_id\n        type: s4\n      - id: child_id\n        type: s4\n      - id: clsid\n        size: 16\n      - id: state\n        type: u4\n        doc: User-defined flags for storage or root storage objects\n      - id: time_create\n        type: u8\n        doc: Creation time, in Windows FILETIME format (number of 100-nanosecond intervals since January 1, 1601, UTC)\n      - id: time_mod\n        type: u8\n        doc: Modification time, in Windows FILETIME format (number of 100-nanosecond intervals since January 1, 1601, UTC).\n      - id: ofs\n        type: s4\n        doc: For stream object, number of starting sector. For a root storage object, first sector of the mini stream, if the mini stream exists.\n      - id: size\n        type: u8\n        doc: For stream object, size of user-defined data in bytes. For a root storage object, size of the mini stream.\n    instances:\n      mini_stream:\n        io: _root._io\n        pos: (ofs + 1) * _root.sector_size\n        size: size\n        if: object_type == obj_type::root_storage\n      child:\n        io: _root._io\n        pos: (_root.header.ofs_dir + 1) * _root.sector_size + child_id * 0x80 # sizeof<dir_entry>\n        type: dir_entry\n        if: child_id != -1\n      left_sibling:\n        io: _root._io\n        pos: (_root.header.ofs_dir + 1) * _root.sector_size + left_sibling_id * 0x80 # sizeof<dir_entry>\n        type: dir_entry\n        if: left_sibling_id != -1\n      right_sibling:\n        io: _root._io\n        pos: (_root.header.ofs_dir + 1) * _root.sector_size + right_sibling_id * 0x80 # sizeof<dir_entry>\n        type: dir_entry\n        if: right_sibling_id != -1\n    enums:\n      obj_type:\n        0: unknown\n        1: storage\n        2: stream\n        5: root_storage\n      rb_color:\n        0: red\n        1: black\n"
  },
  {
    "id": "ksy_msgpack",
    "name": "MessagePack (msgpack) serialization format",
    "category": "Serialization",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "MessagePack (msgpack) serialization format",
      "originalCategory": "serialization",
      "filePath": "serialization/msgpack.ksy",
      "endian": "be"
    },
    "content": "meta:\n  id: msgpack\n  title: MessagePack (msgpack) serialization format\n  xref:\n    wikidata: Q6821738\n  license: CC0-1.0\n  endian: be\ndoc: |\n  MessagePack (msgpack) is a system to serialize arbitrary structured\n  data into a compact binary stream.\ndoc-ref: https://github.com/msgpack/msgpack/blob/master/spec.md\nseq:\n  - id: b1\n    type: u1\n    doc: |\n      First byte is msgpack message is either a piece of data by\n      itself or determines types of further, more complex data\n      structures.\n  # ========================================================================\n  - id: int_extra\n    type:\n      switch-on: b1\n      cases:\n        0xcc: u1\n        0xcd: u2\n        0xce: u4\n        0xcf: u8\n        0xd0: s1\n        0xd1: s2\n        0xd2: s4\n        0xd3: s8\n  # ========================================================================\n  - id: float_32_value\n    type: f4\n    if: is_float_32\n  - id: float_64_value\n    type: f8\n    if: is_float_64\n  # ========================================================================\n  - id: str_len_8\n    type: u1\n    if: is_str_8\n  - id: str_len_16\n    type: u2\n    if: is_str_16\n  - id: str_len_32\n    type: u4\n    if: is_str_32\n  - id: str_value\n    type: str\n    encoding: UTF-8\n    size: str_len\n    if: is_str\n  # ========================================================================\n  - id: num_array_elements_16\n    type: u2\n    if: is_array_16\n  - id: num_array_elements_32\n    type: u4\n    if: is_array_32\n  - id: array_elements\n    type: msgpack\n    repeat: expr\n    repeat-expr: num_array_elements\n    if: is_array\n  # ========================================================================\n  - id: num_map_elements_16\n    type: u2\n    if: is_map_16\n  - id: num_map_elements_32\n    type: u4\n    if: is_map_32\n  - id: map_elements\n    type: map_tuple\n    repeat: expr\n    repeat-expr: num_map_elements\n    if: is_map\ninstances:\n#  value:\n#    value: >-\n#      is_bool ? bool_value :\n#      is_int ? int_value :\n#      is_array ? array_elements :\n#      0\n  is_nil:\n    value: b1 == 0xc0\n    doc-ref: 'https://github.com/msgpack/msgpack/blob/master/spec.md#formats-nil'\n  # ========================================================================\n  is_bool:\n    value: b1 == 0xc2 or b1 == 0xc3\n  bool_value:\n    value: b1 == 0xc3\n    if: is_bool\n    doc-ref: 'https://github.com/msgpack/msgpack/blob/master/spec.md#formats-bool'\n  # ========================================================================\n  is_pos_int7:\n    value: b1 & 0b1000_0000 == 0\n  pos_int7_value:\n    value: b1\n    if: is_pos_int7\n  is_neg_int5:\n    value: b1 & 0b111_00000 == 0b111_00000\n  neg_int5_value:\n    value: -(b1 & 0b000_11111)\n    if: is_neg_int5\n  is_int:\n    value: is_pos_int7 or is_neg_int5\n  int_value:\n    value: >-\n      is_pos_int7 ? pos_int7_value :\n      is_neg_int5 ? neg_int5_value :\n      0x1337\n    if: is_int\n  # ========================================================================\n  is_float_32:\n    value: b1 == 0xca\n    doc-ref: 'https://github.com/msgpack/msgpack/blob/master/spec.md#formats-float'\n  is_float_64:\n    value: b1 == 0xcb\n    doc-ref: 'https://github.com/msgpack/msgpack/blob/master/spec.md#formats-float'\n  is_float:\n    value: is_float_32 or is_float_64\n  float_value:\n    value: >-\n      is_float_32 ? float_32_value : float_64_value\n    if: is_float\n  # ========================================================================\n  is_fix_str:\n    value: b1 & 0b111_00000 == 0b101_00000\n    doc-ref: 'https://github.com/msgpack/msgpack/blob/master/spec.md#formats-str'\n  is_str_8:\n    value: b1 == 0xd9\n    doc-ref: 'https://github.com/msgpack/msgpack/blob/master/spec.md#formats-str'\n  is_str_16:\n    value: b1 == 0xda\n    doc-ref: 'https://github.com/msgpack/msgpack/blob/master/spec.md#formats-str'\n  is_str_32:\n    value: b1 == 0xdb\n    doc-ref: 'https://github.com/msgpack/msgpack/blob/master/spec.md#formats-str'\n  is_str:\n    value: is_fix_str or is_str_8 or is_str_16 or is_str_32\n  str_len:\n    value: >-\n      is_fix_str ? (b1 & 0b000_11111) :\n      is_str_8 ? str_len_8 :\n      is_str_16 ? str_len_16 :\n      str_len_32\n    if: is_str\n  # ========================================================================\n  is_array:\n    value: is_fix_array or is_array_16 or is_array_32\n    doc-ref: 'https://github.com/msgpack/msgpack/blob/master/spec.md#formats-array'\n  is_fix_array:\n    value: b1 & 0b1111_0000 == 0b1001_0000\n    doc-ref: 'https://github.com/msgpack/msgpack/blob/master/spec.md#formats-array'\n  is_array_16:\n    value: b1 == 0xdc\n    doc-ref: 'https://github.com/msgpack/msgpack/blob/master/spec.md#formats-array'\n  is_array_32:\n    value: b1 == 0xdd\n    doc-ref: 'https://github.com/msgpack/msgpack/blob/master/spec.md#formats-array'\n  num_array_elements:\n    value: >-\n      is_fix_array ? b1 & 0b0000_1111 :\n      is_array_16 ? num_array_elements_16 :\n      num_array_elements_32\n    if: is_array\n    doc-ref: 'https://github.com/msgpack/msgpack/blob/master/spec.md#formats-array'\n  # ========================================================================\n  is_map:\n    value: is_fix_map or is_map_16 or is_map_32\n    doc-ref: 'https://github.com/msgpack/msgpack/blob/master/spec.md#formats-map'\n  is_fix_map:\n    value: b1 & 0b1111_0000 == 0b1000_0000\n    doc-ref: 'https://github.com/msgpack/msgpack/blob/master/spec.md#formats-map'\n  is_map_16:\n    value: b1 == 0xde\n    doc-ref: 'https://github.com/msgpack/msgpack/blob/master/spec.md#formats-map'\n  is_map_32:\n    value: b1 == 0xdf\n    doc-ref: 'https://github.com/msgpack/msgpack/blob/master/spec.md#formats-map'\n  num_map_elements:\n    value: >-\n      is_fix_map ? b1 & 0b0000_1111 :\n      is_map_16 ? num_map_elements_16 :\n      num_map_elements_32\n    if: is_map\n    doc-ref: 'https://github.com/msgpack/msgpack/blob/master/spec.md#formats-map'\ntypes:\n  map_tuple:\n    seq:\n      - id: key\n        type: msgpack\n      - id: value\n        type: msgpack\n"
  },
  {
    "id": "ksy_php_serialized_value",
    "name": "Serialized PHP value",
    "category": "Serialization",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "Serialized PHP value",
      "originalCategory": "serialization",
      "filePath": "serialization/php_serialized_value.ksy"
    },
    "content": "meta:\n  id: php_serialized_value\n  title: Serialized PHP value\n  application: PHP\n  license: CC0-1.0\n  ks-version: 0.9\n  # No endianness, since all numbers are stored as ASCII decimal.\n  # This encoding is only used to parse numbers. All strings, class names, etc.\n  # are treated as raw byte arrays, because PHP strings are byte strings\n  # with no particular encoding.\n  encoding: ASCII\ndoc: |\n  A serialized PHP value, in the format used by PHP's built-in `serialize` and\n  `unserialize` functions. This format closely mirrors PHP's data model:\n  it supports all of PHP's scalar types (`NULL`, booleans, numbers, strings),\n  associative arrays, objects, and recursive data structures using references.\n  The only PHP values not supported by this format are *resources*,\n  which usually correspond to native file or connection handles and cannot be\n  meaningfully serialized.\n\n  There is no official documentation for this data format;\n  this spec was created based on the PHP source code and the behavior of\n  `serialize`/`unserialize`. PHP makes no guarantees about compatibility of\n  serialized data between PHP versions, but in practice, the format has\n  remained fully backwards-compatible - values serialized by an older\n  PHP version can be unserialized on any newer PHP version.\n  This spec supports serialized values from PHP 7.3 or any earlier version.\ndoc-ref:\n  - 'https://www.php.net/manual/en/function.serialize.php'\n  - 'https://www.php.net/manual/en/function.serialize.php#66147'\n  - 'https://www.php.net/manual/en/function.unserialize.php'\n  - 'https://github.com/php/php-src/blob/php-7.3.5/ext/standard/var_unserializer.re'\n  - 'https://github.com/php/php-src/blob/php-7.3.5/ext/standard/var.c#L822'\nseq:\n  - id: type\n    type: u1\n    enum: value_type\n    doc: A single-character code indicating the type of the serialized value.\n  - id: contents\n    type:\n      switch-on: type\n      cases:\n        'value_type::null': null_contents\n        'value_type::bool': bool_contents\n        'value_type::int': int_contents\n        'value_type::float': float_contents\n        'value_type::string': string_contents\n        'value_type::php_6_string': string_contents\n        'value_type::array': array_contents\n        'value_type::php_3_object': php_3_object_contents\n        'value_type::object': object_contents\n        'value_type::custom_serialized_object':\n          custom_serialized_object_contents\n        'value_type::variable_reference': int_contents\n        'value_type::object_reference': int_contents\n    doc: |\n      The contents of the serialized value, which vary depending on the type.\nenums:\n  value_type:\n    0x43: # 'C'\n      id: custom_serialized_object\n      doc: |\n        An `object` whose class implements a custom serialized format using\n        `Serializable`. Available since PHP 5.1.\n    0x4e: # 'N'\n      id: 'null'\n      doc: A `NULL` value.\n    0x4f: # 'O'\n      id: object\n      doc: |\n        An `object` value (including its class name) serialized in the\n        default format. Available since PHP 4.\n    0x52: # 'R'\n      id: variable_reference\n      doc: |\n        An additional reference to a value that has already appeared earlier.\n        Available since PHP 4.0.4.\n    0x53: # 'S'\n      id: php_6_string\n      doc: |\n        A `string` value from PHP 6. PHP 6 was never released, but support for\n        deserializing PHP 6 strings was added in PHP 5.2.1 and is still present\n        as of PHP 7.3. In all versions that support them (other than PHP 6),\n        they are deserialized exactly like regular strings.\n    0x61: # 'a'\n      id: array\n      doc: An `array` value.\n    0x62: # 'b'\n      id: bool\n      doc: A `bool` value. Available since PHP 4.\n    0x64: # 'd'\n      id: float\n      doc: A `float` value.\n    0x69: # 'i'\n      id: int\n      doc: An `int` value.\n    0x6f: # 'o'\n      id: php_3_object\n      doc: |\n        An `object` value (without a class name), as serialized by PHP 3.\n\n        PHP 4 through 7.3 included code to deserialize PHP 3 objects,\n        which has now been removed from the development repo and will likely\n        no longer be included in PHP 7.4. However, apparently this code\n        has been broken ever since it was added - it cannot even deserialize\n        a simple PHP 3 object like `o:0:{}`. If the code worked, PHP 3 objects\n        deserialized under PHP 4 and higher would have the class `stdClass`.\n    0x72: # 'r'\n      id: object_reference\n      doc: |\n        An `object` value which shares its identity with another `object`\n        that has already appeared earlier. Available since PHP 5.\n    0x73: # 's'\n      id: string\n      doc: A `string` value.\n  bool_value:\n    0x30: false # '0'\n    0x31: true # '1'\ntypes:\n  null_contents:\n    doc: |\n      The contents of a null value (`value_type::null`). This structure\n      contains no actual data, since there is only a single `NULL` value.\n    seq:\n      - id: semicolon\n        contents: ';'\n  bool_contents:\n    doc: The contents of a boolean value (`value_type::bool`).\n    seq:\n      - id: colon\n        contents: ':'\n      - id: value_dec\n        type: u1\n        enum: bool_value\n        doc: |\n          The value of the `bool`: `0` for `false` or `1` for `true`.\n      - id: semicolon\n        contents: ';'\n    instances:\n      value:\n        value: 'value_dec == bool_value::true'\n        doc: The value of the `bool`, parsed as a boolean.\n  int_contents:\n    doc: |\n      The contents of an integer-like value:\n      either an actual integer (`value_type::int`) or a reference\n      (`value_type::variable_reference`, `value_type::object_reference`).\n    seq:\n      - id: colon\n        contents: ':'\n      - id: value_dec\n        type: str\n        terminator: 0x3b # ';'\n        doc: The value of the `int`, in ASCII decimal.\n    instances:\n      value:\n        value: value_dec.to_i\n        doc: The value of the `int`, parsed as an integer.\n  float_contents:\n    doc: The contents of a floating-point value.\n    seq:\n      - id: colon\n        contents: ':'\n      - id: value_dec\n        type: str\n        terminator: 0x3b # ';'\n        doc: |\n          The value of the `float`, in ASCII decimal, as generated by PHP's\n          usual double-to-string conversion. In particular, this means that:\n\n          * A decimal point may not be included (for integral numbers)\n          * The number may use exponent notation (e. g. `1.0E+16`)\n          * Positive and negative infinity are represented as `INF`\n            and `-INF`, respectively\n          * Not-a-number is represented as `NAN`\n  length_prefixed_quoted_string:\n    doc: |\n      A quoted string prefixed with its length.\n\n      Despite the quotes surrounding the string data, it can contain\n      arbitrary bytes, which are never escaped in any way.\n      This does not cause any ambiguities when parsing - the bounds of\n      the string are determined only by the length field, not by the quotes.\n    seq:\n      - id: len_data_dec\n        type: str\n        terminator: 0x3a # ':'\n        doc: |\n          The length of the string's data in bytes, in ASCII decimal.\n          The quotes are not counted in this length number.\n      - id: opening_quote\n        contents: '\"'\n      - id: data\n        size: len_data\n        doc: The data contained in the string. The quotes are not included.\n      - id: closing_quote\n        contents: '\"'\n    instances:\n      len_data:\n        value: len_data_dec.to_i\n        doc: |\n          The length of the string's contents in bytes, parsed as an integer.\n          The quotes are not counted in this size number.\n  string_contents:\n    doc: |\n      The contents of a string value.\n\n      Note: PHP strings can contain arbitrary byte sequences.\n      They are not necessarily valid text in any specific encoding.\n    seq:\n      - id: colon\n        contents: ':'\n      - id: string\n        type: length_prefixed_quoted_string\n      - id: semicolon\n        contents: ';'\n    instances:\n      value:\n        value: string.data\n        doc: The value of the string, as a byte array.\n  mapping_entry:\n    doc: A mapping entry consisting of a key and a value.\n    seq:\n      - id: key\n        type: php_serialized_value\n        doc: The key of the entry.\n      - id: value\n        type: php_serialized_value\n        doc: The value of the entry.\n  count_prefixed_mapping:\n    doc: A mapping (a sequence of key-value pairs) prefixed with its size.\n    seq:\n      - id: num_entries_dec\n        type: str\n        terminator: 0x3a # ':'\n        doc: The number of key-value pairs in the mapping, in ASCII decimal.\n      - id: opening_brace\n        contents: '{'\n      - id: entries\n        type: mapping_entry\n        repeat: expr\n        repeat-expr: num_entries\n        doc: The key-value pairs contained in the mapping.\n      - id: closing_brace\n        contents: '}'\n    instances:\n      num_entries:\n        value: num_entries_dec.to_i\n        doc: |\n          The number of key-value pairs in the mapping, parsed as an integer.\n  array_contents:\n    doc: The contents of an array value.\n    seq:\n      - id: colon\n        contents: ':'\n      - id: elements\n        type: count_prefixed_mapping\n        doc: |\n          The array's elements. Keys must be of type `int` or `string`,\n          values may have any type.\n  php_3_object_contents:\n    doc: |\n      The contents of a PHP 3 object value. Unlike its counterpart in PHP 4\n      and above, it does not contain a class name.\n    seq:\n      - id: colon\n        contents: ':'\n      - id: properties\n        type: count_prefixed_mapping\n        doc: |\n          The object's properties. Keys must be of type `string`,\n          values may have any type.\n  object_contents:\n    doc: |\n      The contents of an object value serialized in the default format.\n      Unlike its PHP 3 counterpart, it contains a class name.\n    seq:\n      - id: colon1\n        contents: ':'\n      - id: class_name\n        type: length_prefixed_quoted_string\n        doc: The name of the object's class.\n      - id: colon2\n        contents: ':'\n      - id: properties\n        type: count_prefixed_mapping\n        doc: |\n          The object's properties. Keys ust be of type `string`,\n          values may have any type.\n  custom_serialized_object_contents:\n    doc: |\n      The contents of an object value that implements a custom\n      serialized format using `Serializable`.\n    seq:\n      - id: colon1\n        contents: ':'\n      - id: class_name\n        type: length_prefixed_quoted_string\n        doc: The name of the object's class.\n      - id: colon2\n        contents: ':'\n      - id: len_data_dec\n        type: str\n        terminator: 0x3a # ':'\n        doc: |\n          The length of the serialized data in bytes, in ASCII decimal.\n          The braces are not counted in this size number.\n      - id: opening_brace\n        contents: '{'\n      - id: data\n        size: len_data\n        doc: |\n          The custom serialized data. The braces are not included.\n\n          Although the surrounding braces make it look like a regular\n          serialized object, this field is actually more similar to a string:\n          it can contain arbitrary data that is not required to follow\n          any common structure.\n      - id: closing_quote\n        contents: '}'\n    instances:\n      len_data:\n        value: len_data_dec.to_i\n        doc: |\n          The length of the serialized data in bytes, parsed as an integer.\n          The braces are not counted in this length number.\n"
  },
  {
    "id": "ksy_python_pickle",
    "name": "Python pickle serialization format",
    "category": "Serialization",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [
        "pickle",
        "pkl"
      ],
      "description": "Python pickle serialization format",
      "originalCategory": "serialization",
      "filePath": "serialization/python_pickle.ksy",
      "endian": "le"
    },
    "content": "meta:\n  id: python_pickle\n  title: Python pickle serialization format\n  application: Python\n  file-extension:\n    - pickle\n    - pkl\n  xref:\n    justsolve: Pickle\n    wikidata: Q7190889\n  license: CC0-1.0\n  endian: le\ndoc: |\n  Python Pickle format serializes Python objects to a byte stream, as a sequence\n  of operations to run on the Pickle Virtual Machine.\n\n  The format is mostly implementation defined, there is no formal specification.\n  Pickle data types are closely coupled to the Python object model.\n  Python singletons, and most builtin types (e.g. `None`, `int`,`dict`, `list`)\n  are serialised using dedicated Pickle opcodes.\n  Other builtin types, and all classes  (e.g. `set`, `datetime.datetime`) are\n  serialised by encoding the name of a constructor callable.\n  They are deserialised by importing that constructor, and calling it.\n  So, unpickling an arbitrary pickle, using the Python's stdlib pickle module\n  can cause arbitrary code execution.\n\n  Pickle format has evolved with Python, later protocols add opcodes & types.\n  Later Python releases can pickle to or unpickle from any earlier protocol.\n\n  * Protocol 0: ASCII clean, no explicit version, fields are '\\n' terminated.\n  * Protocol 1: Binary, no explicit version, first length prefixed types.\n  * Protocol 2 ([PEP 307](https://peps.python.org/pep-0307/)): Python 2.3+.\n    Explicit versioning, more length prefixed types.\n  * Protocol 3: Python 3.0+. Dedicated opcodes for `bytes` objects.\n  * Protocol 4 ([PEP 3154](https://peps.python.org/pep-3154/)): Python 3.4+.\n    Opcodes for 64 bit strings, framing, `set`.\n  * Protocol 5 ([PEP 574](https://peps.python.org/pep-0574/)): Python 3.8+:\n  Opcodes for `bytearray` and out of band data\ndoc-ref: https://github.com/python/cpython/blob/v3.8.1/Lib/pickletools.py\nseq:\n  # TODO is there a way to declare PROTO is optional, but only valid at position 0?\n  - id: ops\n    type: op\n    repeat: until\n    repeat-until: _.code == opcode::stop\ntypes:\n  op:\n    seq:\n      - id: code\n        type: u1\n        enum: opcode\n        doc: |\n          Operation code that determines which action should be\n          performed next by the Pickle Virtual Machine. Some opcodes\n          are only available in later versions of the Pickle protocol.\n      - id: arg\n        type:\n          switch-on: code\n          cases:\n            'opcode::int': decimalnl_short\n            'opcode::binint': s4\n            'opcode::binint1': u1\n            'opcode::binint2': u2\n            'opcode::long': decimalnl_long\n            'opcode::long1': long1\n            'opcode::long4': long4\n            'opcode::string': stringnl\n            'opcode::binstring': string4\n            'opcode::short_binstring': string1\n            'opcode::binbytes': bytes4\n            'opcode::short_binbytes': bytes1\n            'opcode::binbytes8': bytes8\n            'opcode::none': no_arg\n            'opcode::newtrue': no_arg\n            'opcode::newfalse': no_arg\n            'opcode::unicode': unicodestringnl\n            'opcode::short_binunicode': unicodestring1\n            'opcode::binunicode': unicodestring4\n            'opcode::binunicode8': unicodestring8\n            'opcode::float': floatnl\n            'opcode::binfloat': f8be\n            'opcode::empty_list': no_arg\n            'opcode::append': no_arg\n            'opcode::appends': no_arg\n            'opcode::list': no_arg\n            'opcode::empty_tuple': no_arg\n            'opcode::tuple': no_arg\n            'opcode::tuple1': no_arg\n            'opcode::tuple2': no_arg\n            'opcode::tuple3': no_arg\n            'opcode::empty_dict': no_arg\n            'opcode::dict': no_arg\n            'opcode::setitem': no_arg\n            'opcode::setitems': no_arg\n            'opcode::empty_set': no_arg\n            'opcode::additems': no_arg\n            'opcode::frozenset': no_arg\n            'opcode::pop': no_arg\n            'opcode::dup': no_arg\n            'opcode::mark': no_arg\n            'opcode::pop_mark': no_arg\n            'opcode::get': decimalnl_short\n            'opcode::binget': u1\n            'opcode::long_binget': u4\n            'opcode::put': decimalnl_short\n            'opcode::binput': u1\n            'opcode::long_binput': u4\n            'opcode::memoize': no_arg\n            'opcode::ext1': u1\n            'opcode::ext2': u2\n            'opcode::ext4': u4\n            'opcode::global_opcode':  stringnl_noescape_pair\n            'opcode::stack_global': no_arg\n            'opcode::reduce': no_arg\n            'opcode::build': no_arg\n            'opcode::inst': stringnl_noescape_pair\n            'opcode::obj': no_arg\n            'opcode::newobj': no_arg\n            'opcode::newobj_ex': no_arg\n            'opcode::proto': u1\n            'opcode::stop': no_arg\n            'opcode::frame': u8\n            'opcode::persid': stringnl_noescape\n            'opcode::binpersid': no_arg\n            'opcode::bytearray8': bytearray8\n            'opcode::next_buffer': no_arg\n            'opcode::readonly_buffer': no_arg\n        doc: |\n          Optional argument for the operation. Data type and length\n          are determined by the value of the opcode.\n\n  decimalnl_short:\n    doc: |\n      Integer or boolean, encoded with the ASCII characters [0-9-].\n\n      The values '00' and '01' encode the Python values `False` and `True`.\n      Normally a value would not contain leading '0' characters.\n    seq:\n      - id: val\n        type: str\n        encoding: ascii\n        terminator: 0x0a # \"\\n\"\n\n  decimalnl_long:\n    doc: Integer, encoded with the ASCII chracters [0-9-], followed by 'L'.\n    seq:\n      - id: val\n        type: str\n        encoding: ascii\n        terminator: 0x0a # \"\\n\"\n\n  # TODO Can kaitai express constraint that these are quoted?\n  stringnl:\n    doc: Quoted string, possibly containing Python string escapes.\n    seq:\n      - id: val\n        type: str\n        encoding: ascii\n        terminator: 0x0a # \"\\n\"\n\n  stringnl_noescape:\n    doc: Unquoted string, does not contain string escapes.\n    seq:\n      - id: val\n        type: str\n        encoding: ascii\n        terminator: 0x0a # \"\\n\"\n\n  stringnl_noescape_pair:\n    doc: Pair of unquoted, unescaped strings.\n    seq:\n      - id: val1\n        type: stringnl_noescape\n      - id: val2\n        type: stringnl_noescape\n\n  unicodestringnl:\n    doc: Unquoted string, containing Python Unicode escapes.\n    seq:\n      - id: val\n        type: str\n        encoding: ascii\n        terminator: 0x0a # \"\\n\"\n\n  floatnl:\n    doc: |\n      Double float, encoded with the ASCII characters [0-9.e+-], '-inf', 'inf',\n      or 'nan'.\n    seq:\n      - id: val\n        type: str\n        encoding: ascii\n        terminator: 0x0a # \"\\n\"\n\n  long1:\n    doc: |\n      Large signed integer, in the range -2**(8*255-1) to 2**(8*255-1)-1,\n      encoded as two's complement.\n    seq:\n      - id: len\n        type: u1\n      - id: val\n        size: len\n\n  long4:\n    doc: |\n      Large signed integer, in the range -2**(8*2**32-1) to 2**(8*2**32-1)-1,\n      encoded as two's complement.\n    seq:\n      - id: len\n        type: u4\n      - id: val\n        size: len\n\n  string1:\n    doc: |\n      Length prefixed string, between 0 and 255 bytes long. Encoding is\n      unspecified.\n\n      The default Python 2.x string type (`str`) is a sequence of bytes.\n      These are pickled as `string1` or `string4`, when protocol == 2.\n      The bytes are written directly, no explicit encoding is performed.\n\n      Python 3.x will not pickle an object as `string1` or `string4`.\n      Instead, opcodes and types with a known encoding are used.\n      When unpickling\n\n      - `pickle.Unpickler` objects default to ASCII, which can be overriden\n      - `pickletools.dis` uses latin1, and cannot be overriden\n    doc-ref: https://github.com/python/cpython/blob/bb8071a4cae/Lib/pickle.py#L486-L495\n    seq:\n      - id: len\n        type: u1\n      - id: val\n        size: len\n\n  string4:\n    doc: |\n      Length prefixed string, between 0 and 2**31-1 bytes long. Encoding is\n      unspecified.\n\n      Although the len field is signed, any length < 0 will raise an exception\n      during unpickling.\n\n      See the documentation for `string1` for further detail about encodings.\n    doc-ref: https://github.com/python/cpython/blob/bb8071a4cae/Lib/pickle.py#L486-L495\n    seq:\n      - id: len\n        # Not a typo, the length really is a signed integer\n        type: s4\n      - id: val\n        size: len\n\n  bytes1:\n    doc: Length prefixed byte string, between 0 and 255 bytes long.\n    seq:\n      - id: len\n        type: u1\n      - id: val\n        size: len\n\n  bytes4:\n    doc: Length prefixed string, between 0 and 2**32-1 bytes long\n    seq:\n      - id: len\n        type: u4\n      - id: val\n        size: len\n\n  bytes8:\n    doc: |\n      Length prefixed string, between 0 and 2**64-1 bytes long.\n\n      Only a 64-bit build of Python would produce a pickle containing strings\n      large enough to need this type. Such a pickle could not be unpickled on\n      a 32-bit build of Python, because the string would be larger than\n      `sys.maxsize`.\n    seq:\n      - id: len\n        type: u8\n      - id: val\n        size: len\n\n  bytearray8:\n    doc: |\n      Length prefixed string, between 0 and 2**64-1 bytes long.\n\n      The contents are deserilised into a `bytearray` object.\n    seq:\n      - id: len\n        type: u8\n      - id: val\n        size: len\n\n  unicodestring1:\n    doc: Length prefixed string, between 0 and 255 bytes long\n    seq:\n      - id: len\n        type: u1\n      - id: val\n        type: str\n        encoding: utf8\n        size: len\n\n  unicodestring4:\n    doc: Length prefixed string, between 0 and 2**32-1 bytes long\n    seq:\n      - id: len\n        type: u4\n      - id: val\n        type: str\n        encoding: utf8\n        size: len\n\n  unicodestring8:\n    doc: |\n      Length prefixed string, between 0 and 2**64-1 bytes long.\n\n      Only a 64-bit build of Python would produce a pickle containing strings\n      large enough to need this type. Such a pickle could not be unpickled on\n      a 32-bit build of Python, because the string would be larger than\n      `sys.maxsize`.\n    seq:\n      - id: len\n        type: u8\n      - id: val\n        type: str\n        encoding: utf8\n        size: len\n\n  no_arg:\n    doc: Some opcodes take no argument, this empty type is used for them.\n\nenums:\n  opcode:\n    0x28: # \"(\"\n      id: \"mark\"\n      -orig-id: MARK\n      doc: push special markobject on stack\n    0x2e: # \".\"\n      id: \"stop\"\n      -orig-id: STOP\n      doc: every pickle ends with STOP\n    0x30: # \"0\"\n      id: \"pop\"\n      -orig-id: POP\n      doc: discard topmost stack item\n    0x31: # \"1\"\n      id: \"pop_mark\"\n      -orig-id: POP_MARK\n      doc: discard stack top through topmost markobject\n    0x32: # \"2\"\n      id: \"dup\"\n      -orig-id: DUP\n      doc: duplicate top stack item\n    0x46: # \"F\"\n      id: \"float\"\n      -orig-id: FLOAT\n      doc: push float object; decimal string argument\n    0x49: # \"I\"\n      id: \"int\"\n      -orig-id: INT\n      doc: push integer or bool; decimal string argument\n    0x4a: # \"J\"\n      id: \"binint\"\n      -orig-id: BININT\n      doc: push four-byte signed int\n    0x4b: # \"K\"\n      id: \"binint1\"\n      -orig-id: BININT1\n      doc: push 1-byte unsigned int\n    0x4c: # \"L\"\n      id: \"long\"\n      -orig-id: LONG\n      doc: push long; decimal string argument\n    0x4d: # \"M\"\n      id: \"binint2\"\n      -orig-id: BININT2\n      doc: push 2-byte unsigned int\n    0x4e: # \"N\"\n      id: \"none\"\n      -orig-id: NONE\n      doc: push None\n    0x50: # \"P\"\n      id: \"persid\"\n      -orig-id: PERSID\n      doc: push persistent object; id is taken from string arg\n    0x51: # \"Q\"\n      id: \"binpersid\"\n      -orig-id: BINPERSID\n      doc: push persistent object; id is taken from stack\n    0x52: # \"R\"\n      id: \"reduce\"\n      -orig-id: REDUCE\n      doc: apply callable to argtuple, both on stack\n    0x53: # \"S\"\n      id: \"string\"\n      -orig-id: STRING\n      doc: push string; NL-terminated string argument\n    0x54: # \"T\"\n      id: \"binstring\"\n      -orig-id: BINSTRING\n      doc: push string; counted binary string argument\n    0x55: # \"U\"\n      id: \"short_binstring\"\n      -orig-id: SHORT_BINSTRING\n      doc: push string; counted binary string argument 256 bytes\n    0x56: # \"V\"\n      id: \"unicode\"\n      -orig-id: UNICODE\n      doc: push Unicode string; raw-unicode-escaped argument\n    0x58: # \"X\"\n      id: \"binunicode\"\n      -orig-id: BINUNICODE\n      doc: push Unicode string; counted UTF-8 string argument\n    0x61: # \"a\"\n      id: \"append\"\n      -orig-id: APPEND\n      doc: append stack top to list below it\n    0x62: # \"b\"\n      id: \"build\"\n      -orig-id: BUILD\n      doc: call __setstate__ or __dict__.update()\n    0x63: # \"c\"\n      id: \"global_opcode\"\n      -orig-id: GLOBAL\n      -affected-by: 90\n      doc: |\n        push self.find_class(modname, name); 2 string args\n\n        As of KSC 0.9, this enum key can't be called `global` because it would\n        cause a syntax error in Python (it is a keyword).\n    0x64: # \"d\"\n      id: \"dict\"\n      -orig-id: DICT\n      doc: build a dict from stack items\n    0x7d: # \"}\"\n      id: \"empty_dict\"\n      -orig-id: EMPTY_DICT\n      doc: push empty dict\n    0x65: # \"e\"\n      id: \"appends\"\n      -orig-id: APPENDS\n      doc: extend list on stack by topmost stack slice\n    0x67: # \"g\"\n      id: \"get\"\n      -orig-id: GET\n      doc: push item from memo on stack; index is string arg\n    0x68: # \"h\"\n      id: \"binget\"\n      -orig-id: BINGET\n      doc: push item from memo on stack; index is 1-byte arg\n    0x69: # \"i\"\n      id: \"inst\"\n      -orig-id: INST\n      doc: build & push class instance\n    0x6a: # \"j\"\n      id: \"long_binget\"\n      -orig-id: LONG_BINGET\n      doc: push item from memo on stack; index is 4-byte arg\n    0x6c: # \"l\"\n      id: \"list\"\n      -orig-id: LIST\n      doc: build list from topmost stack items\n    0x5d: # \"]\"\n      id: \"empty_list\"\n      -orig-id: EMPTY_LIST\n      doc: push empty list\n    0x6f: # \"o\"\n      id: \"obj\"\n      -orig-id: OBJ\n      doc: build & push class instance\n    0x70: # \"p\"\n      id: \"put\"\n      -orig-id: PUT\n      doc: store stack top in memo; index is string arg\n    0x71: # \"q\"\n      id: \"binput\"\n      -orig-id: BINPUT\n      doc: store stack top in memo; index is 1-byte arg\n    0x72: # \"r\"\n      id: \"long_binput\"\n      -orig-id: LONG_BINPUT\n      doc: store stack top in memo; index is 4-byte arg\n    0x73: # \"s\"\n      id: \"setitem\"\n      -orig-id: SETITEM\n      doc: add key+value pair to dict\n    0x74: # \"t\"\n      id: \"tuple\"\n      -orig-id: TUPLE\n      doc: build tuple from topmost stack items\n    0x29: # \")\"\n      id: \"empty_tuple\"\n      -orig-id: EMPTY_TUPLE\n      doc: push empty tuple\n    0x75: # \"u\"\n      id: \"setitems\"\n      -orig-id: SETITEMS\n      doc: modify dict by adding topmost key+value pairs\n    0x47: # \"G\"\n      id: \"binfloat\"\n      -orig-id: BINFLOAT\n      doc: push float; arg is 8-byte float encoding\n\n    # Protocol 2\n    0x80:\n      id: \"proto\"\n      -orig-id: PROTO\n      doc: identify pickle protocol\n    0x81:\n      id: \"newobj\"\n      -orig-id: NEWOBJ\n      doc: build object by applying cls.__new__ to argtuple\n    0x82:\n      id: \"ext1\"\n      -orig-id: EXT1\n      doc: push object from extension registry; 1-byte index\n    0x83:\n      id: \"ext2\"\n      -orig-id: EXT2\n      doc: ditto, but 2-byte index\n    0x84:\n      id: \"ext4\"\n      -orig-id: EXT4\n      doc: ditto, but 4-byte index\n    0x85:\n      id: \"tuple1\"\n      -orig-id: TUPLE1\n      doc: build 1-tuple from stack top\n    0x86:\n      id: \"tuple2\"\n      -orig-id: TUPLE2\n      doc: build 2-tuple from two topmost stack items\n    0x87:\n      id: \"tuple3\"\n      -orig-id: TUPLE3\n      doc: build 3-tuple from three topmost stack items\n    0x88:\n      id: \"newtrue\"\n      -orig-id: NEWTRUE\n      doc: push True\n    0x89:\n      id: \"newfalse\"\n      -orig-id: NEWFALSE\n      doc: push False\n    0x8a:\n      id: \"long1\"\n      -orig-id: LONG1\n      doc: push long from < 256 bytes\n    0x8b:\n      id: \"long4\"\n      -orig-id: LONG4\n      doc: push really big long\n\n    # Protocol 3 (Python 3.x)\n    0x42: # \"B\"\n      id: \"binbytes\"\n      -orig-id: BINBYTES\n      doc: push bytes; counted binary string argument\n    0x43: # \"C\"\n      id: \"short_binbytes\"\n      -orig-id: SHORT_BINBYTES\n      doc: push bytes; counted binary string argument < 256 bytes\n\n    # Protocol 4\n    0x8c:\n      id: \"short_binunicode\"\n      -orig-id: SHORT_BINUNICODE\n      doc: push short string; UTF-8 length < 256 bytes\n    0x8d:\n      id: \"binunicode8\"\n      -orig-id: BINUNICODE8\n      doc: push very long string\n    0x8e:\n      id: \"binbytes8\"\n      -orig-id: BINBYTES8\n      doc: push very long bytes string\n    0x8f:\n      id: \"empty_set\"\n      -orig-id: EMPTY_SET\n      doc: push empty set on the stack\n    0x90:\n      id: \"additems\"\n      -orig-id: ADDITEMS\n      doc: modify set by adding topmost stack items\n    0x91:\n      id: \"frozenset\"\n      -orig-id: FROZENSET\n      doc: build frozenset from topmost stack items\n    0x92:\n      id: \"newobj_ex\"\n      -orig-id: NEWOBJ_EX\n      doc: like NEWOBJ but work with keyword only arguments\n    0x93:\n      id: \"stack_global\"\n      -orig-id: STACK_GLOBAL\n      doc: same as GLOBAL but using names on the stacks\n    0x94:\n      id: \"memoize\"\n      -orig-id: MEMOIZE\n      doc: store top of the stack in memo\n    0x95:\n      id: \"frame\"\n      -orig-id: FRAME\n      doc: indicate the beginning of a new frame\n\n    # Protocol 5\n    0x96:\n      id: \"bytearray8\"\n      -orig-id: \"BYTEARRAY8\"\n      doc: push bytearray\n    0x97:\n      id: \"next_buffer\"\n      -orig-id: \"NEXT_BUFFER\"\n      doc: push next out-of-band buffer\n    0x98:\n      id: \"readonly_buffer\"\n      -orig-id: \"READONLY_BUFFER\"\n      doc: make top of stack readonly\n"
  },
  {
    "id": "ksy_ruby_marshal",
    "name": "Ruby Marshal",
    "category": "Serialization",
    "metadata": {
      "isGenerated": true,
      "fileExtensions": [],
      "description": "",
      "originalCategory": "serialization",
      "filePath": "serialization/ruby_marshal.ksy",
      "signature": {
        "offset": 0,
        "bytes": [
          4,
          8
        ]
      },
      "endian": "le"
    },
    "content": "meta:\n  id: ruby_marshal\n  license: CC0-1.0\n  endian: le\ndoc: |\n  Ruby's Marshal module allows serialization and deserialization of\n  many standard and arbitrary Ruby objects in a compact binary\n  format. It is relatively fast, available in stdlibs standard and\n  allows conservation of language-specific properties (such as symbols\n  or encoding-aware strings).\n\n  Feature-wise, it is comparable to other language-specific\n  implementations, such as:\n\n  * Java's\n    [Serializable](https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html)\n  * .NET\n    [BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter?view=net-7.0)\n  * Python's\n    [marshal](https://docs.python.org/3/library/marshal.html),\n    [pickle](https://docs.python.org/3/library/pickle.html) and\n    [shelve](https://docs.python.org/3/library/shelve.html)\n\n  From internal perspective, serialized stream consists of a simple\n  magic header and a record.\ndoc-ref: 'https://docs.ruby-lang.org/en/2.4.0/marshal_rdoc.html#label-Stream+Format'\nseq:\n  - id: version\n    contents: [4, 8]\n  - id: records\n    type: record\ntypes:\n  record:\n    doc: |\n      Each record starts with a single byte that determines its type\n      (`code`) and contents. If necessary, additional info as parsed\n      as `body`, to be determined by `code`.\n    seq:\n      - id: code\n        type: u1\n        enum: codes\n      - id: body\n        type:\n          switch-on: code\n          cases:\n            'codes::bignum': bignum\n            'codes::instance_var': instance_var\n            'codes::packed_int': packed_int\n            'codes::ruby_array': ruby_array\n            'codes::ruby_hash': ruby_hash\n            'codes::ruby_string': ruby_string\n            'codes::ruby_struct': ruby_struct\n            'codes::ruby_symbol': ruby_symbol\n            'codes::ruby_symbol_link': packed_int\n            'codes::ruby_object_link': packed_int\n  packed_int:\n    doc: |\n      Ruby uses sophisticated system to pack integers: first `code`\n      byte either determines packing scheme or carries encoded\n      immediate value (thus allowing smaller values from -123 to 122\n      (inclusive) to take only one byte. There are 11 encoding schemes\n      in total:\n\n      * 0 is encoded specially (as 0)\n      * 1..122 are encoded as immediate value with a shift\n      * 123..255 are encoded with code of 0x01 and 1 extra byte\n      * 0x100..0xffff are encoded with code of 0x02 and 2 extra bytes\n      * 0x10000..0xffffff are encoded with code of 0x03 and 3 extra\n        bytes\n      * 0x1000000..0xffffffff are encoded with code of 0x04 and 4\n        extra bytes\n      * -123..-1 are encoded as immediate value with another shift\n      * -256..-124 are encoded with code of 0xff and 1 extra byte\n      * -0x10000..-257 are encoded with code of 0xfe and 2 extra bytes\n      * -0x1000000..0x10001 are encoded with code of 0xfd and 3 extra\n         bytes\n      * -0x40000000..-0x1000001 are encoded with code of 0xfc and 4\n         extra bytes\n\n      Values beyond that are serialized as bignum (even if they\n      technically might be not Bignum class in Ruby implementation,\n      i.e. if they fit into 64 bits on a 64-bit platform).\n    doc-ref: 'https://docs.ruby-lang.org/en/2.4.0/marshal_rdoc.html#label-Fixnum+and+long'\n    seq:\n      - id: code\n        type: u1\n      - id: encoded\n        type:\n          switch-on: code\n          cases:\n            # 0x00: none\n            0x01: u1\n            0x02: u2\n            0x03: u2\n            0x04: u4\n            0xff: u1\n            0xfe: u2\n            0xfd: u2\n            0xfc: u4\n      - id: encoded2\n        type:\n          switch-on: code\n          cases:\n            0x03: u1\n            0xfd: u1\n        doc: |\n          One extra byte for 3-byte integers (0x03 and 0xfd), as\n          there is no standard `u3` type in KS.\n    instances:\n      is_immediate:\n        value: code > 4 and code < 0xfc\n      value:\n        value: >\n          is_immediate ? (code < 0x80 ? code - 5 : (4 - (~code & 0x7f))) :\n          code == 0 ? 0 :\n          code == 0xff ? (encoded - 0x100) :\n          code == 0xfe ? (encoded - 0x10000) :\n          code == 0xfd ? ((encoded2 << 16 | encoded) - 0x1000000) :\n          code == 0x03 ? (encoded2 << 16 | encoded) :\n          encoded\n  ruby_symbol:\n    doc-ref: 'https://docs.ruby-lang.org/en/2.4.0/marshal_rdoc.html#label-Symbols+and+Byte+Sequence'\n    seq:\n      - id: len\n        type: packed_int\n      - id: name\n        size: len.value\n        type: str\n        encoding: UTF-8\n  ruby_string:\n    doc-ref: 'https://docs.ruby-lang.org/en/2.4.0/marshal_rdoc.html#label-String'\n    seq:\n      - id: len\n        type: packed_int\n      - id: body\n        size: len.value\n  ruby_array:\n    seq:\n      - id: num_elements\n        type: packed_int\n      - id: elements\n        type: record\n        repeat: expr\n        repeat-expr: num_elements.value\n  ruby_hash:\n    doc-ref: 'https://docs.ruby-lang.org/en/2.4.0/marshal_rdoc.html#label-Hash+and+Hash+with+Default+Value'\n    seq:\n      - id: num_pairs\n        type: packed_int\n      - id: pairs\n        type: pair\n        repeat: expr\n        repeat-expr: num_pairs.value\n  bignum:\n    doc-ref: 'https://docs.ruby-lang.org/en/2.4.0/marshal_rdoc.html#label-Bignum'\n    seq:\n      - id: sign\n        type: u1\n        doc: A single byte containing `+` for a positive value or `-` for a negative value.\n      - id: len_div_2\n        type: packed_int\n        doc: Length of bignum body, divided by 2.\n      - id: body\n        size: len_div_2.value * 2\n        doc: Bytes that represent the number, see ruby-lang.org docs for reconstruction algorithm.\n  ruby_struct:\n    doc-ref: 'https://docs.ruby-lang.org/en/2.4.0/marshal_rdoc.html#label-Struct'\n    seq:\n      - id: name\n        type: record\n        doc: Symbol containing the name of the struct.\n      - id: num_members\n        type: packed_int\n        doc: Number of members in a struct\n      - id: members\n        type: pair\n        repeat: expr\n        repeat-expr: num_members.value\n  instance_var:\n    doc-ref: 'https://docs.ruby-lang.org/en/2.4.0/marshal_rdoc.html#label-Instance+Variables'\n    seq:\n      - id: obj\n        type: record\n      - id: num_vars\n        type: packed_int\n      - id: vars\n        type: pair\n        repeat: expr\n        repeat-expr: num_vars.value\n  pair:\n    seq:\n      - id: key\n        type: record\n      - id: value\n        type: record\nenums:\n  codes:\n    0x22: ruby_string\n    0x30: const_nil\n    0x3a: ruby_symbol\n    0x3b: ruby_symbol_link\n    0x40: ruby_object_link\n    0x46: const_false\n    0x49: instance_var\n    0x53: ruby_struct\n    0x54: const_true\n    0x5b: ruby_array\n    0x69: packed_int\n    0x6c: bignum\n    0x7b: ruby_hash\n"
  }
];

export default {
  category: "Serialization",
  formats: serializationFormats
};
